<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Open Space Ratio Web App (UTM Zone 47N/48N)</title>
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
  
  <style>
    html, body, #mapDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }
    #controlPanel {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 15px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      max-width: 350px;
      z-index: 1000;
      max-height: 80vh;
      overflow-y: auto;
    }
    #layerPanel {
      position: absolute;
      top: 20px;
      left: 20px;
      padding: 15px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      max-width: 300px;
      z-index: 1000;
    }
    #processingConfigPanel {
      position: absolute;
      bottom: 20px;
      left: 20px;
      padding: 15px;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      max-width: 300px;
      z-index: 1000;
    }
    .button {
      margin-top: 10px;
      padding: 8px 12px;
      background-color: #0079c1;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
    }
    .button:hover {
      background-color: #005e95;
    }
    .button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    .file-input-container {
      margin-bottom: 10px;
    }
    .field-selector {
      margin-top: 10px;
      width: 100%;
      padding: 5px;
    }
    .result-info {
      margin-top: 15px;
      padding: 10px;
      background-color: #f8f8f8;
      border-radius: 4px;
      font-size: 14px;
    }
    .loading {
      display: none;
      margin-top: 15px;
      text-align: center;
    }
    .progress-container {
      width: 100%;
      background-color: #f3f3f3;
      margin-top: 5px;
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-bar {
      height: 10px;
      background-color: #0079c1;
      width: 0%;
      transition: width 0.3s;
    }
    .panel-header {
      margin-bottom: 15px;
    }
    .panel-title {
      margin: 0;
      font-size: 18px;
      font-weight: bold;
      color: #333;
    }
    .layer-item {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
    }
    .layer-toggle {
      margin-right: 8px;
    }
    .layer-label {
      cursor: pointer;
      flex: 1;
    }
    .attribute-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
      margin-top: 10px;
    }
    .attribute-table th,
    .attribute-table td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: left;
    }
    .attribute-table th {
      background-color: #0079c1;
      color: white;
      font-weight: bold;
    }
    .attribute-table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    .attribute-panel {
      max-height: 400px;
      overflow-y: auto;
      margin-top: 10px;
    }
    .info-popup {
      max-height: 200px;
      overflow-y: auto;
    }
    .crs-selector {
      margin-top: 10px;
      margin-bottom: 5px;
    }
    .export-options {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .export-button {
      flex: 1;
      min-width: 100px;
    }
    .home-button {
      position: absolute;
      top: 15px;
      right: 15px;
      z-index: 1001;
    }
    .home-button a {
      display: block;
      padding: 8px;
      color: #0079c1;
      background-color: white;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      text-decoration: none;
      text-align: center;
    }
    .home-button a:hover {
      background-color: #f0f0f0;
    }
    .home-button i {
      font-size: 18px;
    }
    .config-item {
      margin-bottom: 10px;
    }
    .config-label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }
    .log-container {
      background-color: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 10px;
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 12px;
      margin-top: 10px;
    }
    .log-entry {
      margin-bottom: 4px;
      word-wrap: break-word;
    }
    .log-info {
      color: #0079c1;
    }
    .log-warning {
      color: #ff9800;
    }
    .log-error {
      color: #f44336;
    }
    .toggle-label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
      margin-right: 8px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .toggle-slider {
      background-color: #0079c1;
    }
    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    .file-type-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }
    .file-type-btn {
      flex: 1;
      padding: 8px 12px;
      background-color: #f0f0f0;
      color: #333;
      border: 2px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s;
    }
    .file-type-btn:hover {
      background-color: #e0e0e0;
    }
    .file-type-btn.active {
      background-color: #0079c1;
      color: white;
      border-color: #0079c1;
    }
    .file-input-label {
      display: block;
      font-weight: 600;
      margin-bottom: 5px;
      color: #333;
      font-size: 14px;
    }
    .file-status {
      margin-top: 5px;
      padding: 8px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
    }
    .file-status.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .file-status.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
  </style>
</head>
<body>
  <div id="mapDiv"></div>
  
  <!-- Main Control Panel -->
  <div id="controlPanel">
    <div class="panel-header">
      <h2 class="panel-title">Open Space Ratio Web App</h2>
      <div class="home-button">
        <a href="page11.html" title="Back to Main Page">
          <i class="fas fa-home"></i>
        </a>
      </div>
    </div>
    
    <!-- UTM Zone Selector -->
    <div class="crs-selector">
      <label for="coordSystem">UTM Coordinate System:</label>
      <select id="coordSystem" class="field-selector">
        <option value="EPSG:32647">EPSG:32647 (UTM Zone 47N)</option>
        <option value="EPSG:32648">EPSG:32648 (UTM Zone 48N)</option>
      </select>
    </div>
    
    <!-- Building File Input -->
    <div class="file-input-container">
      <label class="file-input-label">1. Upload Building Data:</label>
      
      <div class="file-type-selector">
        <button class="file-type-btn active" id="btnBuildingGeoJSON" type="button">GeoJSON</button>
        <button class="file-type-btn" id="btnBuildingShapefile" type="button">Shapefile (ZIP)</button>
      </div>
      
      <input type="file" id="buildingFile" accept=".geojson,.json" style="display:block;">
      <input type="file" id="buildingShapefileFile" accept=".zip" style="display:none;">
      
      <div id="buildingStatus" class="file-status"></div>
    </div>
    
    <!-- Parcel File Input -->
    <div class="file-input-container">
      <label class="file-input-label">2. Upload Land Parcel Data:</label>
      
      <div class="file-type-selector">
        <button class="file-type-btn active" id="btnParcelGeoJSON" type="button">GeoJSON</button>
        <button class="file-type-btn" id="btnParcelShapefile" type="button">Shapefile (ZIP)</button>
      </div>
      
      <input type="file" id="parcelFile" accept=".geojson,.json" style="display:block;">
      <input type="file" id="parcelShapefileFile" accept=".zip" style="display:none;">
      
      <div id="parcelStatus" class="file-status"></div>
    </div>
    
    <div id="fieldSelectorContainer" style="display:none;">
      <label for="parcelFieldSelector">Select Parcel Identifier Field:</label>
      <select id="parcelFieldSelector" class="field-selector"></select>
    </div>
    
    <button id="processStep1" class="button" disabled>3.1 Calculate Parcel Area</button>
    <div id="step1Result" class="result-info" style="display:none;"></div>
    
    <button id="processStep2" class="button" disabled>3.2 Extract Parcel Information</button>
    <div id="step2Result" class="result-info" style="display:none;"></div>
    
    <button id="processStep3" class="button" disabled>3.3 Calculate Total Building Area</button>
    <div id="step3Result" class="result-info" style="display:none;"></div>
    
    <button id="processStep4" class="button" disabled>3.4 Calculate OSR</button>
    <div id="step4Result" class="result-info" style="display:none;"></div>
    
    <div class="export-options">
      <button id="exportButton" class="button export-button" disabled>Export GeoJSON</button>
      <button id="exportExcelButton" class="button export-button" disabled>Export Excel</button>
      <button id="exportShapefileButton" class="button export-button" disabled>Export Shapefile</button>
    </div>
    
    <button id="runAllSteps" class="button" style="background-color: #28a745;" disabled>Run All Steps</button>
    
    <div id="loadingIndicator" class="loading">
      <i class="fas fa-cog fa-spin"></i> Processing...<span id="processingStatus"></span>
      <div class="progress-container">
        <div id="progressBar" class="progress-bar"></div>
      </div>
    </div>
    
    <hr>
    
    <!-- Attribute Viewer Section -->
    <div class="panel-header">
      <h3 class="panel-title">Attribute Viewer</h3>
    </div>
    
    <div>
      <label for="layerSelect">Select Layer for Attributes:</label>
      <select id="layerSelect" class="field-selector">
        <option value="">-- Select a layer --</option>
      </select>
    </div>
    
    <div id="attributePanel" class="attribute-panel" style="display:none;">
      <div id="attributeContent"></div>
    </div>
  </div>
  
  <!-- Layer Control Panel -->
  <div id="layerPanel">
    <div class="panel-header">
      <h3 class="panel-title">Map Layers</h3>
    </div>
    <div id="layerList">
      <div class="layer-item">
        <span class="layer-label">No layers available</span>
      </div>
    </div>
  </div>
  
  <!-- Processing Configuration Panel -->
  <div id="processingConfigPanel">
    <div class="panel-header">
      <h3 class="panel-title">Processing Options</h3>
    </div>
    
    <div class="config-item">
      <label class="toggle-label">
        <div class="toggle-switch">
          <input type="checkbox" id="useWebWorkers" checked>
          <span class="toggle-slider"></span>
        </div>
        <span>Use Web Workers (faster)</span>
      </label>
    </div>
    
    <div class="config-item">
      <label class="config-label">Batch Size:</label>
      <input type="number" id="batchSize" value="100" min="10" max="1000" style="width: 100%; padding: 5px;">
    </div>
    
    <div class="config-item">
      <label class="config-label">Processing Delay (ms):</label>
      <input type="number" id="processingDelay" value="10" min="0" max="1000" style="width: 100%; padding: 5px;">
    </div>
    
    <hr>
    
    <div class="config-item">
      <button id="toggleLogButton" class="button" style="background-color: #6c757d;">
        <i class="fas fa-list"></i> Toggle Log
      </button>
    </div>
    
    <div id="logContainer" class="log-container" style="display: none;">
      <div id="logContent"></div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
  
  <!-- Turf.js for geospatial analysis -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
  
  <!-- SheetJS for Excel export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  
  <!-- Libraries for Shapefile processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/shpjs/3.6.3/shp.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
  
  <script>
    // Define UTM projections for Thailand
    proj4.defs([
      ['EPSG:32647', '+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs'],
      ['EPSG:32648', '+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs']
    ]);
  </script>

  <!-- Web Worker Script -->
  <script id="workerScript" type="text/worker-script">
    // Import libraries
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js');
    importScripts('https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js');
    
    // Define UTM projections
    proj4.defs("EPSG:32647", "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs");
    proj4.defs("EPSG:32648", "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs");
    
    // Shoelace formula for polygon area calculation
    function polygonArea(coords) {
      let area = 0;
      const numPoints = coords.length;
      
      if (numPoints < 3) return 0;
      
      for (let i = 0; i < numPoints - 1; i++) {
        area += coords[i][0] * coords[i+1][1] - coords[i+1][0] * coords[i][1];
      }
      
      area += coords[numPoints-1][0] * coords[0][1] - coords[0][0] * coords[numPoints-1][1];
      
      return Math.abs(area / 2);
    }
    
    // Calculate area in UTM coordinates
    function calculateAreaUTM(geometry) {
      let area = 0;
      
      if (geometry.type === 'Polygon') {
        area = polygonArea(geometry.coordinates[0]);
        // Subtract holes
        for (let i = 1; i < geometry.coordinates.length; i++) {
          area -= polygonArea(geometry.coordinates[i]);
        }
      } else if (geometry.type === 'MultiPolygon') {
        for (const polygon of geometry.coordinates) {
          area += polygonArea(polygon[0]);
          for (let i = 1; i < polygon.length; i++) {
            area -= polygonArea(polygon[i]);
          }
        }
      }
      
      return Math.abs(area);
    }
    
    // Process parcel area batch
    function processParcelAreaBatch(batchData) {
      const { parcelBatch, selectedCRS, startIndex, endIndex, originalGeometries } = batchData;
      const processedParcels = [];
      
      for (let i = 0; i < parcelBatch.length; i++) {
        try {
          const parcel = parcelBatch[i];
          const parcelIndex = startIndex + i;
          
          self.postMessage({
            type: 'progress',
            message: `Processing parcel ${parcelIndex + 1}/${endIndex}`,
            index: parcelIndex,
            total: endIndex
          });
          
          // Calculate area using UTM calculation (parcel มีพิกัด UTM)
          const area = calculateAreaUTM(parcel.geometry);
          
          // ใช้ originalGeometries (WGS84) สำหรับแสดงผล
          const geometryToUse = originalGeometries ? originalGeometries[i] : parcel.geometry;
          
          const processedParcel = {
            type: "Feature",
            properties: {
              ...parcel.properties,
              parcelArea: Math.round(area * 100) / 100
            },
            geometry: geometryToUse
          };
          
          processedParcels.push(processedParcel);
        } catch (error) {
          self.postMessage({
            type: 'log',
            level: 'error',
            message: `Error processing parcel ${startIndex + i}: ${error.message}`
          });
        }
      }
      
      return processedParcels;
    }
    
    // Process building points batch
    function processBuildingPointsBatch(batchData) {
      const { buildingBatch, parcelGeojson, selectedField, startIndex, endIndex } = batchData;
      const buildingPoints = [];
      
      for (let i = 0; i < buildingBatch.length; i++) {
        try {
          const building = buildingBatch[i];
          const buildingIndex = startIndex + i;
          
          self.postMessage({
            type: 'progress',
            message: `Processing building ${buildingIndex + 1}/${endIndex}`,
            index: buildingIndex,
            total: endIndex
          });
          
          let centerCoords;
          
          if (building.geometry.type === "Polygon") {
            const centroid = turf.centroid(building);
            centerCoords = centroid.geometry.coordinates;
          } else if (building.geometry.type === "MultiPolygon") {
            const firstPolygon = {
              type: "Feature",
              properties: {},
              geometry: {
                type: "Polygon",
                coordinates: building.geometry.coordinates[0]
              }
            };
            const centroid = turf.centroid(firstPolygon);
            centerCoords = centroid.geometry.coordinates;
          } else {
            throw new Error(`Unsupported geometry type: ${building.geometry.type}`);
          }
          
          const pointFeature = {
            type: "Feature",
            properties: {
              ...building.properties,
              parcelId: null,
              parcelName: null,
              buildingArea: typeof building.properties.BL_AREA === 'number' ? building.properties.BL_AREA : 0,
              buildingStoreys: typeof building.properties.BL_NSTOREY === 'number' ? building.properties.BL_NSTOREY : 1
            },
            geometry: {
              type: "Point",
              coordinates: centerCoords
            }
          };
          
          for (const parcel of parcelGeojson.features) {
            if (turf.booleanPointInPolygon(pointFeature.geometry.coordinates, parcel.geometry)) {
              pointFeature.properties.parcelId = parcel.properties[selectedField];
              pointFeature.properties.parcelName = parcel.properties[selectedField];
              break;
            }
          }
          
          buildingPoints.push(pointFeature);
        } catch (error) {
          self.postMessage({
            type: 'log',
            level: 'warning',
            message: `Error creating point for building ${startIndex + i}: ${error.message}`
          });
        }
      }
      
      return buildingPoints;
    }
    
    // Process building areas batch
    function processBuildingAreasBatch(batchData) {
      const { parcelBatch, buildingGeojson, selectedField, startIndex, endIndex } = batchData;
      const processedParcels = [];
      
      for (let i = 0; i < parcelBatch.length; i++) {
        try {
          const parcel = parcelBatch[i];
          const parcelIndex = startIndex + i;
          
          self.postMessage({
            type: 'progress',
            message: `Processing parcel ${parcelIndex + 1}/${endIndex}`,
            index: parcelIndex,
            total: endIndex
          });
          
          const parcelId = parcel.properties[selectedField];
          let totalBuildingOneFloor = 0;  // BL_AREA only
          let totalBuildingAllFloor = 0;  // BL_AREA * BL_NSTOREY
          let buildingCount = 0;
          
          for (const building of buildingGeojson.features) {
            try {
              let center;
              
              if (building.geometry.type === "Polygon") {
                const centroid = turf.centroid(building);
                center = centroid.geometry.coordinates;
              } else if (building.geometry.type === "MultiPolygon") {
                const firstPolygon = {
                  type: "Feature",
                  properties: {},
                  geometry: {
                    type: "Polygon",
                    coordinates: building.geometry.coordinates[0]
                  }
                };
                const centroid = turf.centroid(firstPolygon);
                center = centroid.geometry.coordinates;
              } else {
                continue;
              }
              
              if (turf.booleanPointInPolygon(center, parcel.geometry)) {
                const buildingArea = typeof building.properties.BL_AREA === 'number' ? building.properties.BL_AREA : 0;
                const buildingStoreys = typeof building.properties.BL_NSTOREY === 'number' ? building.properties.BL_NSTOREY : 1;
                
                // คำนวณทั้งสองแบบ
                totalBuildingOneFloor += buildingArea;  // BL_AREA only
                totalBuildingAllFloor += buildingArea * buildingStoreys;  // BL_AREA * BL_NSTOREY
                buildingCount++;
              }
            } catch (err) {
              // Skip this building
            }
          }
          
          const processedParcel = {
            type: "Feature",
            properties: {
              ...parcel.properties,
              parcelArea: parcel.properties.parcelArea, // เก็บ parcelArea จาก step1
              totalBuildingOneFloor: Math.round(totalBuildingOneFloor * 100) / 100,
              totalBuildingAllFloor: Math.round(totalBuildingAllFloor * 100) / 100,
              buildingCount: buildingCount
            },
            geometry: parcel.geometry
          };
          
          processedParcels.push(processedParcel);
        } catch (error) {
          self.postMessage({
            type: 'log',
            level: 'error',
            message: `Error processing parcel ${startIndex + i}: ${error.message}`
          });
        }
      }
      
      return processedParcels;
    }
    
    // Calculate OSR batch
    function calculateOSRBatch(batchData) {
      const { parcelBatch, startIndex, endIndex } = batchData;
      const processedParcels = [];
      
      for (let i = 0; i < parcelBatch.length; i++) {
        const parcel = parcelBatch[i];
        const totalBuildingOneFloor = parcel.properties.totalBuildingOneFloor || 0;
        const totalBuildingAllFloor = parcel.properties.totalBuildingAllFloor || 0;
        const parcelArea = parcel.properties.parcelArea || 0;
        
        // คำนวณ Open Space Area = Parcel Area - Total Building One Floor
        const openSpaceArea = parcelArea - totalBuildingOneFloor;
        
        // คำนวณ OSR = (Open Space Area / Total Building All Floor) × 100
        let osr = 0;
        if (totalBuildingAllFloor > 0) {
          osr = (openSpaceArea / totalBuildingAllFloor) * 100;
        }
        
        processedParcels.push({
          type: "Feature",
          properties: {
            ...parcel.properties,
            openSpaceArea: Math.round(openSpaceArea * 100) / 100,
            OSR: Math.round(osr * 100) / 100
          },
          geometry: parcel.geometry
        });
      }
      
      return processedParcels;
    }
    
    // Main worker message handler
    self.onmessage = function(e) {
      const { command } = e.data;
      let result;
      
      try {
        switch(command) {
          case 'processParcelArea':
            result = processParcelAreaBatch(e.data);
            break;
          case 'processBuildingPoints':
            result = processBuildingPointsBatch(e.data);
            break;
          case 'processBuildingAreas':
            result = processBuildingAreasBatch(e.data);
            break;
          case 'calculateOSR':
            result = calculateOSRBatch(e.data);
            break;
          default:
            self.postMessage({ 
              type: 'error', 
              message: 'Unknown command type' 
            });
            return;
        }
        
        self.postMessage({
          type: 'result',
          batchIndex: e.data.batchIndex,
          features: result
        });
      } catch (error) {
        self.postMessage({
          type: 'error',
          message: error.message
        });
      }
    };
  </script>

  <script>
    // ===== GLOBAL VARIABLES =====
    let map;
    let buildingLayer;
    let parcelLayer;
    let resultLayer;
    let buildingGeojson = null;
    let parcelGeojson = null;
    let resultGeojson = null;
    let parcelOriginalShapes = null;
    let parcelFields = [];
    let currentCRS = 'EPSG:32647';
    let allLayers = [];
    let layerData = {};
    let processFlags = {
      step1: false,
      step2: false,
      step3: false,
      step4: false
    };
    
    // Web Worker variables
    let workers = [];
    let useWebWorkers = true;
    const NUM_WORKERS = 4;
    let isProcessing = false;
    
    // Batch processing variables
    let batchSize = 100;
    let processingDelay = 10;
    let batchResults = [];
    let currentBatch = 0;
    let totalBatches = 0;
    let currentStep = '';
    let batchStats = {
      startTime: 0,
      endTime: 0,
      featureCount: 0
    };
    let runningAllSteps = false;
    
    // ===== MAP INITIALIZATION =====
    function initMap() {
      if (map) {
        map.remove();
      }
      
      currentCRS = document.getElementById('coordSystem').value;
      
      map = L.map('mapDiv', {
        center: [13.7563, 100.5018],
        zoom: 12,
        zoomControl: true
      });
      
      const baseMaps = {
        'OpenStreetMap': L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          maxZoom: 19,
          attribution: '© OpenStreetMap contributors'
        }),
        'Satellite (ESRI)': L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
          maxZoom: 19,
          attribution: 'ESRI World Imagery'
        }),
        'CartoDB Positron': L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
          maxZoom: 19,
          attribution: '© OpenStreetMap, © CartoDB'
        })
      };
      
      baseMaps['OpenStreetMap'].addTo(map);
      L.control.layers(baseMaps, {}, { position: 'topright' }).addTo(map);
      
      buildingLayer = L.geoJSON(null, {
        style: { color: '#ff7800', weight: 2 },
        onEachFeature: addPopup
      }).addTo(map);
      
      parcelLayer = L.geoJSON(null, {
        style: { color: '#0078d7', weight: 2, fillOpacity: 0.2 },
        onEachFeature: addPopup
      }).addTo(map);
      
      resultLayer = L.geoJSON(null, {
        style: { color: '#28a745', weight: 3, fillOpacity: 0.3 },
        onEachFeature: addPopup
      }).addTo(map);
      
      logMessage(`Map initialized with ${currentCRS}`, 'info');
    }
    
    function addPopup(feature, layer) {
      if (feature.properties) {
        let popupContent = '<div class="info-popup"><b>Properties:</b><br>';
        for (let key in feature.properties) {
          popupContent += `${key}: ${feature.properties[key]}<br>`;
        }
        popupContent += '</div>';
        layer.bindPopup(popupContent);
      }
    }
    
    // ===== COORDINATE TRANSFORMATION =====
    
    function convertUTMToWGS84(geojson, utmZone) {
      const clonedGeoJSON = JSON.parse(JSON.stringify(geojson));
      
      clonedGeoJSON.features.forEach(feature => {
        turf.coordEach(feature, (coord) => {
          if (Math.abs(coord[0]) > 180) {
            const wgs84 = proj4(utmZone, "EPSG:4326", coord);
            coord[0] = wgs84[0];
            coord[1] = wgs84[1];
          }
        });
      });
      
      return clonedGeoJSON;
    }
    
    function convertWGS84ToUTM(geojson, utmZone) {
      const clonedGeoJSON = JSON.parse(JSON.stringify(geojson));
      
      clonedGeoJSON.features.forEach(feature => {
        turf.coordEach(feature, (coord) => {
          if (Math.abs(coord[0]) <= 180) {
            const utm = proj4("EPSG:4326", utmZone, coord);
            coord[0] = utm[0];
            coord[1] = utm[1];
          }
        });
      });
      
      return clonedGeoJSON;
    }
    
    // ===== FILE UPLOAD HANDLERS =====
    
    function showStatus(elementId, message, isSuccess) {
      const statusEl = document.getElementById(elementId);
      if (!message) {
        statusEl.style.display = 'none';
        return;
      }
      
      statusEl.style.display = 'block';
      statusEl.textContent = message;
      statusEl.className = 'file-status ' + (isSuccess ? 'success' : 'error');
    }
    
    // Building file type buttons
    document.getElementById('btnBuildingGeoJSON').addEventListener('click', function() {
      document.getElementById('buildingFile').style.display = 'block';
      document.getElementById('buildingShapefileFile').style.display = 'none';
      document.getElementById('buildingFile').value = '';
      document.getElementById('buildingShapefileFile').value = '';
      
      this.classList.add('active');
      document.getElementById('btnBuildingShapefile').classList.remove('active');
      showStatus('buildingStatus', '', false);
    });
    
    document.getElementById('btnBuildingShapefile').addEventListener('click', function() {
      document.getElementById('buildingFile').style.display = 'none';
      document.getElementById('buildingShapefileFile').style.display = 'block';
      document.getElementById('buildingFile').value = '';
      document.getElementById('buildingShapefileFile').value = '';
      
      this.classList.add('active');
      document.getElementById('btnBuildingGeoJSON').classList.remove('active');
      showStatus('buildingStatus', '', false);
    });
    
    // Parcel file type buttons
    document.getElementById('btnParcelGeoJSON').addEventListener('click', function() {
      document.getElementById('parcelFile').style.display = 'block';
      document.getElementById('parcelShapefileFile').style.display = 'none';
      document.getElementById('parcelFile').value = '';
      document.getElementById('parcelShapefileFile').value = '';
      
      this.classList.add('active');
      document.getElementById('btnParcelShapefile').classList.remove('active');
      showStatus('parcelStatus', '', false);
    });
    
    document.getElementById('btnParcelShapefile').addEventListener('click', function() {
      document.getElementById('parcelFile').style.display = 'none';
      document.getElementById('parcelShapefileFile').style.display = 'block';
      document.getElementById('parcelFile').value = '';
      document.getElementById('parcelShapefileFile').value = '';
      
      this.classList.add('active');
      document.getElementById('btnParcelGeoJSON').classList.remove('active');
      showStatus('parcelStatus', '', false);
    });
    
    // Building GeoJSON upload
    document.getElementById('buildingFile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const geojson = JSON.parse(event.target.result);
          const utmZone = document.getElementById('coordSystem').value;
          const wgs84GeoJSON = convertUTMToWGS84(geojson, utmZone);
          
          buildingGeojson = wgs84GeoJSON;
          buildingLayer.clearLayers().addData(wgs84GeoJSON);
          map.fitBounds(buildingLayer.getBounds());
          
          showStatus('buildingStatus', `✓ Loaded ${wgs84GeoJSON.features.length} buildings`, true);
          addGeoJSONToMap(wgs84GeoJSON, 'building', 'Buildings');
          checkEnableProcessing();
          resetProcessFlags();
        } catch (error) {
          showStatus('buildingStatus', '✗ Error: ' + error.message, false);
        }
      };
      reader.readAsText(file);
    });
    
    // Building Shapefile upload
    document.getElementById('buildingShapefileFile').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const geojson = await shp(arrayBuffer);
        
        let fc;
        if (Array.isArray(geojson)) {
          fc = geojson[0];
        } else if (geojson.type === 'FeatureCollection') {
          fc = geojson;
        } else {
          throw new Error('Invalid Shapefile format');
        }
        
        const utmZone = document.getElementById('coordSystem').value;
        const wgs84GeoJSON = convertUTMToWGS84(fc, utmZone);
        
        buildingGeojson = wgs84GeoJSON;
        buildingLayer.clearLayers().addData(wgs84GeoJSON);
        map.fitBounds(buildingLayer.getBounds());
        
        showStatus('buildingStatus', `✓ Loaded ${wgs84GeoJSON.features.length} buildings (Shapefile)`, true);
        addGeoJSONToMap(wgs84GeoJSON, 'building', 'Buildings');
        checkEnableProcessing();
        resetProcessFlags();
      } catch (error) {
        showStatus('buildingStatus', '✗ Error: ' + error.message, false);
      }
    });
    
    // Parcel GeoJSON upload
    document.getElementById('parcelFile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const geojson = JSON.parse(event.target.result);
          const utmZone = document.getElementById('coordSystem').value;
          const wgs84GeoJSON = convertUTMToWGS84(geojson, utmZone);
          
          parcelGeojson = wgs84GeoJSON;
          parcelLayer.clearLayers().addData(wgs84GeoJSON);
          map.fitBounds(parcelLayer.getBounds());
          
          updateParcelFieldSelector(wgs84GeoJSON);
          
          showStatus('parcelStatus', `✓ Loaded ${wgs84GeoJSON.features.length} parcels`, true);
          addGeoJSONToMap(wgs84GeoJSON, 'parcel', 'Land Parcels');
          checkEnableProcessing();
          resetProcessFlags();
        } catch (error) {
          showStatus('parcelStatus', '✗ Error: ' + error.message, false);
        }
      };
      reader.readAsText(file);
    });
    
    // Parcel Shapefile upload
    document.getElementById('parcelShapefileFile').addEventListener('change', async function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      try {
        const arrayBuffer = await file.arrayBuffer();
        const geojson = await shp(arrayBuffer);
        
        let fc;
        if (Array.isArray(geojson)) {
          fc = geojson[0];
        } else if (geojson.type === 'FeatureCollection') {
          fc = geojson;
        } else {
          throw new Error('Invalid Shapefile format');
        }
        
        const utmZone = document.getElementById('coordSystem').value;
        const wgs84GeoJSON = convertUTMToWGS84(fc, utmZone);
        
        parcelGeojson = wgs84GeoJSON;
        parcelLayer.clearLayers().addData(wgs84GeoJSON);
        map.fitBounds(parcelLayer.getBounds());
        
        updateParcelFieldSelector(wgs84GeoJSON);
        
        showStatus('parcelStatus', `✓ Loaded ${wgs84GeoJSON.features.length} parcels (Shapefile)`, true);
        addGeoJSONToMap(wgs84GeoJSON, 'parcel', 'Land Parcels');
        checkEnableProcessing();
        resetProcessFlags();
      } catch (error) {
        showStatus('parcelStatus', '✗ Error: ' + error.message, false);
      }
    });
    
    // ===== HELPER FUNCTIONS =====
    
    function checkEnableProcessing() {
      if (buildingGeojson && parcelGeojson) {
        document.getElementById('processStep1').disabled = false;
        document.getElementById('runAllSteps').disabled = false;
      }
    }
    
    function updateParcelFieldSelector(geojson) {
      const selector = document.getElementById('parcelFieldSelector');
      selector.innerHTML = '';
      
      if (geojson.features.length > 0) {
        const props = geojson.features[0].properties;
        Object.keys(props).forEach(key => {
          const option = document.createElement('option');
          option.value = key;
          option.textContent = key;
          selector.appendChild(option);
        });
        
        document.getElementById('fieldSelectorContainer').style.display = 'block';
      }
    }
    
    function resetProcessFlags() {
      processFlags = {
        step1: false,
        step2: false,
        step3: false,
        step4: false
      };
      
      document.getElementById('step1Result').style.display = 'none';
      document.getElementById('step2Result').style.display = 'none';
      document.getElementById('step3Result').style.display = 'none';
      document.getElementById('step4Result').style.display = 'none';
      
      document.getElementById('processStep2').disabled = true;
      document.getElementById('processStep3').disabled = true;
      document.getElementById('processStep4').disabled = true;
      document.getElementById('exportButton').disabled = true;
      document.getElementById('exportExcelButton').disabled = true;
      document.getElementById('exportShapefileButton').disabled = true;
    }
    
    function addGeoJSONToMap(geojson, layerId, layerTitle) {
      const style = layerId === 'building' ? { color: '#ff7800', weight: 2 } :
                    layerId === 'parcel' ? { color: '#0078d7', weight: 2, fillOpacity: 0.2 } :
                    { color: '#28a745', weight: 3, fillOpacity: 0.3 };
      
      const layer = L.geoJSON(geojson, {
        style: style,
        onEachFeature: addPopup
      });
      
      if (layerId === 'building') {
        buildingLayer = layer.addTo(map);
      } else if (layerId === 'parcel') {
        parcelLayer = layer.addTo(map);
      } else {
        resultLayer = layer.addTo(map);
      }
      
      addLayerToControl(layer, layerId, layerTitle, geojson);
      
      try {
        map.fitBounds(layer.getBounds());
      } catch (e) {
        logMessage("Could not zoom to layer bounds", 'warning');
      }
    }
    
    function addLayerToControl(layer, layerId, layerTitle, geojson) {
      if (layerData[layerId]) {
        const idx = allLayers.indexOf(layerData[layerId].layer);
        if (idx > -1) {
          allLayers.splice(idx, 1);
        }
      }
      
      allLayers.push(layer);
      layerData[layerId] = {
        layer: layer,
        title: layerTitle,
        geojson: geojson
      };
      
      const layerSelect = document.getElementById('layerSelect');
      let optionExists = false;
      for (let i = 0; i < layerSelect.options.length; i++) {
        if (layerSelect.options[i].value === layerId) {
          optionExists = true;
          break;
        }
      }
      
      if (!optionExists) {
        const option = document.createElement('option');
        option.value = layerId;
        option.textContent = layerTitle;
        layerSelect.appendChild(option);
      }
      
      updateLayerControlPanel();
    }
    
    function updateLayerControlPanel() {
      const layerList = document.getElementById('layerList');
      layerList.innerHTML = '';
      
      Object.keys(layerData).reverse().forEach(id => {
        const layer = layerData[id];
        
        const layerItem = document.createElement('div');
        layerItem.className = 'layer-item';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'layer-toggle';
        checkbox.checked = map.hasLayer(layer.layer);
        checkbox.dataset.layerId = id;
        checkbox.addEventListener('change', function() {
          if (this.checked) {
            if (!map.hasLayer(layer.layer)) {
              map.addLayer(layer.layer);
            }
          } else {
            if (map.hasLayer(layer.layer)) {
              map.removeLayer(layer.layer);
            }
          }
        });
        
        const label = document.createElement('label');
        label.className = 'layer-label';
        label.textContent = layer.title;
        
        layerItem.appendChild(checkbox);
        layerItem.appendChild(label);
        layerList.appendChild(layerItem);
      });
    }
    
    function displayAttributes(layerId) {
      const attributePanel = document.getElementById('attributePanel');
      const attributeContent = document.getElementById('attributeContent');
      
      if (!layerId || !layerData[layerId]) {
        attributePanel.style.display = 'none';
        return;
      }
      
      const layer = layerData[layerId];
      const geojson = layer.geojson;
      
      if (!geojson || !geojson.features || geojson.features.length === 0) {
        attributeContent.innerHTML = '<p>No attribute data available.</p>';
        attributePanel.style.display = 'block';
        return;
      }
      
      let html = `<h4>${layer.title} Attributes</h4>`;
      html += '<table class="attribute-table">';
      
      let fieldsToDisplay = [];
      if (geojson.features.length > 0 && geojson.features[0].properties) {
        fieldsToDisplay = Object.keys(geojson.features[0].properties);
      }
      
      html += '<tr><th>FID</th>';
      fieldsToDisplay.forEach(prop => {
        html += `<th>${prop}</th>`;
      });
      html += '</tr>';
      
      geojson.features.forEach((feature, index) => {
        html += '<tr>';
        html += `<td>${index}</td>`;
        
        fieldsToDisplay.forEach(prop => {
          const value = feature.properties ? feature.properties[prop] : '';
          html += `<td>${value !== undefined && value !== null ? value : ''}</td>`;
        });
        
        html += '</tr>';
      });
      
      html += '</table>';
      
      attributeContent.innerHTML = html;
      attributePanel.style.display = 'block';
    }
    
    // ===== WEB WORKERS =====
    
    function createWorkers() {
      if (!useWebWorkers) return;
      
      terminateWorkers();
      
      const workerScript = document.getElementById('workerScript').textContent;
      const blob = new Blob([workerScript], { type: 'text/javascript' });
      const workerURL = URL.createObjectURL(blob);
      
      for (let i = 0; i < NUM_WORKERS; i++) {
        const worker = new Worker(workerURL);
        
        worker.onmessage = function(e) {
          handleWorkerMessage(e.data);
        };
        
        worker.onerror = function(error) {
          logMessage(`Worker error: ${error.message}`, 'error');
        };
        
        workers.push(worker);
      }
      
      logMessage(`Created ${NUM_WORKERS} web workers`, 'info');
    }
    
    function terminateWorkers() {
      workers.forEach(worker => worker.terminate());
      workers = [];
    }
    
    function handleWorkerMessage(message) {
      const { type, batchIndex, features, level, message: msg, index, total } = message;
      
      switch(type) {
        case 'result':
          batchResults.push({
            batchIndex: batchIndex,
            features: features
          });
          
          const completed = batchResults.length;
          const progress = Math.round((completed / totalBatches) * 100);
          updateProgress(completed, totalBatches, `Completed ${completed}/${totalBatches} batches (${progress}%)`);
          
          if (completed >= totalBatches) {
            combineBatchResults();
          }
          break;
          
        case 'log':
          logMessage(msg, level);
          break;
          
        case 'progress':
          updateProgress(index, total, msg);
          break;
          
        case 'error':
          logMessage(`Worker error: ${msg}`, 'error');
          break;
      }
    }
    
    // ===== AREA CALCULATION (UTM) =====
    
    function polygonArea(coords) {
      let area = 0;
      const numPoints = coords.length;
      
      if (numPoints < 3) return 0;
      
      for (let i = 0; i < numPoints - 1; i++) {
        area += coords[i][0] * coords[i+1][1] - coords[i+1][0] * coords[i][1];
      }
      
      area += coords[numPoints-1][0] * coords[0][1] - coords[0][0] * coords[numPoints-1][1];
      
      return Math.abs(area / 2);
    }
    
    function calculateAreaUTM(geometry) {
      let area = 0;
      
      if (geometry.type === 'Polygon') {
        area = polygonArea(geometry.coordinates[0]);
        for (let i = 1; i < geometry.coordinates.length; i++) {
          area -= polygonArea(geometry.coordinates[i]);
        }
      } else if (geometry.type === 'MultiPolygon') {
        for (const polygon of geometry.coordinates) {
          area += polygonArea(polygon[0]);
          for (let i = 1; i < polygon.length; i++) {
            area -= polygonArea(polygon[i]);
          }
        }
      }
      
      return Math.abs(area);
    }
    
    // ===== PROCESSING FUNCTIONS =====
    
    // Step 1: Calculate Parcel Area
    function processStep1() {
      if (isProcessing) {
        logMessage('Processing already in progress', 'warning');
        return;
      }
      
      if (processFlags.step1) {
        const confirmRedo = confirm('Step 1 already completed. Run again?');
        if (!confirmRedo) return;
      }
      
      if (!parcelGeojson) {
        alert("Please upload parcel file first.");
        return;
      }
      
      currentStep = 'step1';
      batchSize = parseInt(document.getElementById('batchSize').value) || 100;
      processingDelay = parseInt(document.getElementById('processingDelay').value) || 10;
      
      // แปลงพิกัดกลับเป็น UTM สำหรับการคำนวณพื้นที่
      const utmZone = document.getElementById('coordSystem').value;
      const parcelDataUTM = convertWGS84ToUTM(parcelGeojson, utmZone);
      
      batchResults = [];
      currentBatch = 0;
      
      const totalFeatures = parcelDataUTM.features.length;
      totalBatches = Math.ceil(totalFeatures / batchSize);
      
      showLoadingIndicator('Calculating parcel areas');
      updateProgress(0, totalFeatures, 'Starting...');
      
      logMessage(`Starting step 1 - ${totalFeatures} parcels in ${totalBatches} batches`, 'info');
      batchStats.startTime = Date.now();
      batchStats.featureCount = totalFeatures;
      
      isProcessing = true;
      
      if (useWebWorkers && workers.length > 0) {
        processBatchesWithWorkers(parcelDataUTM.features, 'processParcelArea');
      } else {
        processBatchesInMainThread(parcelDataUTM.features, (batch, start, end) => {
          const processedBatch = [];
          
          for (let i = 0; i < batch.length; i++) {
            const parcel = batch[i];
            
            // คำนวณพื้นที่จากพิกัด UTM
            const area = calculateAreaUTM(parcel.geometry);
            
            // ใช้ geometry จาก WGS84 เดิมสำหรับแสดงผล
            const originalParcel = parcelGeojson.features[start + i];
            
            processedBatch.push({
              type: "Feature",
              properties: {
                ...originalParcel.properties,
                parcelArea: Math.round(area * 100) / 100
              },
              geometry: originalParcel.geometry
            });
          }
          
          return processedBatch;
        });
      }
    }
    
    function processBatchesWithWorkers(features, command) {
      const batches = [];
      for (let i = 0; i < features.length; i += batchSize) {
        batches.push({
          items: features.slice(i, i + batchSize),
          startIndex: i,
          endIndex: Math.min(i + batchSize, features.length)
        });
      }
      
      batches.forEach((batch, index) => {
        const workerIndex = index % workers.length;
        const worker = workers[workerIndex];
        
        let data = {
          command: command,
          batchIndex: index,
          startIndex: batch.startIndex,
          endIndex: batch.endIndex
        };
        
        if (command === 'processParcelArea') {
          // Worker จะได้รับข้อมูล UTM เพื่อคำนวณพื้นที่
          data.parcelBatch = batch.items;
          data.selectedCRS = currentCRS;
          // ส่ง geometry WGS84 ไปด้วยสำหรับแสดงผลบนแผนที่
          data.originalGeometries = parcelGeojson.features.slice(batch.startIndex, batch.endIndex).map(f => f.geometry);
        } else if (command === 'processBuildingPoints') {
          data.buildingBatch = batch.items;
          data.parcelGeojson = parcelGeojson;
          data.selectedField = document.getElementById('parcelFieldSelector').value;
        } else if (command === 'processBuildingAreas') {
          data.parcelBatch = batch.items;
          data.buildingGeojson = buildingGeojson;
          data.selectedField = document.getElementById('parcelFieldSelector').value;
        } else if (command === 'calculateOSR') {
          data.parcelBatch = batch.items;
        }
        
        worker.postMessage(data);
      });
    }
    
    function processBatchesInMainThread(features, processFn) {
      const batches = [];
      for (let i = 0; i < features.length; i += batchSize) {
        batches.push({
          items: features.slice(i, i + batchSize),
          startIndex: i,
          endIndex: Math.min(i + batchSize, features.length)
        });
      }
      
      function processNextBatch(index) {
        if (index >= batches.length) {
          combineBatchResults();
          return;
        }
        
        const batch = batches[index];
        updateProgress(batch.startIndex, features.length, `Batch ${index + 1}/${batches.length}`);
        
        try {
          const result = processFn(batch.items, batch.startIndex, batch.endIndex);
          
          batchResults.push({
            batchIndex: index,
            features: result
          });
          
          setTimeout(() => {
            processNextBatch(index + 1);
          }, processingDelay);
        } catch (error) {
          logMessage(`Error processing batch ${index}: ${error.message}`, 'error');
          isProcessing = false;
          hideLoadingIndicator();
        }
      }
      
      processNextBatch(0);
    }
    
    function combineBatchResults() {
      try {
        batchResults.sort((a, b) => a.batchIndex - b.batchIndex);
        
        let allFeatures = [];
        for (const batch of batchResults) {
          allFeatures = allFeatures.concat(batch.features);
        }
        
        const combinedGeoJSON = {
          type: "FeatureCollection",
          features: allFeatures
        };
        
        batchStats.endTime = Date.now();
        const processingTime = (batchStats.endTime - batchStats.startTime) / 1000;
        
        logMessage(`Completed processing ${batchStats.featureCount} features in ${processingTime.toFixed(2)}s`, 'info');
        
        if (currentStep === 'step1') {
          finalizeStep1(combinedGeoJSON);
        } else if (currentStep === 'step2') {
          finalizeStep2(combinedGeoJSON);
        } else if (currentStep === 'step3') {
          finalizeStep3(combinedGeoJSON);
        } else if (currentStep === 'step4') {
          finalizeStep4(combinedGeoJSON);
        }
        
        isProcessing = false;
        hideLoadingIndicator();
        
      } catch (error) {
        logMessage(`Error combining batch results: ${error.message}`, 'error');
        isProcessing = false;
        hideLoadingIndicator();
      }
    }
    
    function finalizeStep1(combinedGeoJSON) {
      if (combinedGeoJSON.features.length === 0) {
        alert("Failed to calculate areas.");
        return;
      }
      
      resultGeojson = combinedGeoJSON;
      parcelOriginalShapes = JSON.parse(JSON.stringify(parcelGeojson));
      
      if (resultLayer) {
        map.removeLayer(resultLayer);
        delete layerData['parcelArea'];
      }
      
      addGeoJSONToMap(resultGeojson, 'parcelArea', 'Parcels with Area');
      
      let totalArea = 0;
      resultGeojson.features.forEach(feature => {
        totalArea += feature.properties.parcelArea;
      });
      
      const avgArea = totalArea / resultGeojson.features.length;
      
      document.getElementById('step1Result').innerHTML = `
        <p>Calculated areas for ${resultGeojson.features.length} parcels</p>
        <p>Total area: ${Math.round(totalArea * 100) / 100} sq.m</p>
        <p>Average area: ${Math.round(avgArea * 100) / 100} sq.m</p>
        <p>CRS: ${currentCRS}</p>
      `;
      document.getElementById('step1Result').style.display = 'block';
      
      document.getElementById('processStep2').disabled = false;
      processFlags.step1 = true;
      
      if (runningAllSteps) {
        setTimeout(() => processStep2(), 500);
      }
    }
    
    // Step 2: Extract Parcel Information
    function processStep2() {
      if (isProcessing) {
        logMessage('Processing already in progress', 'warning');
        return;
      }
      
      if (processFlags.step2) {
        const confirmRedo = confirm('Step 2 already completed. Run again?');
        if (!confirmRedo) return;
      }
      
      if (!buildingGeojson || !parcelGeojson) {
        alert("Please complete step 1 first.");
        return;
      }
      
      const selectedField = document.getElementById('parcelFieldSelector').value;
      if (!selectedField) {
        alert("Please select a parcel field.");
        return;
      }
      
      currentStep = 'step2';
      batchSize = parseInt(document.getElementById('batchSize').value) || 100;
      processingDelay = parseInt(document.getElementById('processingDelay').value) || 10;
      
      const buildingData = JSON.parse(JSON.stringify(buildingGeojson));
      
      batchResults = [];
      currentBatch = 0;
      
      const totalFeatures = buildingData.features.length;
      totalBatches = Math.ceil(totalFeatures / batchSize);
      
      showLoadingIndicator('Converting buildings to points');
      updateProgress(0, totalFeatures, 'Starting...');
      
      logMessage(`Starting step 2 - ${totalFeatures} buildings in ${totalBatches} batches`, 'info');
      batchStats.startTime = Date.now();
      batchStats.featureCount = totalFeatures;
      
      isProcessing = true;
      
      if (useWebWorkers && workers.length > 0) {
        processBatchesWithWorkers(buildingData.features, 'processBuildingPoints');
      } else {
        processBatchesInMainThread(buildingData.features, (batch, start, end) => {
          const buildingPoints = [];
          
          batch.forEach(building => {
            let centerCoords;
            
            if (building.geometry.type === "Polygon") {
              const centroid = turf.centroid(building);
              centerCoords = centroid.geometry.coordinates;
            } else if (building.geometry.type === "MultiPolygon") {
              const firstPolygon = turf.polygon(building.geometry.coordinates[0]);
              const centroid = turf.centroid(firstPolygon);
              centerCoords = centroid.geometry.coordinates;
            }
            
            const pointFeature = {
              type: "Feature",
              properties: {
                ...building.properties,
                parcelId: null,
                parcelName: null,
                buildingArea: building.properties.BL_AREA || 0,
                buildingStoreys: building.properties.BL_NSTOREY || 1
              },
              geometry: {
                type: "Point",
                coordinates: centerCoords
              }
            };
            
            for (const parcel of parcelGeojson.features) {
              if (turf.booleanPointInPolygon(centerCoords, parcel.geometry)) {
                const selectedField = document.getElementById('parcelFieldSelector').value;
                pointFeature.properties.parcelId = parcel.properties[selectedField];
                pointFeature.properties.parcelName = parcel.properties[selectedField];
                break;
              }
            }
            
            buildingPoints.push(pointFeature);
          });
          
          return buildingPoints;
        });
      }
    }
    
    function finalizeStep2(combinedGeoJSON) {
      const buildingsWithParcel = combinedGeoJSON.features.filter(f => f.properties.parcelId !== null).length;
      
      document.getElementById('step2Result').innerHTML = `
        <p>Processed ${combinedGeoJSON.features.length} buildings</p>
        <p>Matched to parcels: ${buildingsWithParcel}</p>
      `;
      document.getElementById('step2Result').style.display = 'block';
      
      addGeoJSONToMap(combinedGeoJSON, 'buildingPoints', 'Building Points');
      
      document.getElementById('processStep3').disabled = false;
      processFlags.step2 = true;
      
      if (runningAllSteps) {
        setTimeout(() => processStep3(), 500);
      }
    }
    
    // Step 3: Calculate Total Building Area
    function processStep3() {
      if (isProcessing) {
        logMessage('Processing already in progress', 'warning');
        return;
      }
      
      if (processFlags.step3) {
        const confirmRedo = confirm('Step 3 already completed. Run again?');
        if (!confirmRedo) return;
      }
      
      if (!parcelGeojson || !buildingGeojson) {
        alert("Please complete step 2 first.");
        return;
      }
      
      if (!resultGeojson) {
        alert("Please complete step 1 first. Parcel area data is required.");
        return;
      }
      
      const selectedField = document.getElementById('parcelFieldSelector').value;
      if (!selectedField) {
        alert("Please select a parcel field.");
        return;
      }
      
      currentStep = 'step3';
      batchSize = parseInt(document.getElementById('batchSize').value) || 100;
      processingDelay = parseInt(document.getElementById('processingDelay').value) || 10;
      
      // ใช้ resultGeojson ที่มี parcelArea จาก step1
      const parcelData = JSON.parse(JSON.stringify(resultGeojson));
      
      batchResults = [];
      currentBatch = 0;
      
      const totalFeatures = parcelData.features.length;
      totalBatches = Math.ceil(totalFeatures / batchSize);
      
      showLoadingIndicator('Calculating building areas');
      updateProgress(0, totalFeatures, 'Starting...');
      
      logMessage(`Starting step 3 - ${totalFeatures} parcels in ${totalBatches} batches`, 'info');
      batchStats.startTime = Date.now();
      batchStats.featureCount = totalFeatures;
      
      isProcessing = true;
      
      if (useWebWorkers && workers.length > 0) {
        processBatchesWithWorkers(parcelData.features, 'processBuildingAreas');
      } else {
        processBatchesInMainThread(parcelData.features, (batch, start, end) => {
          const processedParcels = [];
          
          batch.forEach(parcel => {
            const selectedField = document.getElementById('parcelFieldSelector').value;
            const parcelId = parcel.properties[selectedField];
            let totalBuildingOneFloor = 0;  // BL_AREA only
            let totalBuildingAllFloor = 0;  // BL_AREA * BL_NSTOREY
            let buildingCount = 0;
            
            buildingGeojson.features.forEach(building => {
              let center;
              
              if (building.geometry.type === "Polygon") {
                const centroid = turf.centroid(building);
                center = centroid.geometry.coordinates;
              } else if (building.geometry.type === "MultiPolygon") {
                const firstPolygon = turf.polygon(building.geometry.coordinates[0]);
                const centroid = turf.centroid(firstPolygon);
                center = centroid.geometry.coordinates;
              }
              
              if (turf.booleanPointInPolygon(center, parcel.geometry)) {
                const buildingArea = building.properties.BL_AREA || 0;
                const buildingStoreys = building.properties.BL_NSTOREY || 1;
                
                // คำนวณทั้งสองแบบ
                totalBuildingOneFloor += buildingArea;  // BL_AREA only
                totalBuildingAllFloor += buildingArea * buildingStoreys;  // BL_AREA * BL_NSTOREY
                buildingCount++;
              }
            });
            
            processedParcels.push({
              type: "Feature",
              properties: {
                ...parcel.properties,
                parcelArea: parcel.properties.parcelArea, // เก็บ parcelArea จาก step1
                totalBuildingOneFloor: Math.round(totalBuildingOneFloor * 100) / 100,
                totalBuildingAllFloor: Math.round(totalBuildingAllFloor * 100) / 100,
                buildingCount: buildingCount
              },
              geometry: parcel.geometry
            });
          });
          
          return processedParcels;
        });
      }
    }
    
    function finalizeStep3(combinedGeoJSON) {
      // อัพเดท parcelGeojson ด้วยข้อมูล totalBuildingOneFloor และ totalBuildingAllFloor
      // แต่ต้องรักษา parcelArea จาก step1 ไว้ด้วย
      const updatedFeatures = combinedGeoJSON.features.map((parcel, index) => {
        // หา parcel เดิมที่มี parcelArea จาก resultGeojson (ผลจาก step1)
        const originalParcel = resultGeojson ? resultGeojson.features[index] : null;
        
        return {
          type: "Feature",
          properties: {
            ...parcel.properties,
            parcelArea: originalParcel ? originalParcel.properties.parcelArea : parcel.properties.parcelArea,
            totalBuildingOneFloor: parcel.properties.totalBuildingOneFloor || 0,
            totalBuildingAllFloor: parcel.properties.totalBuildingAllFloor || 0,
            buildingCount: parcel.properties.buildingCount || 0
          },
          geometry: parcel.geometry
        };
      });
      
      parcelGeojson = {
        type: "FeatureCollection",
        features: updatedFeatures
      };
      
      const totalBuildingOneFloor = parcelGeojson.features.reduce((sum, f) => 
        sum + (f.properties.totalBuildingOneFloor || 0), 0);
      const totalBuildingAllFloor = parcelGeojson.features.reduce((sum, f) => 
        sum + (f.properties.totalBuildingAllFloor || 0), 0);
      
      // นับจำนวน parcels ที่มีข้อมูล parcelArea
      const parcelsWithArea = parcelGeojson.features.filter(f => f.properties.parcelArea > 0).length;
      
      document.getElementById('step3Result').innerHTML = `
        <p>Calculated building areas for ${parcelGeojson.features.length} parcels</p>
        <p>Parcels with area data: ${parcelsWithArea}</p>
        <p>Total building area (one floor): ${Math.round(totalBuildingOneFloor * 100) / 100} sq.m</p>
        <p>Total building area (all floors): ${Math.round(totalBuildingAllFloor * 100) / 100} sq.m</p>
      `;
      document.getElementById('step3Result').style.display = 'block';
      
      addGeoJSONToMap(parcelGeojson, 'parcelsBuildingAreas', 'Parcels with Building Areas');
      
      document.getElementById('processStep4').disabled = false;
      processFlags.step3 = true;
      
      logMessage(`Step 3 completed. Parcels with area: ${parcelsWithArea}/${parcelGeojson.features.length}`, 'info');
      
      if (runningAllSteps) {
        setTimeout(() => processStep4(), 500);
      }
    }
    
    // Step 4: Calculate OSR
    function processStep4() {
      if (isProcessing) {
        logMessage('Processing already in progress', 'warning');
        return;
      }
      
      if (processFlags.step4) {
        const confirmRedo = confirm('Step 4 already completed. Run again?');
        if (!confirmRedo) return;
      }
      
      if (!parcelGeojson) {
        alert("Please complete step 3 first.");
        return;
      }
      
      currentStep = 'step4';
      batchSize = parseInt(document.getElementById('batchSize').value) || 100;
      processingDelay = parseInt(document.getElementById('processingDelay').value) || 10;
      
      const parcelData = JSON.parse(JSON.stringify(parcelGeojson));
      
      batchResults = [];
      currentBatch = 0;
      
      const totalFeatures = parcelData.features.length;
      totalBatches = Math.ceil(totalFeatures / batchSize);
      
      showLoadingIndicator('Calculating OSR');
      updateProgress(0, totalFeatures, 'Starting...');
      
      logMessage(`Starting step 4 - ${totalFeatures} parcels in ${totalBatches} batches`, 'info');
      batchStats.startTime = Date.now();
      batchStats.featureCount = totalFeatures;
      
      isProcessing = true;
      
      if (useWebWorkers && workers.length > 0) {
        processBatchesWithWorkers(parcelData.features, 'calculateOSR');
      } else {
        processBatchesInMainThread(parcelData.features, (batch, start, end) => {
          return batch.map(parcel => {
            const totalBuildingOneFloor = parcel.properties.totalBuildingOneFloor || 0;
            const totalBuildingAllFloor = parcel.properties.totalBuildingAllFloor || 0;
            const parcelArea = parcel.properties.parcelArea || 0;
            
            // คำนวณ Open Space Area = Parcel Area - Total Building One Floor
            const openSpaceArea = parcelArea - totalBuildingOneFloor;
            
            // คำนวณ OSR = (Open Space Area / Total Building All Floor) × 100
            let osr = 0;
            if (totalBuildingAllFloor > 0) {
              osr = (openSpaceArea / totalBuildingAllFloor) * 100;
            }
            
            return {
              type: "Feature",
              properties: {
                ...parcel.properties,
                openSpaceArea: Math.round(openSpaceArea * 100) / 100,
                OSR: Math.round(osr * 100) / 100
              },
              geometry: parcel.geometry
            };
          });
        });
      }
    }
    
    function finalizeStep4(combinedGeoJSON) {
      if (combinedGeoJSON.features.length === 0) {
        alert("Failed to calculate OSR values.");
        return;
      }
      
      resultGeojson = combinedGeoJSON;
      window.finalResultGeojson = combinedGeoJSON;
      
      if (resultLayer) {
        map.removeLayer(resultLayer);
        delete layerData['finalResult'];
      }
      
      addGeoJSONToMap(resultGeojson, 'finalResult', 'Final Result (OSR)');
      
      let totalParcelArea = 0;
      let totalBuildingOneFloor = 0;
      let totalBuildingAllFloor = 0;
      let totalOpenSpaceArea = 0;
      let totalParcels = resultGeojson.features.length;
      let parcelsWithData = 0;
      let parcelsWithBothData = 0;
      let osrValues = [];
      
      // Log ตัวอย่างข้อมูล 3 แปลงแรก
      logMessage('=== Sample OSR Calculations (first 3 parcels) ===', 'info');
      
      resultGeojson.features.forEach((parcel, index) => {
        const parcelArea = parcel.properties.parcelArea || 0;
        const buildingOneFloor = parcel.properties.totalBuildingOneFloor || 0;
        const buildingAllFloor = parcel.properties.totalBuildingAllFloor || 0;
        const openSpaceArea = parcel.properties.openSpaceArea || 0;
        const osr = parcel.properties.OSR || 0;
        
        // Log ตัวอย่างแปลงแรก 3 แปลง
        if (index < 3) {
          logMessage(`Parcel ${index + 1}: Area=${parcelArea.toFixed(2)}m², BuildingOneFloor=${buildingOneFloor.toFixed(2)}m², BuildingAllFloor=${buildingAllFloor.toFixed(2)}m², OpenSpace=${openSpaceArea.toFixed(2)}m², OSR=${osr.toFixed(2)}%`, 'info');
        }
        
        if (parcelArea > 0) {
          totalParcelArea += parcelArea;
          totalBuildingOneFloor += buildingOneFloor;
          totalBuildingAllFloor += buildingAllFloor;
          totalOpenSpaceArea += openSpaceArea;
          parcelsWithData++;
          
          if (buildingAllFloor > 0) {
            parcelsWithBothData++;
            osrValues.push(osr);
          }
        }
      });
      
      const averageOSR = osrValues.length > 0 ? osrValues.reduce((a, b) => a + b, 0) / osrValues.length : 0;
      const maxOSR = osrValues.length > 0 ? Math.max(...osrValues) : 0;
      const minOSR = osrValues.length > 0 ? Math.min(...osrValues) : 0;
      
      // คำนวณ Overall OSR = (Total Open Space Area / Total Building All Floor) × 100
      const overallOSR = totalBuildingAllFloor > 0 ? (totalOpenSpaceArea / totalBuildingAllFloor) * 100 : 0;
      
      document.getElementById('step4Result').innerHTML = `
        <p><strong>OSR calculated for ${resultGeojson.features.length} parcels</strong></p>
        <p style="font-size: 12px; color: #666;">Open Space Area = Parcel Area - Total Building One Floor</p>
        <p style="font-size: 12px; color: #666;">OSR = (Open Space Area / Total Building All Floor) × 100</p>
        <hr>
        <p><strong>Summary Statistics:</strong></p>
        <p>Total parcels: ${totalParcels}</p>
        <p>Parcels with area data: ${parcelsWithData}</p>
        <p>Parcels with buildings: ${parcelsWithBothData}</p>
        <p>Total parcel area: ${Math.round(totalParcelArea * 100) / 100} sq.m</p>
        <p>Total building area (one floor): ${Math.round(totalBuildingOneFloor * 100) / 100} sq.m</p>
        <p>Total building area (all floors): ${Math.round(totalBuildingAllFloor * 100) / 100} sq.m</p>
        <p>Total open space area: ${Math.round(totalOpenSpaceArea * 100) / 100} sq.m</p>
        <hr>
        <p><strong>Overall OSR:</strong> <span style="color: #0079c1; font-size: 16px;">${overallOSR.toFixed(2)}%</span></p>
        <p><strong>Average OSR:</strong> ${averageOSR.toFixed(2)}%</p>
        <p><strong>Maximum OSR:</strong> ${maxOSR.toFixed(2)}%</p>
        <p><strong>Minimum OSR:</strong> ${minOSR.toFixed(2)}%</p>
        <p style="font-size: 11px; color: #666; margin-top: 10px;">CRS: ${currentCRS}</p>
      `;
      document.getElementById('step4Result').style.display = 'block';
      
      document.getElementById('exportButton').disabled = false;
      document.getElementById('exportExcelButton').disabled = false;
      document.getElementById('exportShapefileButton').disabled = false;
      processFlags.step4 = true;
      
      logMessage(`OSR calculation completed. Overall OSR: ${overallOSR.toFixed(2)}%`, 'info');
      
      if (runningAllSteps) {
        runningAllSteps = false;
        logMessage('Completed all processing steps successfully!', 'info');
      }
    }
    
    // Run all steps
    function runAllSteps() {
      if (isProcessing) {
        logMessage('Processing already in progress', 'warning');
        return;
      }
      
      if (!buildingGeojson || !parcelGeojson) {
        alert("Please upload both parcel and building files first.");
        return;
      }
      
      const selectedField = document.getElementById('parcelFieldSelector').value;
      if (!selectedField) {
        alert("Please select a parcel field.");
        return;
      }
      
      if (processFlags.step1 || processFlags.step2 || processFlags.step3 || processFlags.step4) {
        const confirmRedo = confirm('Some steps already completed. Run all steps again?');
        if (!confirmRedo) return;
      }
      
      runningAllSteps = true;
      processStep1();
    }
    
    // ===== EXPORT FUNCTIONS =====
    
    function exportResult() {
      if (!window.finalResultGeojson) {
        alert("Please complete step 4 first.");
        return;
      }
      
      const utmZone = document.getElementById('coordSystem').value;
      const utmData = convertWGS84ToUTM(window.finalResultGeojson, utmZone);
      
      utmData.crs = {
        "type": "name",
        "properties": {
          "name": currentCRS
        }
      };
      
      const blob = new Blob([JSON.stringify(utmData, null, 2)], { 
        type: 'application/json' 
      });
      
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `OSR_Result_${utmZone.replace(':', '_')}_${Date.now()}.geojson`;
      a.click();
      
      URL.revokeObjectURL(url);
      logMessage('Exported GeoJSON (UTM) successfully', 'info');
    }
    
    function exportExcel() {
      if (!window.finalResultGeojson) {
        alert("Please complete step 4 first.");
        return;
      }
      
      const selectedField = document.getElementById('parcelFieldSelector').value;
      const selectedCRS = document.getElementById('coordSystem').value;
      
      const data = window.finalResultGeojson.features.map((feature, index) => {
        return {
          'FID': index,
          [selectedField]: feature.properties[selectedField] || '',
          'Parcel Area (sq.m)': feature.properties.parcelArea || 0,
          'Building One Floor (sq.m)': feature.properties.totalBuildingOneFloor || 0,
          'Building All Floors (sq.m)': feature.properties.totalBuildingAllFloor || 0,
          'Open Space Area (sq.m)': feature.properties.openSpaceArea || 0,
          'Building Count': feature.properties.buildingCount || 0,
          'OSR (%)': feature.properties.OSR || 0
        };
      });
      
      const wb = XLSX.utils.book_new();
      
      data.unshift({});
      data.unshift({
        [selectedField]: 'Coordinate System',
        'OSR (%)': selectedCRS
      });
      data.unshift({
        [selectedField]: 'Generated on',
        'OSR (%)': new Date().toLocaleString()
      });
      
      const ws = XLSX.utils.json_to_sheet(data);
      XLSX.utils.book_append_sheet(wb, ws, "OSR Analysis");
      XLSX.writeFile(wb, `OSR_Result_${selectedCRS.replace(':', '_')}_${Date.now()}.xlsx`);
      
      logMessage('Exported Excel successfully', 'info');
    }
    
    async function exportShapefile() {
      if (!window.finalResultGeojson) {
        alert("Please complete step 4 first.");
        return;
      }
      
      try {
        showLoadingIndicator('Preparing Shapefile export...');
        
        const utmZone = document.getElementById('coordSystem').value;
        const selectedField = document.getElementById('parcelFieldSelector').value;
        
        // แปลงกลับเป็น UTM
        const utmData = convertWGS84ToUTM(window.finalResultGeojson, utmZone);
        
        logMessage('Converting GeoJSON to Shapefile format...', 'info');
        
        // เตรียมข้อมูล properties โดยตัดชื่อฟิลด์ให้สั้นลง (Shapefile รองรับแค่ 10 ตัวอักษร)
        const features = utmData.features.map((feature, index) => {
          const shortProps = {};
          
          // FID
          shortProps['FID'] = index;
          
          // เก็บ field หลัก
          if (feature.properties[selectedField] !== undefined) {
            const fieldValue = String(feature.properties[selectedField]);
            shortProps['PARCEL_ID'] = fieldValue.substring(0, 254); // DBF text field max 254
          }
          
          // เก็บข้อมูล OSR
          shortProps['PARCEL_A'] = parseFloat((feature.properties.parcelArea || 0).toFixed(2));
          shortProps['BUILD_1F'] = parseFloat((feature.properties.totalBuildingOneFloor || 0).toFixed(2));
          shortProps['BUILD_AF'] = parseFloat((feature.properties.totalBuildingAllFloor || 0).toFixed(2));
          shortProps['OPEN_A'] = parseFloat((feature.properties.openSpaceArea || 0).toFixed(2));
          shortProps['BUILD_CNT'] = parseInt(feature.properties.buildingCount || 0);
          shortProps['OSR'] = parseFloat((feature.properties.OSR || 0).toFixed(2));
          
          return {
            type: feature.type,
            geometry: feature.geometry,
            properties: shortProps
          };
        });
        
        const processedGeoJSON = {
          type: 'FeatureCollection',
          features: features
        };
        
        logMessage('Generating Shapefile components...', 'info');
        
        // สร้าง Shapefile components
        const shapefileComponents = await createShapefileFromGeoJSON(processedGeoJSON);
        
        // สร้าง ZIP file
        const zip = new JSZip();
        
        // เพิ่มไฟล์ Shapefile
        zip.file('OSR_Result.shp', shapefileComponents.shp);
        zip.file('OSR_Result.shx', shapefileComponents.shx);
        zip.file('OSR_Result.dbf', shapefileComponents.dbf);
        
        // สร้างไฟล์ .prj
        let prjContent = '';
        if (utmZone === 'EPSG:32647') {
          prjContent = 'PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]';
        } else {
          prjContent = 'PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",105.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]';
        }
        
        zip.file('OSR_Result.prj', prjContent);
        
        // สร้างไฟล์ README
        const readmeContent = `Open Space Ratio (OSR) Analysis Results
========================================

Coordinate System: ${utmZone}
Export Date: ${new Date().toLocaleString()}

Files Included:
--------------
OSR_Result.shp  : Shape geometry
OSR_Result.shx  : Shape index
OSR_Result.dbf  : Attribute data
OSR_Result.prj  : Projection information

Field Descriptions:
------------------
FID        : Feature ID (sequential number)
PARCEL_ID  : Parcel Identifier
PARCEL_A   : Parcel Area (square meters)
BUILD_1F   : Total Building Area - One Floor only (BL_AREA, square meters)
BUILD_AF   : Total Building Area - All Floors (BL_AREA × BL_NSTOREY, square meters)
OPEN_A     : Open Space Area (PARCEL_A - BUILD_1F, square meters)
BUILD_CNT  : Number of Buildings in Parcel
OSR        : Open Space Ratio ((OPEN_A / BUILD_AF) × 100, percentage)

Calculation Notes:
-----------------
1. Open Space Area = Parcel Area - Total Building One Floor
   - Uses only ground floor footprint (BL_AREA) for open space calculation
   
2. OSR = (Open Space Area / Total Building All Floors) × 100
   - Open Space Area: Available open space on the parcel
   - Total Building All Floors: Total built area including all stories

Notes:
------
- All area measurements are in square meters
- OSR is expressed as a percentage
- BUILD_1F uses ground floor footprint only
- BUILD_AF accounts for multiple stories
- Coordinate system: ${utmZone === 'EPSG:32647' ? 'WGS 1984 UTM Zone 47N' : 'WGS 1984 UTM Zone 48N'}
- Compatible with ArcGIS, QGIS, and other GIS software
- Generated by Open Space Ratio Web App

Example Usage in ArcMap:
-----------------------
1. Extract all files to the same folder
2. Add OSR_Result.shp to your map
3. View attributes in the attribute table
4. Symbolize by OSR field for visualization

For questions or issues, please check the application documentation.
`;
        
        zip.file('README.txt', readmeContent);
        
        // สร้าง ZIP และดาวน์โหลด
        const content = await zip.generateAsync({ 
          type: 'blob',
          compression: "DEFLATE",
          compressionOptions: {
            level: 9
          }
        });
        
        saveAs(content, `OSR_Result_${utmZone.replace(':', '_')}_${Date.now()}.zip`);
        
        hideLoadingIndicator();
        logMessage('Shapefile exported successfully!', 'info');
        logMessage(`Exported ${features.length} features to Shapefile format`, 'info');
        
      } catch (error) {
        hideLoadingIndicator();
        console.error('Export error:', error);
        alert('Error exporting Shapefile: ' + error.message);
        logMessage('Export error: ' + error.message, 'error');
      }
    }
    
    // ฟังก์ชันสร้าง Shapefile จาก GeoJSON
    async function createShapefileFromGeoJSON(geojson) {
      // สร้าง .shp (geometry)
      const shpBuffer = createShpFile(geojson);
      
      // สร้าง .shx (index)
      const shxBuffer = createShxFile(geojson);
      
      // สร้าง .dbf (attributes)
      const dbfBuffer = createDbfFile(geojson);
      
      return {
        shp: shpBuffer,
        shx: shxBuffer,
        dbf: dbfBuffer
      };
    }
    
    // สร้างไฟล์ .shp
    function createShpFile(geojson) {
      const features = geojson.features;
      
      // คำนวณ bounding box
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      
      features.forEach(feature => {
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach(coord => {
            minX = Math.min(minX, coord[0]);
            minY = Math.min(minY, coord[1]);
            maxX = Math.max(maxX, coord[0]);
            maxY = Math.max(maxY, coord[1]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(polygon => {
            polygon[0].forEach(coord => {
              minX = Math.min(minX, coord[0]);
              minY = Math.min(minY, coord[1]);
              maxX = Math.max(maxX, coord[0]);
              maxY = Math.max(maxY, coord[1]);
            });
          });
        }
      });
      
      // สร้าง header (100 bytes)
      const header = new ArrayBuffer(100);
      const headerView = new DataView(header);
      
      // File code (9994 in big-endian)
      headerView.setInt32(0, 9994, false);
      
      // File length (จะคำนวณทีหลัง - ใส่ placeholder ไว้ก่อน)
      headerView.setInt32(24, 0, false);
      
      // Version (1000)
      headerView.setInt32(28, 1000, true);
      
      // Shape type (5 = Polygon)
      headerView.setInt32(32, 5, true);
      
      // Bounding box
      headerView.setFloat64(36, minX, true);
      headerView.setFloat64(44, minY, true);
      headerView.setFloat64(52, maxX, true);
      headerView.setFloat64(60, maxY, true);
      
      // Z and M values (not used, set to 0)
      headerView.setFloat64(68, 0, true);
      headerView.setFloat64(76, 0, true);
      headerView.setFloat64(84, 0, true);
      headerView.setFloat64(92, 0, true);
      
      // สร้าง records
      const records = [];
      let recordNumber = 1;
      
      features.forEach(feature => {
        const recordBuffer = createPolygonRecord(feature.geometry, recordNumber);
        records.push(recordBuffer);
        recordNumber++;
      });
      
      // รวม header + records
      const totalLength = 100 + records.reduce((sum, r) => sum + r.byteLength, 0);
      const result = new Uint8Array(totalLength);
      
      // Copy header
      result.set(new Uint8Array(header), 0);
      
      // Update file length in header (in 16-bit words)
      const fileLengthInWords = totalLength / 2;
      new DataView(result.buffer).setInt32(24, fileLengthInWords, false);
      
      // Copy records
      let offset = 100;
      records.forEach(record => {
        result.set(new Uint8Array(record), offset);
        offset += record.byteLength;
      });
      
      return result.buffer;
    }
    
    // สร้าง polygon record
    function createPolygonRecord(geometry, recordNumber) {
      let numParts = 0;
      let numPoints = 0;
      let parts = [];
      let points = [];
      
      if (geometry.type === 'Polygon') {
        numParts = geometry.coordinates.length;
        geometry.coordinates.forEach((ring, index) => {
          parts.push(numPoints);
          ring.forEach(coord => {
            points.push(coord[0], coord[1]);
            numPoints++;
          });
        });
      } else if (geometry.type === 'MultiPolygon') {
        geometry.coordinates.forEach(polygon => {
          polygon.forEach((ring, index) => {
            parts.push(numPoints);
            ring.forEach(coord => {
              points.push(coord[0], coord[1]);
              numPoints++;
            });
            numParts++;
          });
        });
      }
      
      // คำนวณ bounding box
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let i = 0; i < points.length; i += 2) {
        minX = Math.min(minX, points[i]);
        maxX = Math.max(maxX, points[i]);
        minY = Math.min(minY, points[i + 1]);
        maxY = Math.max(maxY, points[i + 1]);
      }
      
      // Record header (8 bytes) + content
      const contentLength = 44 + (4 * numParts) + (16 * numPoints);
      const recordLength = 8 + contentLength;
      
      const buffer = new ArrayBuffer(recordLength);
      const view = new DataView(buffer);
      
      // Record header
      view.setInt32(0, recordNumber, false); // Record number (big-endian)
      view.setInt32(4, contentLength / 2, false); // Content length in 16-bit words (big-endian)
      
      // Shape type
      view.setInt32(8, 5, true); // Polygon (little-endian)
      
      // Bounding box
      view.setFloat64(12, minX, true);
      view.setFloat64(20, minY, true);
      view.setFloat64(28, maxX, true);
      view.setFloat64(36, maxY, true);
      
      // Number of parts and points
      view.setInt32(44, numParts, true);
      view.setInt32(48, numPoints, true);
      
      // Parts array
      let offset = 52;
      parts.forEach(partIndex => {
        view.setInt32(offset, partIndex, true);
        offset += 4;
      });
      
      // Points array
      for (let i = 0; i < points.length; i += 2) {
        view.setFloat64(offset, points[i], true); // X
        view.setFloat64(offset + 8, points[i + 1], true); // Y
        offset += 16;
      }
      
      return buffer;
    }
    
    // สร้างไฟล์ .shx
    function createShxFile(geojson) {
      const features = geojson.features;
      
      // คำนวณ bounding box (เหมือน .shp)
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      
      features.forEach(feature => {
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach(coord => {
            minX = Math.min(minX, coord[0]);
            minY = Math.min(minY, coord[1]);
            maxX = Math.max(maxX, coord[0]);
            maxY = Math.max(maxY, coord[1]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(polygon => {
            polygon[0].forEach(coord => {
              minX = Math.min(minX, coord[0]);
              minY = Math.min(minY, coord[1]);
              maxX = Math.max(maxX, coord[0]);
              maxY = Math.max(maxY, coord[1]);
            });
          });
        }
      });
      
      // Header (100 bytes) + index records (8 bytes per feature)
      const totalLength = 100 + (features.length * 8);
      const buffer = new ArrayBuffer(totalLength);
      const view = new DataView(buffer);
      
      // File code
      view.setInt32(0, 9994, false);
      
      // File length in 16-bit words
      view.setInt32(24, totalLength / 2, false);
      
      // Version
      view.setInt32(28, 1000, true);
      
      // Shape type
      view.setInt32(32, 5, true);
      
      // Bounding box
      view.setFloat64(36, minX, true);
      view.setFloat64(44, minY, true);
      view.setFloat64(52, maxX, true);
      view.setFloat64(60, maxY, true);
      
      // Index records
      let offset = 100;
      let recordOffset = 50; // Start after header (100 bytes / 2 = 50 words)
      
      features.forEach((feature, index) => {
        // คำนวณ content length ของแต่ละ record
        let numParts = 0;
        let numPoints = 0;
        
        if (feature.geometry.type === 'Polygon') {
          numParts = feature.geometry.coordinates.length;
          feature.geometry.coordinates.forEach(ring => {
            numPoints += ring.length;
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(polygon => {
            numParts += polygon.length;
            polygon.forEach(ring => {
              numPoints += ring.length;
            });
          });
        }
        
        const contentLength = 44 + (4 * numParts) + (16 * numPoints);
        
        // Offset (in 16-bit words, big-endian)
        view.setInt32(offset, recordOffset, false);
        
        // Content length (in 16-bit words, big-endian)
        view.setInt32(offset + 4, contentLength / 2, false);
        
        recordOffset += 4 + (contentLength / 2); // 4 words for record header
        offset += 8;
      });
      
      return buffer;
    }
    
    // สร้างไฟล์ .dbf
    function createDbfFile(geojson) {
      const features = geojson.features;
      const numRecords = features.length;
      
      // Define fields
      const fields = [
        { name: 'FID', type: 'N', length: 10, decimal: 0 },
        { name: 'PARCEL_ID', type: 'C', length: 50, decimal: 0 },
        { name: 'PARCEL_A', type: 'N', length: 15, decimal: 2 },
        { name: 'BUILD_1F', type: 'N', length: 15, decimal: 2 },
        { name: 'BUILD_AF', type: 'N', length: 15, decimal: 2 },
        { name: 'OPEN_A', type: 'N', length: 15, decimal: 2 },
        { name: 'BUILD_CNT', type: 'N', length: 10, decimal: 0 },
        { name: 'OSR', type: 'N', length: 10, decimal: 2 }
      ];
      
      // Calculate record length (1 byte for deletion flag + sum of field lengths)
      const recordLength = 1 + fields.reduce((sum, field) => sum + field.length, 0);
      
      // Header length (32 bytes + 32 bytes per field + 1 byte terminator)
      const headerLength = 32 + (fields.length * 32) + 1;
      
      // Total file length
      const fileLength = headerLength + (numRecords * recordLength);
      
      const buffer = new ArrayBuffer(fileLength);
      const view = new DataView(buffer);
      const bytes = new Uint8Array(buffer);
      
      // Header
      view.setUint8(0, 3); // Version (dBASE III)
      
      // Last update date (YY, MM, DD)
      const now = new Date();
      view.setUint8(1, now.getFullYear() - 1900);
      view.setUint8(2, now.getMonth() + 1);
      view.setUint8(3, now.getDate());
      
      // Number of records
      view.setUint32(4, numRecords, true);
      
      // Header length
      view.setUint16(8, headerLength, true);
      
      // Record length
      view.setUint16(10, recordLength, true);
      
      // Field descriptors
      let offset = 32;
      fields.forEach(field => {
        // Field name (11 bytes, null-terminated)
        for (let i = 0; i < field.name.length; i++) {
          bytes[offset + i] = field.name.charCodeAt(i);
        }
        
        // Field type
        bytes[offset + 11] = field.type.charCodeAt(0);
        
        // Field length
        bytes[offset + 16] = field.length;
        
        // Decimal count
        bytes[offset + 17] = field.decimal;
        
        offset += 32;
      });
      
      // Field descriptor terminator
      bytes[offset] = 0x0D;
      offset++;
      
      // Records
      features.forEach((feature, index) => {
        const props = feature.properties;
        
        // Deletion flag (space = not deleted)
        bytes[offset] = 0x20;
        offset++;
        
        // Write field values
        fields.forEach(field => {
          let value = '';
          
          switch (field.name) {
            case 'FID':
              value = String(props.FID || index).padStart(field.length, ' ');
              break;
            case 'PARCEL_ID':
              value = String(props.PARCEL_ID || '').substring(0, field.length).padEnd(field.length, ' ');
              break;
            case 'PARCEL_A':
              value = props.PARCEL_A.toFixed(field.decimal).padStart(field.length, ' ');
              break;
            case 'BUILD_1F':
              value = props.BUILD_1F.toFixed(field.decimal).padStart(field.length, ' ');
              break;
            case 'BUILD_AF':
              value = props.BUILD_AF.toFixed(field.decimal).padStart(field.length, ' ');
              break;
            case 'OPEN_A':
              value = props.OPEN_A.toFixed(field.decimal).padStart(field.length, ' ');
              break;
            case 'BUILD_CNT':
              value = String(props.BUILD_CNT).padStart(field.length, ' ');
              break;
            case 'OSR':
              value = props.OSR.toFixed(field.decimal).padStart(field.length, ' ');
              break;
          }
          
          // Write value
          for (let i = 0; i < field.length; i++) {
            bytes[offset + i] = i < value.length ? value.charCodeAt(i) : 0x20;
          }
          
          offset += field.length;
        });
      });
      
      // End of file marker
      bytes[offset] = 0x1A;
      
      return buffer;
    }
    
    // ===== UTILITY FUNCTIONS =====
    
    function showLoadingIndicator(message) {
      const loadingIndicator = document.getElementById('loadingIndicator');
      const processingStatus = document.getElementById('processingStatus');
      
      if (message) {
        processingStatus.textContent = ": " + message;
      } else {
        processingStatus.textContent = "";
      }
      
      loadingIndicator.style.display = 'block';
      document.getElementById('progressBar').style.width = '0%';
    }
    
    function hideLoadingIndicator() {
      document.getElementById('loadingIndicator').style.display = 'none';
    }
    
    function updateProgress(current, total, message) {
      const percent = Math.min(100, Math.round((current / total) * 100));
      document.getElementById('progressBar').style.width = percent + '%';
      
      if (message) {
        document.getElementById('processingStatus').textContent = ": " + message;
      }
    }
    
    function logMessage(message, level = 'info') {
      const now = new Date();
      const timestamp = now.toLocaleTimeString();
      
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry log-${level}`;
      logEntry.textContent = `[${timestamp}] ${message}`;
      
      const logContent = document.getElementById('logContent');
      logContent.appendChild(logEntry);
      logContent.scrollTop = logContent.scrollHeight;
      
      switch(level) {
        case 'error':
          console.error(message);
          break;
        case 'warning':
          console.warn(message);
          break;
        default:
          console.log(message);
      }
    }
    
    // ===== EVENT LISTENERS =====
    
    function init() {
      createWorkers();
      initMap();
      
      document.getElementById('coordSystem').addEventListener('change', function() {
        currentCRS = this.value;
        logMessage(`Changed UTM Zone to ${currentCRS}`, 'info');
      });
      
      document.getElementById('processStep1').addEventListener('click', processStep1);
      document.getElementById('processStep2').addEventListener('click', processStep2);
      document.getElementById('processStep3').addEventListener('click', processStep3);
      document.getElementById('processStep4').addEventListener('click', processStep4);
      document.getElementById('runAllSteps').addEventListener('click', runAllSteps);
      
      document.getElementById('exportButton').addEventListener('click', exportResult);
      document.getElementById('exportExcelButton').addEventListener('click', exportExcel);
      document.getElementById('exportShapefileButton').addEventListener('click', exportShapefile);
      
      document.getElementById('layerSelect').addEventListener('change', function() {
        displayAttributes(this.value);
      });
      
      document.getElementById('useWebWorkers').addEventListener('change', function() {
        useWebWorkers = this.checked;
        if (useWebWorkers) {
          createWorkers();
        } else {
          terminateWorkers();
        }
        logMessage(`Web Workers ${useWebWorkers ? 'enabled' : 'disabled'}`, 'info');
      });
      
      document.getElementById('toggleLogButton').addEventListener('click', function() {
        const logContainer = document.getElementById('logContainer');
        if (logContainer.style.display === 'none') {
          logContainer.style.display = 'block';
          this.innerHTML = '<i class="fas fa-times"></i> Hide Log';
        } else {
          logContainer.style.display = 'none';
          this.innerHTML = '<i class="fas fa-list"></i> Toggle Log';
        }
      });
      
      logMessage("Application initialized successfully!", 'info');
      logMessage(`Using ${currentCRS} coordinate system`, 'info');
    }
    
    window.onload = init;
  </script>
</body>
</html>
