<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONVERT GIS FILE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shpjs/3.6.3/shp.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shpwrite@latest/shpwrite.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        h1, h2 {
            text-align: center;
            color: #2563eb;
            margin-bottom: 20px;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            margin-right: 5px;
            transition: all 0.3s;
        }
        .tab.active {
            background-color: #2563eb;
            color: white;
            border-color: #2563eb;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            background-color: #f8f9fa;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .upload-area:hover {
            border-color: #2563eb;
            background-color: #f0f4ff;
        }
        .upload-icon {
            font-size: 48px;
            color: #2563eb;
            margin-bottom: 10px;
        }
        .btn {
            background-color: #2563eb;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin: 5px;
        }
        .btn:hover {
            background-color: #1d4ed8;
        }
        .btn:disabled {
            background-color: #93c5fd;
            cursor: not-allowed;
        }
        .result-area {
            margin-top: 20px;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 15px;
            background-color: #f8f9fa;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            display: none;
        }
        .spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid rgba(37, 99, 235, 0.3);
            border-radius: 50%;
            border-top-color: #2563eb;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .error-message {
            color: #dc2626;
            background-color: #fee2e2;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            display: none;
        }
        .success-message {
            color: #059669;
            background-color: #d1fae5;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            display: none;
        }
        .hidden {
            display: none;
        }
        .projection-options {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
            background-color: #f9fafb;
        }
        .projection-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #4b5563;
        }
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .radio-option input {
            margin-right: 10px;
        }
        footer {
            text-align: center;
            margin-top: 30px;
            color: #6b7280;
            font-size: 14px;
        }
        .info-box {
            background-color: #e0f2fe;
            border-left: 4px solid #0ea5e9;
            padding: 10px 15px;
            margin-bottom: 20px;
            border-radius: 0 4px 4px 0;
        }
        .detected-projection {
            font-weight: bold;
            color: #0369a1;
        }
        .navigation-buttons {
            display: flex;
            justify-content: center;
            margin-top: 30px;
            gap: 15px;
        }
        .nav-btn {
            background-color: #4b5563;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
        }
        .nav-btn:hover {
            background-color: #374151;
        }
        .nav-btn i {
            margin-right: 8px;
        }
        .home-btn {
            background-color: #2563eb;
        }
        .home-btn:hover {
            background-color: #2563eb;
        }
        .area-btn {
            background-color: #2563eb;
        }
        .area-btn:hover {
            background-color: #2563eb;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CONVERT GIS FILE</h1>
        
        <div class="tabs">
            <div class="tab active" data-tab="tab1">Shapefile ‚Üí GeoJSON</div>
            <div class="tab" data-tab="tab2">GeoJSON ‚Üí Shapefile</div>
        </div>
        
        <!-- Tab 1: Shapefile to GeoJSON -->
        <div class="tab-content active" id="tab1">
            <h2>Shapefile to GeoJSON Converter</h2>
            
            <div class="error-message" id="errorMessage1"></div>
            <div class="success-message" id="successMessage1"></div>
            
            <div class="upload-area" id="uploadArea1">
                <div class="upload-icon">üìÅ</div>
                <p>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏ó‡∏µ‡πà‡∏°‡∏µ Shapefile (.shp, .dbf, etc.) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á</p>
                <input type="file" id="fileInput1" accept=".zip" style="display: none;">
            </div>
            
            <div class="projection-options">
                <div class="projection-title">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô (‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î):</div>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="original" checked>
                        <span>‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:4326 (WGS84 - ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö GeoJSON)</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="EPSG:32647">
                        <span>‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:32647 (UTM Zone 47N)</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="EPSG:32648">
                        <span>‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:32648 (UTM Zone 48N)</span>
                    </label>
                </div>
            </div>
            
            <div id="loadingSpinner1" class="hidden" style="text-align: center;">
                <div class="spinner"></div>
                <p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile...</p>
            </div>
            
            <div id="resultContainer1" class="hidden" style="text-align: center;">
                <p>‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!</p>
                <button id="downloadBtn1" class="btn">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î GeoJSON</button>
            </div>
            
            <pre id="resultPreview1" class="result-area"></pre>
        </div>
        
        <!-- Tab 2: GeoJSON to Shapefile -->
        <div class="tab-content" id="tab2">
            <h2>GeoJSON to Shapefile Converter</h2>
            
            <div class="error-message" id="errorMessage2"></div>
            <div class="success-message" id="successMessage2"></div>
            
            <div id="projectionInfo" class="info-box hidden">
                <p>‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô: <span id="detectedProjection" class="detected-projection">EPSG:4326 (WGS84)</span></p>
                <p>‡∏à‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Shapefile ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö</p>
            </div>
            
            <div class="upload-area" id="uploadArea2">
                <div class="upload-icon">üìä</div>
                <p>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå GeoJSON (.geojson, .json) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á</p>
                <input type="file" id="fileInput2" accept=".geojson,.json" style="display: none;">
            </div>
            
            <div id="loadingSpinner2" class="hidden" style="text-align: center;">
                <div class="spinner"></div>
                <p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå GeoJSON...</p>
            </div>
            
            <div id="resultContainer2" class="hidden" style="text-align: center;">
                <p>‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!</p>
                <button id="downloadBtn2" class="btn">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Shapefile (ZIP)</button>
            </div>
            
            <pre id="resultPreview2" class="result-area"></pre>
        </div>
        
        <!-- Navigation Buttons -->
        <div class="navigation-buttons">
            <a href="https://mponline1.github.io/" class="nav-btn home-btn">
                <i></i> ‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å
            </a>
            <a href="https://mponline1.github.io/page11.html" class="nav-btn area-btn">
                <i></i> Calculate AREA
            </a>
        </div>
    </div>

    <script>
        // Tab Switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId === 'tab1' ? 'tab1' : 'tab2').classList.add('active');
            });
        });
        
        // Define projection definitions
        const projDefinitions = {
            'EPSG:4326': '+proj=longlat +datum=WGS84 +no_defs', // WGS84 - standard GeoJSON
            'EPSG:32647': '+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs', // UTM zone 47N
            'EPSG:32648': '+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs'  // UTM zone 48N
        };
        
        // Register projections with proj4js
        for (const [code, def] of Object.entries(projDefinitions)) {
            proj4.defs(code, def);
        }
        
        // ******************************************
        // PART 1: SHAPEFILE TO GEOJSON
        // ******************************************
        
        // DOM Elements
        const uploadArea1 = document.getElementById('uploadArea1');
        const fileInput1 = document.getElementById('fileInput1');
        const loadingSpinner1 = document.getElementById('loadingSpinner1');
        const resultContainer1 = document.getElementById('resultContainer1');
        const downloadBtn1 = document.getElementById('downloadBtn1');
        const resultPreview1 = document.getElementById('resultPreview1');
        const errorMessage1 = document.getElementById('errorMessage1');
        const successMessage1 = document.getElementById('successMessage1');
        const projectionOptions1 = document.getElementsByName('projection1');
        
        // Global variables
        let originalGeoJSON = null;
        let convertedGeoJSON = null;
        let fileName1 = 'converted';
        
        // Setup event listeners
        uploadArea1.addEventListener('click', () => fileInput1.click());
        uploadArea1.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#2563eb';
            uploadArea1.style.backgroundColor = '#f0f4ff';
        });
        uploadArea1.addEventListener('dragleave', () => {
            uploadArea1.style.borderColor = '#ccc';
            uploadArea1.style.backgroundColor = '#f8f9fa';
        });
        uploadArea1.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#ccc';
            uploadArea1.style.backgroundColor = '#f8f9fa';
            
            if (e.dataTransfer.files.length) {
                handleShapefileUpload(e.dataTransfer.files[0]);
            }
        });
        fileInput1.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleShapefileUpload(e.target.files[0]);
            }
        });
        downloadBtn1.addEventListener('click', downloadGeoJSON);
        
        // Add event listeners for projection change
        projectionOptions1.forEach(option => {
            option.addEventListener('change', () => {
                if (originalGeoJSON) {
                    const selectedProjection = getSelectedProjection1();
                    
                    if (selectedProjection === 'original') {
                        convertedGeoJSON = originalGeoJSON;
                        updatePreview1(convertedGeoJSON);
                        showMessage1('‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:4326 (WGS84) ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß', 'success');
                    } else {
                        try {
                            convertedGeoJSON = transformGeoJSON(originalGeoJSON, selectedProjection);
                            updatePreview1(convertedGeoJSON);
                            showMessage1(`‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô ${selectedProjection} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß`, 'success');
                        } catch (error) {
                            showError1(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô: ${error.message}`);
                        }
                    }
                }
            });
        });
        
        // Function to get selected projection
        function getSelectedProjection1() {
            for (const option of projectionOptions1) {
                if (option.checked) {
                    return option.value;
                }
            }
            return 'original';
        }
        
        // Function to handle file upload
        function handleShapefileUpload(file) {
            if (!file.name.endsWith('.zip')) {
                showError1('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• shapefile');
                return;
            }
            
            fileName1 = file.name.replace('.zip', '');
            resetUI1();
            showLoading1();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const zipData = e.target.result;
                    await processShapefileZip(zipData);
                } catch (error) {
                    console.error('Conversion error:', error);
                    showError1(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå: ${error.message}`);
                    hideLoading1();
                }
            };
            reader.onerror = () => {
                showError1('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå');
                hideLoading1();
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Process zip file
        async function processShapefileZip(zipData) {
            try {
                const zip = await JSZip.loadAsync(zipData);
                const fileNames = Object.keys(zip.files);
                
                // Check for required shapefile components
                const hasSHP = fileNames.some(name => name.toLowerCase().endsWith('.shp'));
                const hasDBF = fileNames.some(name => name.toLowerCase().endsWith('.dbf'));
                
                if (!hasSHP || !hasDBF) {
                    throw new Error('‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå .shp ‡πÅ‡∏•‡∏∞ .dbf ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢');
                }
                
                // Using shp.js to convert
                const geojson = await shp(zipData);
                originalGeoJSON = geojson;
                
                // Apply projection transformation if needed
                const selectedProjection = getSelectedProjection1();
                if (selectedProjection !== 'original') {
                    convertedGeoJSON = transformGeoJSON(originalGeoJSON, selectedProjection);
                } else {
                    convertedGeoJSON = originalGeoJSON;
                }
                
                // Update preview
                updatePreview1(convertedGeoJSON);
                
                // Show success
                hideLoading1();
                showSuccess1();
                
            } catch (error) {
                console.error('Error processing zip:', error);
                showError1(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå ZIP: ${error.message}`);
                hideLoading1();
            }
        }
        
        // Function to transform GeoJSON to a different projection
        function transformGeoJSON(geojson, targetProjection) {
            // Deep clone the original GeoJSON to avoid modifying it
            const transformedGeoJSON = JSON.parse(JSON.stringify(geojson));
            
            // Function to transform coordinates
            function transformCoordinates(coords) {
                if (Array.isArray(coords[0]) && typeof coords[0][0] === 'number') {
                    // This is a LineString
                    return coords.map(coord => proj4('EPSG:4326', targetProjection, coord));
                } else if (Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                    // This is a Polygon or MultiLineString
                    return coords.map(line => transformCoordinates(line));
                } else if (Array.isArray(coords[0]) && Array.isArray(coords[0][0]) && Array.isArray(coords[0][0][0])) {
                    // This is a MultiPolygon
                    return coords.map(polygon => transformCoordinates(polygon));
                } else {
                    // This is a Point
                    return proj4('EPSG:4326', targetProjection, coords);
                }
            }
            
            // Process each feature
            if (transformedGeoJSON.type === 'FeatureCollection') {
                transformedGeoJSON.features.forEach(feature => {
                    if (feature.geometry) {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (transformedGeoJSON.type === 'Feature') {
                transformedGeoJSON.geometry.coordinates = transformCoordinates(transformedGeoJSON.geometry.coordinates);
            }
            
            // Update CRS property
            transformedGeoJSON.crs = {
                type: 'name',
                properties: {
                    name: targetProjection
                }
            };
            
            return transformedGeoJSON;
        }
        
        // Update preview
        function updatePreview1(geojson) {
            const jsonString = JSON.stringify(geojson, null, 2);
            const preview = jsonString.length > 500 
                ? jsonString.substring(0, 500) + '...' 
                : jsonString;
            
            resultPreview1.textContent = preview;
            resultPreview1.style.display = 'block';
        }
        
        // Download GeoJSON function
        function downloadGeoJSON() {
            if (!convertedGeoJSON) return;
            
            const jsonString = JSON.stringify(convertedGeoJSON);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const selectedProjection = getSelectedProjection1();
            let downloadFileName = fileName1;
            
            if (selectedProjection !== 'original') {
                downloadFileName += `_${selectedProjection.replace(':', '_')}`;
            }
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${downloadFileName}.geojson`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage1('‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå GeoJSON ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!', 'success');
        }
        
        // UI Helper functions
        function resetUI1() {
            errorMessage1.style.display = 'none';
            successMessage1.style.display = 'none';
            resultPreview1.style.display = 'none';
            resultContainer1.classList.add('hidden');
        }
        
        function showLoading1() {
            loadingSpinner1.classList.remove('hidden');
        }
        
        function hideLoading1() {
            loadingSpinner1.classList.add('hidden');
        }
        
        function showSuccess1() {
            resultContainer1.classList.remove('hidden');
            showMessage1('‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!', 'success');
        }
        
        function showError1(message) {
            errorMessage1.textContent = message;
            errorMessage1.style.display = 'block';
            successMessage1.style.display = 'none';
        }
        
        function showMessage1(message, type) {
            if (type === 'error') {
                errorMessage1.textContent = message;
                errorMessage1.style.display = 'block';
                successMessage1.style.display = 'none';
            } else {
                successMessage1.textContent = message;
                successMessage1.style.display = 'block';
                errorMessage1.style.display = 'none';
            }
        }
        
        // ******************************************
        // PART 2: GEOJSON TO SHAPEFILE
        // ******************************************
        
        // DOM Elements
        const uploadArea2 = document.getElementById('uploadArea2');
        const fileInput2 = document.getElementById('fileInput2');
        const loadingSpinner2 = document.getElementById('loadingSpinner2');
        const resultContainer2 = document.getElementById('resultContainer2');
        const downloadBtn2 = document.getElementById('downloadBtn2');
        const resultPreview2 = document.getElementById('resultPreview2');
        const errorMessage2 = document.getElementById('errorMessage2');
        const successMessage2 = document.getElementById('successMessage2');
        const projectionInfo = document.getElementById('projectionInfo');
        const detectedProjection = document.getElementById('detectedProjection');
        
        // Global variables for GeoJSON to Shapefile
        let originalGeoJSONData = null;
        let fileName2 = 'converted';
        let detectedCRS = 'EPSG:4326'; // Default CRS
        let shapefileZip = null;
        
        // Setup event listeners
        uploadArea2.addEventListener('click', () => fileInput2.click());
        uploadArea2.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#2563eb';
            uploadArea2.style.backgroundColor = '#f0f4ff';
        });
        uploadArea2.addEventListener('dragleave', () => {
            uploadArea2.style.borderColor = '#ccc';
            uploadArea2.style.backgroundColor = '#f8f9fa';
        });
        uploadArea2.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#ccc';
            uploadArea2.style.backgroundColor = '#f8f9fa';
            
            if (e.dataTransfer.files.length) {
                handleGeoJSONUpload(e.dataTransfer.files[0]);
            }
        });
        fileInput2.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleGeoJSONUpload(e.target.files[0]);
            }
        });
        downloadBtn2.addEventListener('click', downloadShapefile);
        
        // Function to handle GeoJSON file upload
        function handleGeoJSONUpload(file) {
            if (!file.name.endsWith('.geojson') && !file.name.endsWith('.json')) {
                showError2('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå GeoJSON (.geojson ‡∏´‡∏£‡∏∑‡∏≠ .json)');
                return;
            }
            
            fileName2 = file.name.replace('.geojson', '').replace('.json', '');
            resetUI2();
            showLoading2();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const jsonData = e.target.result;
                    await processGeoJSONFile(jsonData);
                } catch (error) {
                    console.error('GeoJSON processing error:', error);
                    showError2(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå GeoJSON: ${error.message}`);
                    hideLoading2();
                }
            };
            reader.onerror = () => {
                showError2('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå');
                hideLoading2();
            };
            reader.readAsText(file);
        }
        
        // Process GeoJSON file
        async function processGeoJSONFile(jsonData) {
            try {
                // Parse the GeoJSON data
                const geoJSONObj = JSON.parse(jsonData);
                originalGeoJSONData = geoJSONObj;
                
                // Detect the projection/CRS from the GeoJSON
                detectGeoJSONProjection(geoJSONObj);
                
                // Process with the detected projection
                await processGeoJSONWithProjection();
                
                // Show success
                hideLoading2();
                showSuccess2();
                
            } catch (error) {
                console.error('Error processing GeoJSON:', error);
                showError2(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå GeoJSON: ${error.message}`);
                hideLoading2();
            }
        }
        
        // Function to detect projection from GeoJSON
        function detectGeoJSONProjection(geoJSON) {
            let crs = 'EPSG:4326'; // Default
            
            // Check if the GeoJSON has a CRS property
            if (geoJSON.crs && geoJSON.crs.properties && geoJSON.crs.properties.name) {
                const crsName = geoJSON.crs.properties.name;
                
                // Handle different CRS formats (e.g., 'EPSG:4326', 'urn:ogc:def:crs:EPSG::4326', etc.)
                if (crsName.includes('EPSG')) {
                    // Extract the EPSG code
                    let epsgCode = '';
                    
                    if (crsName.startsWith('EPSG:')) {
                        epsgCode = crsName; // Already in the right format
                    } else if (crsName.includes('EPSG')) {
                        // Try to extract the code using regex
                        const epsgMatch = crsName.match(/EPSG[:]{0,2}(\d+)/);
                        if (epsgMatch && epsgMatch[1]) {
                            epsgCode = `EPSG:${epsgMatch[1]}`;
                        }
                    }
                    
                    // Check if we found a valid EPSG code and it's in our supported list
                    if (epsgCode && projDefinitions[epsgCode]) {
                        crs = epsgCode;
                    }
                }
            }
            
            // Update the detected projection information
            detectedCRS = crs;
            detectedProjection.textContent = crs === 'EPSG:4326' ? 
                'EPSG:4326 (WGS84)' : 
                crs === 'EPSG:32647' ? 
                'EPSG:32647 (UTM Zone 47N)' : 
                crs === 'EPSG:32648' ? 
                'EPSG:32648 (UTM Zone 48N)' : 
                crs;
            
            // Show the projection info box
            projectionInfo.classList.remove('hidden');
            
            return crs;
        }
        
        // Process GeoJSON with detected projection
        async function processGeoJSONWithProjection() {
            try {
                // Use only the detected projection
                await createShapefile(originalGeoJSONData);
                
                // Update preview
                updatePreview2(originalGeoJSONData);
                
                showMessage2(`GeoJSON ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Shapefile ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô ${detectedCRS}`, 'success');
                
            } catch (error) {
                console.error('Error processing GeoJSON with projection:', error);
                showError2(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô: ${error.message}`);
            }
        }
        
        // Function to create Shapefile from GeoJSON
        async function createShapefile(geoJSON) {
            try {
                // Create a new instance of JSZip
                const zip = new JSZip();
                
                // Extract features from GeoJSON
                let features = [];
                if (geoJSON.type === 'FeatureCollection') {
                    features = geoJSON.features;
                } else if (geoJSON.type === 'Feature') {
                    features = [geoJSON];
                }
                
                if (features.length === 0) {
                    throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Feature ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå GeoJSON');
                }
                
                // Group features by geometry type
                let points = [];
                let lines = [];
                let polygons = [];
                
                features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    const geomType = feature.geometry.type.toLowerCase();
                    
                    if (geomType === 'point' || geomType === 'multipoint') {
                        points.push(feature);
                    } else if (geomType === 'linestring' || geomType === 'multilinestring') {
                        lines.push(feature);
                    } else if (geomType === 'polygon' || geomType === 'multipolygon') {
                        polygons.push(feature);
                    }
                });
                
                // Flag to track if we added any shapefiles
                let filesAdded = false;
                
                // Create a .prj file with the correct projection
                let prjContent = '';
                
                if (detectedCRS === 'EPSG:4326' || detectedCRS.includes('4326')) {
                    // WGS84
                    prjContent = 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]';
                } else if (detectedCRS === 'EPSG:32647' || detectedCRS.includes('32647')) {
                    // UTM Zone 47N
                    prjContent = 'PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",99],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
                } else if (detectedCRS === 'EPSG:32648' || detectedCRS.includes('32648')) {
                    // UTM Zone 48N
                    prjContent = 'PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",105],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
                }
                
                // Create separate shapefiles for each geometry type
                // Points
                if (points.length > 0) {
                    const pointGeoJSON = {
                        type: 'FeatureCollection',
                        features: points,
                        crs: geoJSON.crs
                    };
                    
                    await createShapefileForFeatureType(pointGeoJSON, 'point', zip, prjContent);
                    filesAdded = true;
                }
                
                // Lines
                if (lines.length > 0) {
                    const lineGeoJSON = {
                        type: 'FeatureCollection',
                        features: lines,
                        crs: geoJSON.crs
                    };
                    
                    await createShapefileForFeatureType(lineGeoJSON, 'line', zip, prjContent);
                    filesAdded = true;
                }
                
                // Polygons
                if (polygons.length > 0) {
                    const polygonGeoJSON = {
                        type: 'FeatureCollection',
                        features: polygons,
                        crs: geoJSON.crs
                    };
                    
                    await createShapefileForFeatureType(polygonGeoJSON, 'polygon', zip, prjContent);
                    filesAdded = true;
                }
                
                if (!filesAdded) {
                    throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile ‡πÑ‡∏î‡πâ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                }
                
                // Generate the ZIP file
                shapefileZip = await zip.generateAsync({type: 'blob'});
                
                return true;
                
            } catch (error) {
                console.error('Error creating shapefile:', error);
                throw new Error(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile: ${error.message}`);
            }
        }
        
        // Create a shapefile for a specific feature type
        async function createShapefileForFeatureType(geoJSON, type, zip, prjContent) {
            try {
                const typeSuffix = type === 'point' ? 'point' : (type === 'line' ? 'line' : 'poly');
                const baseName = `${fileName2}_${typeSuffix}`;
                
                // Use shpwrite to create proper shapefile binary data
                return new Promise((resolve, reject) => {
                    try {
                        // Determine geometry type for shpwrite
                        let geomType;
                        if (type === 'point') {
                            geomType = 'POINT';
                        } else if (type === 'line') {
                            geomType = 'POLYLINE';
                        } else {
                            geomType = 'POLYGON';
                        }
                        
                        // Use shpwrite to generate shapefile components
                        shpwrite.write(geoJSON.features, geomType, function(err, files) {
                            if (err) {
                                console.error('shpwrite error:', err);
                                // Use fallback method
                                createBasicShapefile(geoJSON, type, zip, prjContent)
                                    .then(resolve)
                                    .catch(reject);
                                return;
                            }
                            
                            try {
                                // Add shapefile components to zip
                                if (files.shp) {
                                    zip.file(`${baseName}.shp`, files.shp.buffer, {binary: true});
                                }
                                if (files.shx) {
                                    zip.file(`${baseName}.shx`, files.shx.buffer, {binary: true});
                                }
                                if (files.dbf) {
                                    zip.file(`${baseName}.dbf`, files.dbf.buffer, {binary: true});
                                }
                                
                                // Add custom PRJ file with correct projection
                                if (prjContent) {
                                    zip.file(`${baseName}.prj`, prjContent);
                                }
                                
                                // Add CPG file for UTF-8 encoding
                                zip.file(`${baseName}.cpg`, 'UTF-8');
                                
                                resolve(true);
                            } catch (error) {
                                console.error('Error adding files to zip:', error);
                                reject(error);
                            }
                        });
                    } catch (error) {
                        console.error('Error in shpwrite.write:', error);
                        // Use fallback method
                        createBasicShapefile(geoJSON, type, zip, prjContent)
                            .then(resolve)
                            .catch(reject);
                    }
                });
            } catch (error) {
                console.error(`Error creating ${type} shapefile:`, error);
                // Use fallback method
                return createBasicShapefile(geoJSON, type, zip, prjContent);
            }
        }
        
        // Fallback function to create basic shapefile structure with proper binary format
        async function createBasicShapefile(geoJSON, type, zip, prjContent) {
            try {
                const typeSuffix = type === 'point' ? 'point' : (type === 'line' ? 'line' : 'poly');
                const baseName = `${fileName2}_${typeSuffix}`;
                
                // Collect all coordinates and properties
                const features = geoJSON.features;
                const properties = features.length > 0 ? Object.keys(features[0].properties || {}) : [];
                
                // Calculate bounding box
                const bbox = calculateBoundingBox(geoJSON);
                
                // Determine shape type
                let shapeType = 0;
                if (type === 'point') shapeType = 1;      // Point
                else if (type === 'line') shapeType = 3;   // Polyline
                else if (type === 'polygon') shapeType = 5; // Polygon
                
                // Create SHP file
                const shpData = createCompleteShpFile(features, shapeType, bbox);
                zip.file(`${baseName}.shp`, shpData, {binary: true});
                
                // Create SHX file (index)
                const shxData = createCompleteShxFile(features, shapeType);
                zip.file(`${baseName}.shx`, shxData, {binary: true});
                
                // Create DBF file (attributes)
                const dbfData = createCompleteDbfFile(features, properties);
                zip.file(`${baseName}.dbf`, dbfData, {binary: true});
                
                // Add PRJ file
                if (prjContent) {
                    zip.file(`${baseName}.prj`, prjContent);
                }
                
                // Add CPG file for UTF-8 encoding
                zip.file(`${baseName}.cpg`, 'UTF-8');
                
                return true;
            } catch (error) {
                console.error('Error in fallback shapefile creation:', error);
                throw error;
            }
        }
        
        // Create complete SHP file with proper structure
        function createCompleteShpFile(features, shapeType, bbox) {
            const records = [];
            let offset = 50; // Header is 100 bytes = 50 16-bit words
            
            features.forEach((feature, index) => {
                const recordHeader = new ArrayBuffer(8);
                const recordHeaderView = new DataView(recordHeader);
                
                // Record number (1-based, big-endian)
                recordHeaderView.setInt32(0, index + 1, false);
                
                // Content length will be calculated based on geometry
                let contentLength = 0;
                let shapeData;
                
                if (shapeType === 1) { // Point
                    contentLength = 10; // 20 bytes = 10 words (4 for type + 16 for coordinates)
                    shapeData = createPointRecord(feature.geometry);
                } else if (shapeType === 3) { // Polyline
                    const result = createPolylineRecord(feature.geometry);
                    contentLength = result.length;
                    shapeData = result.data;
                } else if (shapeType === 5) { // Polygon
                    const result = createPolygonRecord(feature.geometry);
                    contentLength = result.length;
                    shapeData = result.data;
                }
                
                recordHeaderView.setInt32(4, contentLength, false);
                
                records.push({
                    header: recordHeader,
                    data: shapeData,
                    offset: offset,
                    length: contentLength
                });
                
                offset += 4 + contentLength; // 4 words for record header + content length
            });
            
            // Calculate total file length in 16-bit words
            const fileLengthWords = offset;
            
            // Create main header (100 bytes)
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            
            // File code (9994) - big endian
            headerView.setInt32(0, 9994, false);
            
            // Unused positions (5 int32)
            for (let i = 4; i < 24; i += 4) {
                headerView.setInt32(i, 0, false);
            }
            
            // File length in 16-bit words - big endian
            headerView.setInt32(24, fileLengthWords, false);
            
            // Version (1000) - little endian
            headerView.setInt32(28, 1000, true);
            
            // Shape type - little endian
            headerView.setInt32(32, shapeType, true);
            
            // Bounding box - little endian
            headerView.setFloat64(36, bbox.xmin, true);
            headerView.setFloat64(44, bbox.ymin, true);
            headerView.setFloat64(52, bbox.xmax, true);
            headerView.setFloat64(60, bbox.ymax, true);
            
            // Z range (unused, set to 0)
            headerView.setFloat64(68, 0, true);
            headerView.setFloat64(76, 0, true);
            
            // M range (unused, set to 0)
            headerView.setFloat64(84, 0, true);
            headerView.setFloat64(92, 0, true);
            
            // Combine header and all records
            const totalSize = 100 + records.reduce((sum, rec) => sum + 8 + rec.data.byteLength, 0);
            const result = new Uint8Array(totalSize);
            
            // Copy header
            result.set(new Uint8Array(header), 0);
            
            // Copy records
            let position = 100;
            records.forEach(record => {
                result.set(new Uint8Array(record.header), position);
                position += 8;
                result.set(new Uint8Array(record.data), position);
                position += record.data.byteLength;
            });
            
            return result.buffer;
        }
        
        // Create point record
        function createPointRecord(geometry) {
            const buffer = new ArrayBuffer(20); // 4 bytes type + 16 bytes coordinates
            const view = new DataView(buffer);
            
            // Shape type (1 = Point)
            view.setInt32(0, 1, true);
            
            // X coordinate
            view.setFloat64(4, geometry.coordinates[0], true);
            
            // Y coordinate
            view.setFloat64(12, geometry.coordinates[1], true);
            
            return buffer;
        }
        
        // Create polyline record
        function createPolylineRecord(geometry) {
            const coords = geometry.type === 'LineString' ? [geometry.coordinates] : geometry.coordinates;
            const numParts = coords.length;
            const numPoints = coords.reduce((sum, part) => sum + part.length, 0);
            
            // Calculate size: 4 (type) + 32 (bbox) + 4 (numParts) + 4 (numPoints) + 4*numParts (parts) + 16*numPoints (points)
            const size = 44 + 4 * numParts + 16 * numPoints;
            const buffer = new ArrayBuffer(size);
            const view = new DataView(buffer);
            
            // Shape type (3 = Polyline)
            view.setInt32(0, 3, true);
            
            // Bounding box
            const bbox = calculateGeometryBbox(coords);
            view.setFloat64(4, bbox.xmin, true);
            view.setFloat64(12, bbox.ymin, true);
            view.setFloat64(20, bbox.xmax, true);
            view.setFloat64(28, bbox.ymax, true);
            
            // Number of parts
            view.setInt32(36, numParts, true);
            
            // Number of points
            view.setInt32(40, numPoints, true);
            
            // Parts (starting index of each part)
            let offset = 44;
            let pointIndex = 0;
            for (let i = 0; i < numParts; i++) {
                view.setInt32(offset, pointIndex, true);
                offset += 4;
                pointIndex += coords[i].length;
            }
            
            // Points
            coords.forEach(part => {
                part.forEach(point => {
                    view.setFloat64(offset, point[0], true);
                    view.setFloat64(offset + 8, point[1], true);
                    offset += 16;
                });
            });
            
            return {
                data: buffer,
                length: size / 2 // Length in 16-bit words
            };
        }
        
        // Create polygon record
        function createPolygonRecord(geometry) {
            const coords = geometry.type === 'Polygon' ? [geometry.coordinates] : geometry.coordinates;
            const allRings = coords.flat();
            const numParts = allRings.length;
            const numPoints = allRings.reduce((sum, ring) => sum + ring.length, 0);
            
            // Calculate size
            const size = 44 + 4 * numParts + 16 * numPoints;
            const buffer = new ArrayBuffer(size);
            const view = new DataView(buffer);
            
            // Shape type (5 = Polygon)
            view.setInt32(0, 5, true);
            
            // Bounding box
            const bbox = calculateGeometryBbox(allRings);
            view.setFloat64(4, bbox.xmin, true);
            view.setFloat64(12, bbox.ymin, true);
            view.setFloat64(20, bbox.xmax, true);
            view.setFloat64(28, bbox.ymax, true);
            
            // Number of parts
            view.setInt32(36, numParts, true);
            
            // Number of points
            view.setInt32(40, numPoints, true);
            
            // Parts
            let offset = 44;
            let pointIndex = 0;
            for (let i = 0; i < numParts; i++) {
                view.setInt32(offset, pointIndex, true);
                offset += 4;
                pointIndex += allRings[i].length;
            }
            
            // Points
            allRings.forEach(ring => {
                ring.forEach(point => {
                    view.setFloat64(offset, point[0], true);
                    view.setFloat64(offset + 8, point[1], true);
                    offset += 16;
                });
            });
            
            return {
                data: buffer,
                length: size / 2
            };
        }
        
        // Create complete SHX file
        function createCompleteShxFile(features, shapeType) {
            // Header (100 bytes) + 8 bytes per record
            const size = 100 + features.length * 8;
            const buffer = new ArrayBuffer(size);
            const view = new DataView(buffer);
            
            // File code (9994) - big endian
            view.setInt32(0, 9994, false);
            
            // File length in 16-bit words - big endian
            view.setInt32(24, size / 2, false);
            
            // Version (1000) - little endian
            view.setInt32(28, 1000, true);
            
            // Shape type - little endian
            view.setInt32(32, shapeType, true);
            
            // Write record offsets and lengths
            let offset = 50; // Start after header (100 bytes / 2)
            let position = 100;
            
            features.forEach((feature, index) => {
                // Record offset in 16-bit words - big endian
                view.setInt32(position, offset, false);
                
                // Content length in 16-bit words - big endian
                let contentLength = 10; // Default for points
                
                if (shapeType === 3 || shapeType === 5) {
                    // Calculate for polyline/polygon
                    const coords = feature.geometry.type.includes('Multi') 
                        ? feature.geometry.coordinates.flat()
                        : (feature.geometry.type === 'Polygon' ? feature.geometry.coordinates : [feature.geometry.coordinates]);
                    const numParts = coords.length;
                    const numPoints = coords.reduce((sum, part) => sum + part.length, 0);
                    contentLength = (44 + 4 * numParts + 16 * numPoints) / 2;
                }
                
                view.setInt32(position + 4, contentLength, false);
                
                offset += 4 + contentLength;
                position += 8;
            });
            
            return buffer;
        }
        
        // Create complete DBF file
        // Create complete DBF file with proper field types and lengths
        function createCompleteDbfFile(features, properties) {
            const numRecords = features.length;
            
            // Analyze field types and calculate appropriate lengths
            const fieldDefinitions = [];
            
            // Add FID field
            fieldDefinitions.push({
                name: 'FID',
                type: 'N',
                length: 10,
                decimal: 0
            });
            
            // Analyze properties from first few features to determine types and lengths
            properties.forEach(prop => {
                let fieldType = 'C'; // Default to Character
                let maxLength = 10;
                let decimalCount = 0;
                
                // Sample data from features to determine type and max length
                let hasNumber = false;
                let hasDecimal = false;
                let hasDate = false;
                
                features.forEach(feature => {
                    if (!feature.properties || feature.properties[prop] === undefined || feature.properties[prop] === null) {
                        return;
                    }
                    
                    const value = feature.properties[prop];
                    const valueStr = value.toString();
                    
                    // Check if it's a number
                    if (typeof value === 'number' || !isNaN(parseFloat(valueStr))) {
                        hasNumber = true;
                        if (valueStr.includes('.')) {
                            hasDecimal = true;
                            const parts = valueStr.split('.');
                            if (parts[1]) {
                                decimalCount = Math.max(decimalCount, parts[1].length);
                            }
                        }
                    }
                    
                    // Check if it's a date
                    if (value instanceof Date || /^\d{4}-\d{2}-\d{2}/.test(valueStr)) {
                        hasDate = true;
                    }
                    
                    // Track max length
                    maxLength = Math.max(maxLength, valueStr.length);
                });
                
                // Determine field type
                if (hasDate) {
                    fieldType = 'D';
                    maxLength = 8; // YYYYMMDD format
                    decimalCount = 0;
                } else if (hasNumber) {
                    fieldType = hasDecimal ? 'F' : 'N'; // Float or Numeric
                    maxLength = Math.min(Math.max(maxLength, 10), 20);
                    if (hasDecimal) {
                        decimalCount = Math.min(decimalCount, 6);
                    }
                } else {
                    fieldType = 'C'; // Character
                    maxLength = Math.min(Math.max(maxLength, 10), 254); // DBF max is 254
                }
                
                fieldDefinitions.push({
                    name: prop.substring(0, 10), // Field name max 10 chars
                    type: fieldType,
                    length: maxLength,
                    decimal: decimalCount
                });
            });
            
            const numFields = fieldDefinitions.length;
            
            // Calculate record size
            const recordSize = fieldDefinitions.reduce((sum, field) => sum + field.length, 0) + 1; // +1 for deletion flag
            
            // Header: 32 bytes + 32 bytes per field + 1 terminator
            const headerSize = 32 + numFields * 32 + 1;
            const totalSize = headerSize + numRecords * recordSize + 1; // +1 for EOF marker
            
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);
            
            // Write DBF Header (32 bytes)
            view.setUint8(0, 0x03); // dBASE III
            
            // Last update date
            const now = new Date();
            view.setUint8(1, now.getFullYear() - 1900);
            view.setUint8(2, now.getMonth() + 1);
            view.setUint8(3, now.getDate());
            
            // Number of records (little-endian)
            view.setUint32(4, numRecords, true);
            
            // Header size (little-endian)
            view.setUint16(8, headerSize, true);
            
            // Record size (little-endian)
            view.setUint16(10, recordSize, true);
            
            // Reserved bytes (12-31) are already 0
            
            // Write Field Descriptors
            let fieldOffset = 32;
            
            fieldDefinitions.forEach(field => {
                // Field name (11 bytes, null-terminated)
                for (let i = 0; i < field.name.length && i < 10; i++) {
                    uint8View[fieldOffset + i] = field.name.charCodeAt(i);
                }
                // Fill remaining with null
                for (let i = field.name.length; i < 11; i++) {
                    uint8View[fieldOffset + i] = 0x00;
                }
                
                // Field type (1 byte)
                uint8View[fieldOffset + 11] = field.type.charCodeAt(0);
                
                // Field data address (4 bytes) - not used in DBF III, set to 0
                view.setUint32(fieldOffset + 12, 0, true);
                
                // Field length (1 byte)
                view.setUint8(fieldOffset + 16, field.length);
                
                // Decimal count (1 byte)
                view.setUint8(fieldOffset + 17, field.decimal);
                
                // Reserved bytes (18-31) are already 0
                
                fieldOffset += 32;
            });
            
            // Field descriptor terminator
            uint8View[fieldOffset] = 0x0D;
            
            // Write Records
            let recordOffset = headerSize;
            
            features.forEach((feature, index) => {
                // Deletion flag (0x20 = not deleted, 0x2A = deleted)
                uint8View[recordOffset] = 0x20;
                recordOffset++;
                
                // Write each field value
                fieldDefinitions.forEach((field, fieldIndex) => {
                    let value = '';
                    
                    if (fieldIndex === 0) {
                        // FID field
                        value = (index + 1).toString();
                    } else {
                        // Property field
                        const propName = properties[fieldIndex - 1];
                        const propValue = feature.properties && feature.properties[propName];
                        
                        if (propValue !== undefined && propValue !== null) {
                            if (field.type === 'D' && propValue instanceof Date) {
                                // Date format: YYYYMMDD
                                const year = propValue.getFullYear().toString().padStart(4, '0');
                                const month = (propValue.getMonth() + 1).toString().padStart(2, '0');
                                const day = propValue.getDate().toString().padStart(2, '0');
                                value = year + month + day;
                            } else if (field.type === 'D' && typeof propValue === 'string') {
                                // Try to parse date string
                                const dateMatch = propValue.match(/(\d{4})-(\d{2})-(\d{2})/);
                                if (dateMatch) {
                                    value = dateMatch[1] + dateMatch[2] + dateMatch[3];
                                } else {
                                    value = propValue.replace(/[^0-9]/g, '').substring(0, 8);
                                }
                            } else if (field.type === 'N' || field.type === 'F') {
                                // Numeric or Float
                                const numValue = typeof propValue === 'number' ? propValue : parseFloat(propValue);
                                if (!isNaN(numValue)) {
                                    if (field.decimal > 0) {
                                        value = numValue.toFixed(field.decimal);
                                    } else {
                                        value = Math.round(numValue).toString();
                                    }
                                } else {
                                    value = '';
                                }
                            } else {
                                // Character
                                value = propValue.toString();
                            }
                        }
                    }
                    
                    // Trim or pad value to field length
                    if (field.type === 'N' || field.type === 'F') {
                        // Right-align numeric fields
                        value = value.substring(0, field.length).padStart(field.length, ' ');
                    } else {
                        // Left-align character and date fields
                        value = value.substring(0, field.length).padEnd(field.length, ' ');
                    }
                    
                    // Write field value
                    for (let i = 0; i < field.length; i++) {
                        uint8View[recordOffset + i] = value.charCodeAt(i) || 0x20; // Use space if undefined
                    }
                    
                    recordOffset += field.length;
                });
            });
            
            // End of file marker
            uint8View[totalSize - 1] = 0x1A;
            
            return buffer;
        }
        
        // Calculate geometry bounding box
        function calculateGeometryBbox(coords) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            const processCoord = (coord) => {
                if (Array.isArray(coord[0])) {
                    coord.forEach(processCoord);
                } else {
                    xmin = Math.min(xmin, coord[0]);
                    ymin = Math.min(ymin, coord[1]);
                    xmax = Math.max(xmax, coord[0]);
                    ymax = Math.max(ymax, coord[1]);
                }
            };
            
            coords.forEach(processCoord);
            
            return { xmin, ymin, xmax, ymax };
        }
        
        // Helper function to calculate bounding box
        function calculateBoundingBox(geoJSON) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            geoJSON.features.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;
                
                const coords = feature.geometry.coordinates;
                const processCoord = (coord) => {
                    if (Array.isArray(coord[0])) {
                        coord.forEach(processCoord);
                    } else {
                        xmin = Math.min(xmin, coord[0]);
                        ymin = Math.min(ymin, coord[1]);
                        xmax = Math.max(xmax, coord[0]);
                        ymax = Math.max(ymax, coord[1]);
                    }
                };
                processCoord(coords);
            });
            
            return { xmin, ymin, xmax, ymax };
        }
        
        // Update preview for GeoJSON
        function updatePreview2(geojson) {
            const jsonString = JSON.stringify(geojson, null, 2);
            const preview = jsonString.length > 500 
                ? jsonString.substring(0, 500) + '...' 
                : jsonString;
            
            resultPreview2.textContent = preview;
            resultPreview2.style.display = 'block';
        }
        
        // Download Shapefile function
        function downloadShapefile() {
            if (!shapefileZip) return;
            
            // Create a URL for the blob
            const url = URL.createObjectURL(shapefileZip);
            
            // Create a download link
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName2}_shapefile.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage2('‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Shapefile ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!', 'success');
        }
        
        // UI Helper functions for GeoJSON to Shapefile
        function resetUI2() {
            errorMessage2.style.display = 'none';
            successMessage2.style.display = 'none';
            resultPreview2.style.display = 'none';
            resultContainer2.classList.add('hidden');
            projectionInfo.classList.add('hidden');
        }
        
        function showLoading2() {
            loadingSpinner2.classList.remove('hidden');
        }
        
        function hideLoading2() {
            loadingSpinner2.classList.add('hidden');
        }
        
        function showSuccess2() {
            resultContainer2.classList.remove('hidden');
            showMessage2('‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!', 'success');
        }
        
        function showError2(message) {
            errorMessage2.textContent = message;
            errorMessage2.style.display = 'block';
            successMessage2.style.display = 'none';
        }
        
        function showMessage2(message, type) {
            if (type === 'error') {
                errorMessage2.textContent = message;
                errorMessage2.style.display = 'block';
                successMessage2.style.display = 'none';
            } else {
                successMessage2.textContent = message;
                successMessage2.style.display = 'block';
                errorMessage2.style.display = 'none';
            }
        }
    </script>
    <script data-goatcounter="https://mponline.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>
</html>