<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONVERT GIS FILE - MAPRAW</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shpjs/3.6.3/shp.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
    /* Import Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Prompt:wght@300;400;500;600;700&display=swap');

    :root {
        --primary-gradient: linear-gradient(135deg, #1e88e5 0%, #1565c0 50%, #0d47a1 100%);
        --primary-solid: #1565c0;
        --primary-dark: #0d47a1;
        --primary-light: #e3f2fd;
        --text-white: #ffffff;
        --text-yellow: #ffeb3b;
        --bg-glass: rgba(255, 255, 255, 0.1);
        --bg-glass-hover: rgba(255, 255, 255, 0.25);
        --header-height: 70px;
    }
    
    body {
        margin: 0;
        padding-top: var(--header-height);
        font-family: 'Prompt', sans-serif;
        background: linear-gradient(180deg, #f0f7ff 0%, #ffffff 100%);
        color: #333;
        min-height: 100vh;
    }

    /* Container */
    .container {
        max-width: 900px;
        margin: 0 auto;
        padding: 20px;
        padding-top: 30px;
    }

    h1 {
        text-align: center;
        color: #2563eb;
        margin-bottom: 30px;
        font-size: 2rem;
        font-weight: 700;
    }

    h2 {
        color: #1e40af;
        font-size: 1.5rem;
        margin-bottom: 20px;
        font-weight: 600;
    }

    /* Header Structure */
    .mapraw-header {
        background: var(--primary-gradient);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1000;
        font-family: 'Prompt', sans-serif;
        height: var(--header-height);
    }
    
    .mapraw-header-content {
        max-width: 100%;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        height: 100%;
    }
    
    /* Logo Section */
    .mapraw-logo-section {
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex-shrink: 0;
        padding-right: 15px;
    }
    
    .mapraw-logo-main {
        color: var(--text-white);
        font-size: 1.2rem;
        font-weight: 700;
        margin: 0;
        line-height: 1;
        white-space: nowrap;
    }
    
    .mapraw-logo-main span {
        color: var(--text-yellow);
        text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
    }
    
    .mapraw-page-title {
        color: #e3f2fd;
        font-size: 1rem;
        font-weight: 400;
        margin: 2px 0 0 0;
        white-space: nowrap;
    }
    
    /* Navigation Section */
    .mapraw-nav {
        display: flex;
        gap: 8px;
        align-items: center;
        height: 100%;
    }
    
    .mapraw-nav-item {
        position: relative;
        height: 100%;
        display: flex;
        align-items: center;
    }
    
    /* Buttons */
    .mapraw-nav-btn {
        background: var(--bg-glass);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 6px;
        font-family: 'Prompt', sans-serif;
        white-space: nowrap;
    }
    
    .mapraw-nav-btn:hover {
        background: var(--bg-glass-hover);
        transform: translateY(-1px);
    }
    
    .mapraw-nav-btn.home-btn {
        background: rgba(255, 235, 59, 0.15);
        border-color: #ffeb3b;
        color: #ffeb3b;
    }
    
    .mapraw-nav-btn.home-btn:hover {
        background: #ffeb3b;
        color: #1565c0;
    }

    /* Dropdown */
    .mapraw-dropdown {
        position: absolute;
        top: calc(100% - 10px);
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: white;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        min-width: 200px;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
        padding: 5px 0;
        z-index: 1001;
    }
    
    /* Hover Logic for Desktop */
    @media (min-width: 1201px) {
        .mapraw-nav-item:hover .mapraw-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
    }
    
    .mapraw-dropdown-item {
        display: block;
        padding: 10px 20px;
        color: #333;
        text-decoration: none;
        font-size: 0.9rem;
        transition: background 0.2s;
        white-space: nowrap;
    }
    
    .mapraw-dropdown-item:hover {
        background: #f1f8ff;
        color: #1565c0;
    }

    /* Hamburger Menu Toggle */
    .mobile-menu-toggle {
        display: none;
        background: none;
        border: none;
        cursor: pointer;
        padding: 10px;
        z-index: 1002;
    }
    
    .bar {
        display: block;
        width: 25px;
        height: 3px;
        margin: 5px auto;
        background-color: white;
        transition: all 0.3s ease-in-out;
        border-radius: 2px;
    }

    /* ==== Responsive Styles ==== */
    
    @media (max-width: 1400px) {
        .mapraw-nav-btn {
            padding: 6px 8px;
            font-size: 0.8rem;
        }
        .mapraw-nav {
            gap: 4px;
        }
    }

    @media (max-width: 1200px) {
        .mobile-menu-toggle {
            display: block;
        }

        .mapraw-nav {
            position: fixed;
            top: var(--header-height);
            right: -100%;
            width: 280px;
            height: calc(100vh - var(--header-height));
            background: white;
            flex-direction: column;
            align-items: stretch;
            gap: 0;
            padding: 10px 0;
            transition: right 0.3s ease;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .mapraw-nav.active {
            right: 0;
        }

        .mapraw-nav-item {
            height: auto;
            flex-direction: column;
            width: 100%;
            display: block;
            border-bottom: 1px solid #eee;
        }

        .mapraw-nav-btn {
            background: white;
            color: #333;
            border: none;
            border-radius: 0;
            padding: 15px 20px;
            font-size: 1rem;
            justify-content: space-between;
            width: 100%;
            box-sizing: border-box;
        }

        .mapraw-nav-btn:hover {
            background: #f8f9fa;
            transform: none;
        }

        .mapraw-nav-btn.home-btn {
            background: #1565c0;
            color: white;
        }

        .mapraw-nav-btn.home-btn:hover {
            background: #0d47a1;
        }

        .mapraw-dropdown {
            position: static;
            opacity: 1;
            visibility: visible;
            transform: none;
            box-shadow: none;
            border-radius: 0;
            padding: 0;
            background: #f8f9fa;
            display: none;
        }

        .mapraw-nav-item.active .mapraw-dropdown {
            display: block;
        }

        .mapraw-dropdown-item {
            padding: 12px 20px 12px 40px;
            font-size: 0.9rem;
        }

        .mobile-menu-toggle.active .bar:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }

        .mobile-menu-toggle.active .bar:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-toggle.active .bar:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
    }

    @media (max-width: 768px) {
        .mapraw-logo-main {
            font-size: 1rem;
        }
        
        .mapraw-page-title {
            font-size: 0.8rem;
        }

        .mapraw-header-content {
            padding: 0 15px;
        }
    }

    /* Main Container */
    .main-container {
        padding: 2rem;
        margin: 0 auto;
        max-width: 900px;
    }

    .card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(30, 136, 229, 0.1);
        padding: 2rem;
        margin-bottom: 2rem;
        border-top: 4px solid var(--primary-solid);
    }

    .title-container {
        text-align: center;
        margin-bottom: 2rem;
    }

    .main-title {
        color: var(--primary-dark);
        font-size: 1.8rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
    }

    .subtitle {
        color: #546e7a;
        font-size: 1rem;
    }

    /* Tabs */
    .tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 25px;
        justify-content: center;
        flex-wrap: wrap;
        background-color: #f8f9fa;
        padding: 10px;
        border-radius: 10px;
    }

    .tab {
        padding: 12px 30px;
        cursor: pointer;
        background-color: white;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        font-weight: 600;
        transition: all 0.3s;
        color: #666;
        font-size: 1rem;
    }

    .tab.active {
        background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
        color: white;
        border-color: transparent;
        box-shadow: 0 4px 10px rgba(37, 99, 235, 0.3);
    }

    .tab-content {
        display: none;
        background-color: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        margin-bottom: 30px;
    }

    .tab-content.active {
        display: block;
        animation: fadeIn 0.4s ease-out;
    }

    @keyframes fadeIn {
        from {
            opacity: 0;
            transform: translateY(10px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Upload Area */
    .upload-area {
        border: 2px dashed #ccc;
        border-radius: 12px;
        padding: 40px 20px;
        text-align: center;
        background-color: #f8f9fa;
        margin-bottom: 25px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .upload-area:hover {
        border-color: #2563eb;
        background-color: #f0f4ff;
    }

    .upload-icon {
        font-size: 48px;
        margin-bottom: 15px;
    }

    .upload-area p {
        color: #666;
        margin: 0;
        font-size: 1rem;
    }

    /* Projection Options */
    .projection-options {
        margin-bottom: 25px;
    }

    .projection-title {
        font-weight: 600;
        margin-bottom: 12px;
        color: #333;
        font-size: 1.05rem;
    }

    .radio-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }

    .radio-option {
        display: flex;
        align-items: center;
        padding: 12px 15px;
        background-color: #f8f9fa;
        border: 2px solid #e0e0e0;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .radio-option:hover {
        border-color: #2563eb;
        background-color: #f0f4ff;
    }

    .radio-option input[type="radio"] {
        margin-right: 10px;
        cursor: pointer;
        width: 18px;
        height: 18px;
    }

    .radio-option input[type="radio"]:checked + span {
        color: #2563eb;
        font-weight: 600;
    }

    .radio-option span {
        flex: 1;
        color: #666;
        font-size: 0.95rem;
    }

    /* Buttons */
    .btn {
        padding: 12px 30px;
        background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 2px 8px rgba(37, 99, 235, 0.3);
        font-family: 'Prompt', sans-serif;
        font-size: 1rem;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
    }

    .btn:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    /* Messages */
    .error-message,
    .success-message {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
        font-size: 0.95rem;
        font-weight: 500;
    }

    .error-message {
        background-color: #fee;
        color: #c00;
        border-left: 4px solid #c00;
    }

    .success-message {
        background-color: #efe;
        color: #060;
        border-left: 4px solid #060;
    }

    .info-box {
        background: #e3f2fd;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        border-left: 4px solid #2563eb;
    }

    .info-box p {
        margin: 5px 0;
        color: #1e40af;
        font-weight: 500;
        font-size: 0.95rem;
    }

    .detected-projection {
        font-weight: 700;
        color: #2563eb;
    }

    /* Result Area */
    .result-area {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        border: 1px solid #dee2e6;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-size: 0.85rem;
        max-height: 300px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        display: none;
        margin-top: 20px;
    }

    /* Spinner */
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #2563eb;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .hidden {
        display: none !important;
    }

    /* Navigation Buttons */
    .navigation-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 30px;
        flex-wrap: wrap;
    }

    .nav-btn {
        padding: 12px 25px;
        border-radius: 8px;
        text-decoration: none;
        font-weight: 600;
        transition: all 0.3s;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        border: 2px solid #2563eb;
        color: #2563eb;
        background: white;
    }

    .nav-btn:hover {
        background: #f0f4ff;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(37, 99, 235, 0.2);
    }

    .nav-btn.home-btn {
        background: white;
        color: #666;
        border-color: #ccc;
    }

    .nav-btn.home-btn:hover {
        background: #f8f9fa;
        color: #333;
        border-color: #999;
    }

    .nav-btn.area-btn {
        background: #2563eb;
        color: white;
        border-color: #2563eb;
    }

    .nav-btn.area-btn:hover {
        background: #1e40af;
        border-color: #1e40af;
        color: white;
    }

    @media (max-width: 768px) {
        .container {
            padding: 15px;
        }

        h1 {
            font-size: 1.5rem;
        }

        h2 {
            font-size: 1.2rem;
        }

        .tabs {
            gap: 8px;
            padding: 8px;
        }

        .tab {
            padding: 10px 15px;
            font-size: 0.9rem;
        }

        .tab-content {
            padding: 20px;
        }

        .radio-group {
            gap: 8px;
        }

        .radio-option {
            padding: 10px;
        }

        .navigation-buttons {
            flex-direction: column;
        }

        .nav-btn {
            width: 100%;
            justify-content: center;
        }

        .mapraw-logo-main {
            font-size: 1rem;
        }
        
        .mapraw-page-title {
            font-size: 0.8rem;
        }

        .mapraw-header-content {
            padding: 0 15px;
        }
    }

    @media (max-width: 768px) {
        .main-container {
            padding: 1rem;
        }

        .card {
            padding: 1.5rem;
        }

        .main-title {
            font-size: 1.5rem;
        }

        .subtitle {
            font-size: 0.9rem;
        }

        .tabs {
            gap: 8px;
        }

        .tab {
            padding: 8px 15px;
            font-size: 0.85rem;
        }

        .radio-group {
            flex-direction: column;
            gap: 10px;
        }

        .navigation-buttons {
            flex-direction: column;
        }

        .nav-btn {
            width: 100%;
            justify-content: center;
        }
    }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="mapraw-header">
        <div class="mapraw-header-content">
            <div class="mapraw-logo-section">
                <h1 class="mapraw-logo-main">TOOL FROM <span>MAPRAW</span></h1>
                <p class="mapraw-page-title">Calculate AREA</p>
            </div>
            
            <button class="mobile-menu-toggle" id="mobileMenuBtn">
                <span class="bar"></span>
                <span class="bar"></span>
                <span class="bar"></span>
            </button>

            <nav class="mapraw-nav" id="mainNav">
                <div class="mapraw-nav-item">
                    <a href="index.html" class="mapraw-nav-btn home-btn">
                        <span>ğŸ  à¸«à¸™à¹‰à¸²à¸«à¸¥à¸±à¸</span>
                    </a>
                </div>
                
                <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                    <div class="mapraw-nav-btn">
                        <span>ğŸ“‹ à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­à¸ªà¸³à¸£à¸§à¸ˆ</span>
                        <span style="font-size: 0.8em">â–¼</span>
                    </div>
                    <div class="mapraw-dropdown">
                        <a href="page1.html" class="mapraw-dropdown-item">NoteMAP</a>
                        <a href="#" class="mapraw-dropdown-item">SURVEY WORK</a>
                    </div>
                </div>
                
                <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                    <div class="mapraw-nav-btn">
                        <span>ğŸ”§ à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­à¹€à¸•à¸£à¸µà¸¢à¸¡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥</span>
                        <span style="font-size: 0.8em">â–¼</span>
                    </div>
                    <div class="mapraw-dropdown">
                        <a href="page2.html" class="mapraw-dropdown-item">Reclass BLDG</a>
                        <a href="page5.html" class="mapraw-dropdown-item">Prepare PLLU</a>
                        <a href="page8.html" class="mapraw-dropdown-item">SHAPEFILE TO EXCEL</a>
                        <a href="page10.html" class="mapraw-dropdown-item">CAPTURE MAP</a>
                        <a href="page13.html" class="mapraw-dropdown-item">Perpendicular Line</a>
                    </div>
                </div>
                
                <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                    <div class="mapraw-nav-btn">
                        <span>âš™ï¸ à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­à¸›à¸£à¸°à¸¡à¸§à¸¥à¸œà¸¥</span>
                        <span style="font-size: 0.8em">â–¼</span>
                    </div>
                    <div class="mapraw-dropdown">
                        <a href="page3.html" class="mapraw-dropdown-item">Calculate Landuse</a>
                        <a href="page6.html" class="mapraw-dropdown-item">Calculate Population</a>
                        <a href="page11.html" class="mapraw-dropdown-item">Calculate AREA</a>
                        <a href="page14.html" class="mapraw-dropdown-item">RECLASS FACTORY</a>
                        <a href="page12.html" class="mapraw-dropdown-item">COMPARISON LANDUSE</a>
                    </div>
                </div>
                
                <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                    <div class="mapraw-nav-btn">
                        <span>âš–ï¸ à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­à¸à¸à¸«à¸¡à¸²à¸¢</span>
                        <span style="font-size: 0.8em">â–¼</span>
                    </div>
                    <div class="mapraw-dropdown">
                        <a href="page4.html" class="mapraw-dropdown-item">Town Planning Laws</a>
                        <a href="page15.html" class="mapraw-dropdown-item">Building Laws</a>
                    </div>
                </div>
                
                <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                    <div class="mapraw-nav-btn">
                        <span>ğŸ§® à¸„à¸³à¸™à¸§à¸“à¹€à¸šà¸·à¹‰à¸­à¸‡à¸•à¹‰à¸™</span>
                        <span style="font-size: 0.8em">â–¼</span>
                    </div>
                    <div class="mapraw-dropdown">
                        <a href="page7.html" class="mapraw-dropdown-item">AREA Calculator</a>
                    </div>
                </div>
                
                <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                    <div class="mapraw-nav-btn">
                        <span>ğŸ¯ à¹€à¸„à¸£à¸·à¹ˆà¸­à¸‡à¸¡à¸·à¸­à¸­à¸·à¹ˆà¸™à¹†</span>
                        <span style="font-size: 0.8em">â–¼</span>
                    </div>
                    <div class="mapraw-dropdown">
                        <a href="page9.html" class="mapraw-dropdown-item">CREATE QRCODE</a>
                    </div>
                </div>
            </nav>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <h1>CONVERT GIS FILE</h1>
        
        <div class="tabs">
            <div class="tab active" data-tab="tab1">Shapefile â†’ GeoJSON</div>
            <div class="tab" data-tab="tab2">GeoJSON â†’ Shapefile</div>
        </div>
        
        <!-- Tab 1: Shapefile to GeoJSON -->
        <div class="tab-content active" id="tab1">
            <h2>Shapefile to GeoJSON Converter</h2>
            
            <div class="error-message" id="errorMessage1"></div>
            <div class="success-message" id="successMessage1"></div>
            
            <div class="upload-area" id="uploadArea1">
                <div class="upload-icon">ğŸ“</div>
                <p>à¸„à¸¥à¸´à¸à¸—à¸µà¹ˆà¸™à¸µà¹ˆà¸«à¸£à¸·à¸­à¸¥à¸²à¸à¹„à¸Ÿà¸¥à¹Œ ZIP à¸—à¸µà¹ˆà¸¡à¸µ Shapefile (.shp, .dbf, etc.) à¸¡à¸²à¸§à¸²à¸‡</p>
                <input type="file" id="fileInput1" accept=".zip" style="display: none;">
            </div>
            
            <div class="projection-options">
                <div class="projection-title">à¹€à¸¥à¸·à¸­à¸à¸à¸·à¹‰à¸™à¸«à¸¥à¸±à¸à¸à¸²à¸™ (à¸£à¸°à¸šà¸šà¸à¸´à¸à¸±à¸”):</div>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="original" checked>
                        <span>à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ EPSG:4326 (WGS84 - à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸ªà¸³à¸«à¸£à¸±à¸š GeoJSON)</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="EPSG:32647">
                        <span>à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ EPSG:32647 (UTM Zone 47N)</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="EPSG:32648">
                        <span>à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ EPSG:32648 (UTM Zone 48N)</span>
                    </label>
                </div>
            </div>
            
            <div id="loadingSpinner1" class="hidden" style="text-align: center;">
                <div class="spinner"></div>
                <p>à¸à¸³à¸¥à¸±à¸‡à¹à¸›à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œ Shapefile...</p>
            </div>
            
            <div id="resultContainer1" class="hidden" style="text-align: center;">
                <p>à¸à¸²à¸£à¹à¸›à¸¥à¸‡à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ!</p>
                <button id="downloadBtn1" class="btn">à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸” GeoJSON</button>
            </div>
            
            <pre id="resultPreview1" class="result-area"></pre>
        </div>
        
        <!-- Tab 2: GeoJSON to Shapefile -->
        <div class="tab-content" id="tab2">
            <h2>GeoJSON to Shapefile Converter</h2>
            
            <div class="error-message" id="errorMessage2"></div>
            <div class="success-message" id="successMessage2"></div>
            
            <div id="projectionInfo" class="info-box hidden">
                <p>à¸•à¸£à¸§à¸ˆà¸à¸šà¸à¸·à¹‰à¸™à¸«à¸¥à¸±à¸à¸à¸²à¸™: <span id="detectedProjection" class="detected-projection">EPSG:4326 (WGS84)</span></p>
                <p>à¸ˆà¸°à¸—à¸³à¸à¸²à¸£à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ Shapefile à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰à¸à¸·à¹‰à¸™à¸«à¸¥à¸±à¸à¸à¸²à¸™à¹€à¸”à¸´à¸¡à¸•à¸²à¸¡à¸—à¸µà¹ˆà¸•à¸£à¸§à¸ˆà¸à¸š</p>
            </div>
            
            <div class="upload-area" id="uploadArea2">
                <div class="upload-icon">ğŸ“Š</div>
                <p>à¸„à¸¥à¸´à¸à¸—à¸µà¹ˆà¸™à¸µà¹ˆà¸«à¸£à¸·à¸­à¸¥à¸²à¸à¹„à¸Ÿà¸¥à¹Œ GeoJSON (.geojson, .json) à¸¡à¸²à¸§à¸²à¸‡</p>
                <input type="file" id="fileInput2" accept=".geojson,.json" style="display: none;">
            </div>
            
            <div id="loadingSpinner2" class="hidden" style="text-align: center;">
                <div class="spinner"></div>
                <p>à¸à¸³à¸¥à¸±à¸‡à¹à¸›à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œ GeoJSON...</p>
            </div>
            
            <div id="resultContainer2" class="hidden" style="text-align: center;">
                <p>à¸à¸²à¸£à¹à¸›à¸¥à¸‡à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ!</p>
                <button id="downloadBtn2" class="btn">à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸” Shapefile (ZIP)</button>
            </div>
            
            <pre id="resultPreview2" class="result-area"></pre>
        </div>
        
        <!-- Navigation Buttons -->
        <div class="navigation-buttons">
            <a href="https://mponline1.github.io/" class="nav-btn home-btn">
                <i></i> à¸«à¸™à¹‰à¸²à¸«à¸¥à¸±à¸
            </a>
            <a href="https://mponline1.github.io/page11.html" class="nav-btn area-btn">
                <i></i> Calculate AREA
            </a>
        </div>
    </div>

    <script>
        // Tab switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });

        // Projection definitions
        const projDefinitions = {
            'EPSG:4326': '+proj=longlat +datum=WGS84 +no_defs',
            'EPSG:32647': '+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs',
            'EPSG:32648': '+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs'
        };
        
        for (const [code, def] of Object.entries(projDefinitions)) {
            proj4.defs(code, def);
        }

        // ============================================
        // PART 1: Shapefile to GeoJSON
        // ============================================
        const uploadArea1 = document.getElementById('uploadArea1');
        const fileInput1 = document.getElementById('fileInput1');
        const loadingSpinner1 = document.getElementById('loadingSpinner1');
        const resultContainer1 = document.getElementById('resultContainer1');
        const downloadBtn1 = document.getElementById('downloadBtn1');
        const resultPreview1 = document.getElementById('resultPreview1');
        const errorMessage1 = document.getElementById('errorMessage1');
        const successMessage1 = document.getElementById('successMessage1');
        const projectionOptions1 = document.getElementsByName('projection1');

        let originalGeoJSON = null;
        let convertedGeoJSON = null;
        let fileName1 = 'converted';

        uploadArea1.addEventListener('click', () => fileInput1.click());
        
        uploadArea1.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#1565c0';
        });
        
        uploadArea1.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#bbdefb';
        });
        
        uploadArea1.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#bbdefb';
            if (e.dataTransfer.files.length > 0) {
                handleShapefileUpload(e.dataTransfer.files[0]);
            }
        });

        fileInput1.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleShapefileUpload(e.target.files[0]);
            }
        });

        downloadBtn1.addEventListener('click', downloadGeoJSON);

        // Add event listeners for projection change
        projectionOptions1.forEach(option => {
            option.addEventListener('change', () => {
                if (originalGeoJSON) {
                    const selectedProjection = [...projectionOptions1].find(r => r.checked).value;
                    
                    if (selectedProjection === 'original') {
                        convertedGeoJSON = originalGeoJSON;
                        updatePreview1(convertedGeoJSON);
                        showMessage1('à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ EPSG:4326 (WGS84) à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§', 'success');
                    } else {
                        try {
                            convertedGeoJSON = transformGeoJSON(originalGeoJSON, selectedProjection);
                            updatePreview1(convertedGeoJSON);
                            showMessage1(`à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ ${selectedProjection} à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§`, 'success');
                        } catch (error) {
                            showError1(`à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¹à¸›à¸¥à¸‡à¸à¸·à¹‰à¸™à¸«à¸¥à¸±à¸à¸à¸²à¸™: ${error.message}`);
                        }
                    }
                }
            });
        });

        function handleShapefileUpload(file) {
            if (!file.name.endsWith('.zip')) {
                showError1('à¸à¸£à¸¸à¸“à¸²à¸­à¸±à¸›à¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ ZIP à¸—à¸µà¹ˆà¸¡à¸µ Shapefile');
                return;
            }
            
            fileName1 = file.name.replace('.zip', '');
            resetUI1();
            showLoading1();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    await processShapefileZip(e.target.result);
                } catch (error) {
                    showError1(error.message);
                    hideLoading1();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async function processShapefileZip(zipData) {
            try {
                const geojson = await shp(zipData);
                originalGeoJSON = geojson;
                
                const selectedProjection = [...projectionOptions1].find(r => r.checked).value;
                
                if (selectedProjection !== 'original') {
                    convertedGeoJSON = transformGeoJSON(originalGeoJSON, selectedProjection);
                } else {
                    convertedGeoJSON = originalGeoJSON;
                }
                
                updatePreview1(convertedGeoJSON);
                hideLoading1();
                showSuccess1();
                
            } catch (error) {
                throw new Error(`à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸­à¹ˆà¸²à¸™à¹„à¸Ÿà¸¥à¹Œ Shapefile à¹„à¸”à¹‰: ${error.message}`);
            }
        }

        function transformGeoJSON(geojson, targetCRS) {
            const transformed = JSON.parse(JSON.stringify(geojson));
            
            const transformCoordinates = (coords) => {
                if (typeof coords[0] === 'number') {
                    // Point
                    return proj4('EPSG:4326', targetCRS, coords);
                }
                
                if (Array.isArray(coords[0]) && typeof coords[0][0] === 'number') {
                    // LineString or list of Points
                    return coords.map(coord => proj4('EPSG:4326', targetCRS, coord));
                }
                
                if (Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                    // Polygon or MultiLineString
                    return coords.map(ring => transformCoordinates(ring));
                }
                
                return coords;
            };
            
            if (transformed.type === 'FeatureCollection') {
                transformed.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (transformed.type === 'Feature') {
                if (transformed.geometry && transformed.geometry.coordinates) {
                    transformed.geometry.coordinates = transformCoordinates(transformed.geometry.coordinates);
                }
            }
            
            transformed.crs = {
                type: 'name',
                properties: {
                    name: targetCRS
                }
            };
            
            return transformed;
        }

        function updatePreview1(geojson) {
            const jsonString = JSON.stringify(geojson, null, 2);
            const preview = jsonString.length > 500 
                ? jsonString.substring(0, 500) + '...' 
                : jsonString;
            
            resultPreview1.textContent = preview;
            resultPreview1.style.display = 'block';
        }

        function downloadGeoJSON() {
            if (!convertedGeoJSON) return;
            
            const blob = new Blob([JSON.stringify(convertedGeoJSON, null, 2)], {
                type: 'application/json'
            });
            saveAs(blob, `${fileName1}.geojson`);
            showMessage1('à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ GeoJSON à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§!', 'success');
        }

        function resetUI1() {
            errorMessage1.style.display = 'none';
            successMessage1.style.display = 'none';
            resultPreview1.style.display = 'none';
            resultContainer1.classList.add('hidden');
        }

        function showLoading1() {
            loadingSpinner1.classList.remove('hidden');
        }

        function hideLoading1() {
            loadingSpinner1.classList.add('hidden');
        }

        function showSuccess1() {
            resultContainer1.classList.remove('hidden');
            showMessage1('à¹à¸›à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œà¸ªà¸³à¹€à¸£à¹‡à¸ˆ!', 'success');
        }

        function showError1(message) {
            errorMessage1.textContent = message;
            errorMessage1.style.display = 'block';
            successMessage1.style.display = 'none';
        }

        function showMessage1(message, type) {
            if (type === 'error') {
                errorMessage1.textContent = message;
                errorMessage1.style.display = 'block';
                successMessage1.style.display = 'none';
            } else {
                successMessage1.textContent = message;
                successMessage1.style.display = 'block';
                errorMessage1.style.display = 'none';
            }
        }

        // ============================================
        // PART 2: GeoJSON to Shapefile
        // ============================================
        const uploadArea2 = document.getElementById('uploadArea2');
        const fileInput2 = document.getElementById('fileInput2');
        const loadingSpinner2 = document.getElementById('loadingSpinner2');
        const resultContainer2 = document.getElementById('resultContainer2');
        const downloadBtn2 = document.getElementById('downloadBtn2');
        const resultPreview2 = document.getElementById('resultPreview2');
        const errorMessage2 = document.getElementById('errorMessage2');
        const successMessage2 = document.getElementById('successMessage2');
        const projectionInfo = document.getElementById('projectionInfo');
        const detectedProjectionSpan = document.getElementById('detectedProjection');

        let shapefileZip = null;
        let fileName2 = 'converted';
        let detectedCRS = 'EPSG:4326';

        uploadArea2.addEventListener('click', () => fileInput2.click());
        
        uploadArea2.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#1565c0';
        });
        
        uploadArea2.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#bbdefb';
        });
        
        uploadArea2.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#bbdefb';
            if (e.dataTransfer.files.length > 0) {
                handleGeoJSONUpload(e.dataTransfer.files[0]);
            }
        });

        fileInput2.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleGeoJSONUpload(e.target.files[0]);
            }
        });

        downloadBtn2.addEventListener('click', downloadShapefile);

        function handleGeoJSONUpload(file) {
            if (!file.name.match(/\.(json|geojson)$/i)) {
                showError2('à¸à¸£à¸¸à¸“à¸²à¸­à¸±à¸›à¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ GeoJSON (.json à¸«à¸£à¸·à¸­ .geojson)');
                return;
            }
            
            fileName2 = file.name.replace(/\.[^/.]+$/, "");
            resetUI2();
            showLoading2();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const geojsonText = e.target.result;
                    const geoJSON = JSON.parse(geojsonText);
                    
                    // Detect CRS
                    detectedCRS = detectCRS(geoJSON);
                    detectedProjectionSpan.textContent = detectedCRS;
                    projectionInfo.classList.remove('hidden');
                    
                    // Create Shapefile
                    const success = await createShapefile(geoJSON);
                    
                    if (success) {
                        updatePreview2(geoJSON);
                        hideLoading2();
                        showSuccess2();
                    } else {
                        throw new Error('à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸ªà¸£à¹‰à¸²à¸‡à¹„à¸Ÿà¸¥à¹Œ Shapefile à¹„à¸”à¹‰');
                    }
                    
                } catch (error) {
                    showError2(`à¸£à¸¹à¸›à¹à¸šà¸šà¹„à¸Ÿà¸¥à¹Œ GeoJSON à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡: ${error.message}`);
                    hideLoading2();
                }
            };
            reader.readAsText(file);
        }

        function detectCRS(geoJSON) {
            // Check CRS in GeoJSON
            if (geoJSON.crs && geoJSON.crs.properties && geoJSON.crs.properties.name) {
                const crsName = geoJSON.crs.properties.name;
                if (crsName.includes('4326')) return 'EPSG:4326';
                if (crsName.includes('32647')) return 'EPSG:32647';
                if (crsName.includes('32648')) return 'EPSG:32648';
            }
            
            // Check coordinate values to guess CRS
            let sampleCoord = null;
            
            if (geoJSON.type === 'FeatureCollection' && geoJSON.features.length > 0) {
                const firstFeature = geoJSON.features[0];
                if (firstFeature.geometry && firstFeature.geometry.coordinates) {
                    sampleCoord = firstFeature.geometry.coordinates;
                }
            } else if (geoJSON.type === 'Feature' && geoJSON.geometry) {
                sampleCoord = geoJSON.geometry.coordinates;
            }
            
            if (sampleCoord) {
                const flatCoord = flattenCoordinates(sampleCoord);
                if (flatCoord.length >= 2) {
                    const [x, y] = flatCoord;
                    
                    // Check if it's lat/lon (WGS84)
                    if (Math.abs(x) <= 180 && Math.abs(y) <= 90) {
                        return 'EPSG:4326';
                    }
                    
                    // Check if it's UTM Zone 47N (Thailand West)
                    if (x >= 166000 && x <= 834000 && y >= 0 && y <= 10000000) {
                        return 'EPSG:32647';
                    }
                    
                    // Check if it's UTM Zone 48N (Thailand East)
                    if (x >= 166000 && x <= 834000 && y >= 0 && y <= 10000000) {
                        return 'EPSG:32648';
                    }
                }
            }
            
            // Default to WGS84
            return 'EPSG:4326';
        }

        function flattenCoordinates(coords) {
            if (typeof coords[0] === 'number') {
                return coords;
            }
            return flattenCoordinates(coords[0]);
        }

        async function createShapefile(geoJSON) {
            try {
                const zip = new JSZip();
                
                // Separate features by geometry type
                const points = [];
                const lines = [];
                const polygons = [];
                
                const features = geoJSON.type === 'FeatureCollection' 
                    ? geoJSON.features 
                    : [geoJSON];
                
                features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    const geomType = feature.geometry.type;
                    
                    // Normalize geometry type
                    if (geomType === 'Point' || geomType === 'MultiPoint') {
                        points.push(feature);
                    } else if (geomType === 'LineString' || geomType === 'MultiLineString') {
                        lines.push(feature);
                    } else if (geomType === 'Polygon' || geomType === 'MultiPolygon') {
                        polygons.push(feature);
                    } else {
                        console.warn(`Unknown geometry type: ${geomType}`, feature);
                    }
                });
                
                let filesAdded = false;
                
                // Create .prj file content
                let prjContent = '';
                
                if (detectedCRS === 'EPSG:4326' || detectedCRS.includes('4326')) {
                    prjContent = 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]';
                } else if (detectedCRS === 'EPSG:32647' || detectedCRS.includes('32647')) {
                    prjContent = 'PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",99],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
                } else if (detectedCRS === 'EPSG:32648' || detectedCRS.includes('32648')) {
                    prjContent = 'PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",105],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
                }
                
                // Create separate shapefiles for each geometry type
                if (points.length > 0) {
                    const pointGeoJSON = {
                        type: 'FeatureCollection',
                        features: points,
                        crs: geoJSON.crs
                    };
                    console.log(`Creating Point shapefile: ${points.length} features`);
                    await createShapefileForFeatureType(pointGeoJSON, 'point', zip, prjContent);
                    filesAdded = true;
                }
                
                if (lines.length > 0) {
                    const lineGeoJSON = {
                        type: 'FeatureCollection',
                        features: lines,
                        crs: geoJSON.crs
                    };
                    console.log(`Creating Line shapefile: ${lines.length} features`);
                    await createShapefileForFeatureType(lineGeoJSON, 'line', zip, prjContent);
                    filesAdded = true;
                }
                
                if (polygons.length > 0) {
                    const polygonGeoJSON = {
                        type: 'FeatureCollection',
                        features: polygons,
                        crs: geoJSON.crs
                    };
                    console.log(`Creating Polygon shapefile: ${polygons.length} features`);
                    await createShapefileForFeatureType(polygonGeoJSON, 'polygon', zip, prjContent);
                    filesAdded = true;
                }
                
                if (!filesAdded) {
                    throw new Error('à¹„à¸¡à¹ˆà¸à¸šà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ Feature à¹ƒà¸™ GeoJSON');
                }
                
                // Add README
                zip.file('README.txt', `â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  Shapefile à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸”à¸¢ MAPRAW GIS File Converter               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸—à¸±à¹ˆà¸§à¹„à¸›
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
à¸£à¸°à¸šà¸šà¸à¸´à¸à¸±à¸”: ${detectedCRS}
à¸§à¸±à¸™à¸—à¸µà¹ˆà¸ªà¸£à¹‰à¸²à¸‡: ${new Date().toLocaleString('th-TH')}
Character Encoding: UTF-8 / TIS-620

ğŸ“ à¸£à¸²à¸¢à¸à¸²à¸£à¹„à¸Ÿà¸¥à¹Œà¹ƒà¸™à¹à¸•à¹ˆà¸¥à¸° Shapefile
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ“ .shp      = à¹„à¸Ÿà¸¥à¹Œà¹€à¸£à¸‚à¸²à¸„à¸“à¸´à¸• (geometry data)
âœ“ .shx      = à¹„à¸Ÿà¸¥à¹Œà¸”à¸±à¸Šà¸™à¸µ (spatial index)
âœ“ .dbf      = à¹„à¸Ÿà¸¥à¹Œà¸•à¸²à¸£à¸²à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (attribute table)
âœ“ .prj      = à¹„à¸Ÿà¸¥à¹Œà¸£à¸°à¸šà¸šà¸à¸´à¸à¸±à¸” (coordinate system)
âœ“ .cpg      = à¹„à¸Ÿà¸¥à¹Œà¸à¸³à¸«à¸™à¸” encoding (UTF-8)
âœ“ .xml      = à¹„à¸Ÿà¸¥à¹Œ metadata
âœ“ .geojson  = à¹„à¸Ÿà¸¥à¹Œ GeoJSON à¸•à¹‰à¸™à¸‰à¸šà¸±à¸šà¸ªà¸³à¸«à¸£à¸±à¸šà¸­à¹‰à¸²à¸‡à¸­à¸´à¸‡
âœ“ _fields.txt = à¹„à¸Ÿà¸¥à¹Œà¸­à¸˜à¸´à¸šà¸²à¸¢ field names (à¸ªà¸³à¸«à¸£à¸±à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢)

ğŸŒ à¸à¸²à¸£à¸£à¸­à¸‡à¸£à¸±à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… à¸‚à¹‰à¸­à¸¡à¸¹à¸¥ attributes à¸£à¸­à¸‡à¸£à¸±à¸šà¸ à¸²à¸©à¸²à¹„à¸—à¸¢à¸”à¹‰à¸§à¸¢ TIS-620 encoding
âœ… à¸Šà¸·à¹ˆà¸­ field à¸ à¸²à¸©à¸²à¹„à¸—à¸¢à¸ˆà¸°à¸–à¸¹à¸à¹à¸›à¸¥à¸‡à¹€à¸›à¹‡à¸™ FIELD_1, FIELD_2, ...
âœ… à¸”à¸¹à¸„à¸§à¸²à¸¡à¸«à¸¡à¸²à¸¢à¸‚à¸­à¸‡ field names à¹„à¸”à¹‰à¸ˆà¸²à¸à¹„à¸Ÿà¸¥à¹Œ *_fields.txt

ğŸ“– à¸§à¸´à¸˜à¸µà¹ƒà¸Šà¹‰à¸‡à¸²à¸™
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
1. à¹à¸•à¸ ZIP file à¸­à¸­à¸à¸¡à¸²
2. à¹€à¸›à¸´à¸”à¹„à¸Ÿà¸¥à¹Œ .shp à¹ƒà¸™ GIS software (QGIS, ArcGIS, MapInfo, etc.)
3. à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š field mapping à¸ˆà¸²à¸à¹„à¸Ÿà¸¥à¹Œ *_fields.txt
4. à¸«à¸²à¸à¸ à¸²à¸©à¸²à¹„à¸—à¸¢à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡à¸œà¸¥ à¹ƒà¸«à¹‰à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² encoding à¹€à¸›à¹‡à¸™ TIS-620 à¸«à¸£à¸·à¸­ UTF-8

âš™ï¸ à¸à¸²à¸£à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² Encoding à¹ƒà¸™ GIS Software
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
QGIS:
  - Layer Properties â†’ Source â†’ Encoding â†’ à¹€à¸¥à¸·à¸­à¸ "TIS-620" à¸«à¸£à¸·à¸­ "UTF-8"
  
ArcGIS:
  - Layer Properties â†’ Fields â†’ Field Properties â†’ Encoding

ğŸ“Š Attribute Data Types
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
C = Character (à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡)
N = Numeric (à¸•à¸±à¸§à¹€à¸¥à¸‚à¸ˆà¸³à¸™à¸§à¸™à¹€à¸•à¹‡à¸¡)
F = Float (à¸•à¸±à¸§à¹€à¸¥à¸‚à¸—à¸¨à¸™à¸´à¸¢à¸¡)
L = Logical (True/False)
D = Date (à¸§à¸±à¸™à¸—à¸µà¹ˆ à¸£à¸¹à¸›à¹à¸šà¸š YYYYMMDD)

âš ï¸ à¸‚à¹‰à¸­à¸ˆà¸³à¸à¸±à¸”
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- à¸Šà¸·à¹ˆà¸­ field à¸ªà¸¹à¸‡à¸ªà¸¸à¸” 10 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£ (ASCII only)
- à¸„à¸§à¸²à¸¡à¸¢à¸²à¸§ field à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£à¸ªà¸¹à¸‡à¸ªà¸¸à¸” 254 characters
- à¸ˆà¸³à¸™à¸§à¸™ fields à¸ªà¸¹à¸‡à¸ªà¸¸à¸” 254 fields
- à¸ à¸²à¸©à¸²à¹„à¸—à¸¢ 1 à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£ = 3 bytes à¹ƒà¸™ UTF-8

ğŸ’¡ Tips
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
- à¹ƒà¸Šà¹‰à¹„à¸Ÿà¸¥à¹Œ .geojson à¸ªà¸³à¸«à¸£à¸±à¸šà¸­à¹‰à¸²à¸‡à¸­à¸´à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸•à¹‰à¸™à¸‰à¸šà¸±à¸š
- à¸”à¸¹à¹„à¸Ÿà¸¥à¹Œ *_fields.txt à¹€à¸à¸·à¹ˆà¸­à¹€à¸—à¸µà¸¢à¸šà¸Šà¸·à¹ˆà¸­ field
- à¸«à¸²à¸à¸ à¸²à¸©à¸²à¹„à¸—à¸¢à¹à¸ªà¸”à¸‡à¸œà¸¥à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡ à¸¥à¸­à¸‡à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™ encoding

ğŸ“ à¸à¸²à¸£à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
à¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸”à¸¢: MAPRAW GIS File Converter
à¹€à¸§à¹‡à¸šà¹„à¸‹à¸•à¹Œ: https://mponline1.github.io/
à¸£à¸­à¸‡à¸£à¸±à¸š: QGIS, ArcGIS, MapInfo, Global Mapper à¹à¸¥à¸° GIS software à¸­à¸·à¹ˆà¸™à¹†

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  à¸«à¸²à¸à¸à¸šà¸›à¸±à¸à¸«à¸²à¸à¸²à¸£à¹à¸ªà¸”à¸‡à¸œà¸¥à¸ à¸²à¸©à¸²à¹„à¸—à¸¢                                â•‘
â•‘  à¹‚à¸›à¸£à¸”à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸² encoding à¸‚à¸­à¸‡à¹‚à¸›à¸£à¹à¸à¸£à¸¡ GIS            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`);
                
                // Add original GeoJSON for reference
                zip.file(`${fileName2}_original.geojson`, JSON.stringify(geoJSON, null, 2));
                
                // Generate ZIP
                shapefileZip = await zip.generateAsync({type: 'blob'});
                
                return true;
                
            } catch (error) {
                console.error('Error creating shapefile:', error);
                throw new Error(`à¹€à¸à¸´à¸”à¸‚à¹‰à¸­à¸œà¸´à¸”à¸à¸¥à¸²à¸”à¹ƒà¸™à¸à¸²à¸£à¸ªà¸£à¹‰à¸²à¸‡à¹„à¸Ÿà¸¥à¹Œ Shapefile: ${error.message}`);
            }
        }

        async function createShapefileForFeatureType(geoJSON, type, zip, prjContent) {
            try {
                const typeSuffix = type === 'point' ? 'point' : (type === 'line' ? 'line' : 'poly');
                const baseName = `${fileName2}_${typeSuffix}`;
                
                // Get all features
                const features = geoJSON.features;
                if (!features || features.length === 0) {
                    return false;
                }
                
                // Calculate bounding box
                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                
                features.forEach(feature => {
                    if (!feature.geometry || !feature.geometry.coordinates) return;
                    
                    const coords = getAllCoordinates(feature.geometry.coordinates);
                    coords.forEach(([x, y]) => {
                        minX = Math.min(minX, x);
                        minY = Math.min(minY, y);
                        maxX = Math.max(maxX, x);
                        maxY = Math.max(maxY, y);
                    });
                });
                
                // Determine shape type based on actual geometry
                let shapeType;
                const firstFeature = features[0];
                const geomType = firstFeature.geometry.type;
                
                if (type === 'point') {
                    if (geomType === 'MultiPoint') {
                        shapeType = 8; // MultiPoint
                    } else {
                        shapeType = 1; // Point
                    }
                } else if (type === 'line') {
                    if (geomType === 'MultiLineString') {
                        shapeType = 3; // PolyLine (can handle multiple lines)
                    } else {
                        shapeType = 3; // PolyLine
                    }
                } else {
                    if (geomType === 'MultiPolygon') {
                        shapeType = 5; // Polygon (can handle multiple polygons)
                    } else {
                        shapeType = 5; // Polygon
                    }
                }
                
                // Create .shp file (Main File)
                const shpData = createShpFile(features, shapeType, minX, minY, maxX, maxY);
                zip.file(`${baseName}.shp`, shpData);
                
                // Create .shx file (Index File)
                const shxData = createShxFile(features, shapeType, minX, minY, maxX, maxY);
                zip.file(`${baseName}.shx`, shxData);
                
                // Create .dbf file (Attribute Table)
                const dbfData = createDbfFile(features);
                zip.file(`${baseName}.dbf`, dbfData);
                
                // Create .prj file (Projection)
                zip.file(`${baseName}.prj`, prjContent);
                
                // Create .cpg file (Character Encoding) - use UTF-8 for better Thai support
                zip.file(`${baseName}.cpg`, 'UTF-8');
                
                // Create field mapping file for Thai field names
                if (features.length > 0 && features[0].properties) {
                    const fieldMapping = createFieldMappingFile(features);
                    zip.file(`${baseName}_fields.txt`, fieldMapping);
                }
                
                // Create .xml file (Metadata)
                const xmlContent = createXmlMetadata(baseName, type, features.length, detectedCRS);
                zip.file(`${baseName}.xml`, xmlContent);
                
                // Create .geojson file for reference
                zip.file(`${baseName}.geojson`, JSON.stringify(geoJSON, null, 2));
                
                return true;
            } catch (error) {
                console.error(`Error creating ${type} shapefile:`, error);
                return false;
            }
        }
        
        // Helper function to get all coordinates from geometry
        function getAllCoordinates(coords) {
            const result = [];
            
            function extract(c) {
                if (typeof c[0] === 'number') {
                    result.push(c);
                } else {
                    c.forEach(extract);
                }
            }
            
            extract(coords);
            return result;
        }
        
        // Create .shp file (ESRI Shapefile binary format)
        function createShpFile(features, shapeType, minX, minY, maxX, maxY) {
            const records = [];
            let fileLength = 100; // Header length
            
            features.forEach((feature, index) => {
                if (!feature.geometry || !feature.geometry.coordinates) {
                    console.warn(`Feature ${index} has no geometry`);
                    return;
                }
                
                const recordHeader = new ArrayBuffer(8);
                const recordHeaderView = new DataView(recordHeader);
                
                // Record number (big-endian)
                recordHeaderView.setInt32(0, index + 1, false);
                
                // Create record content based on shape type
                let recordContent;
                const coords = feature.geometry.coordinates;
                const geomType = feature.geometry.type;
                
                if (shapeType === 1) { // Point
                    if (geomType === 'Point') {
                        // Single Point
                        recordContent = new ArrayBuffer(20);
                        const view = new DataView(recordContent);
                        view.setInt32(0, 1, true); // Shape Type
                        view.setFloat64(4, coords[0], true); // X
                        view.setFloat64(12, coords[1], true); // Y
                    } else if (geomType === 'MultiPoint') {
                        // MultiPoint
                        const numPoints = coords.length;
                        recordContent = new ArrayBuffer(40 + 16 * numPoints);
                        const view = new DataView(recordContent);
                        
                        let offset = 0;
                        view.setInt32(offset, 8, true); offset += 4; // Shape Type: MultiPoint
                        
                        // Bounding box
                        let pMinX = Infinity, pMinY = Infinity, pMaxX = -Infinity, pMaxY = -Infinity;
                        coords.forEach(([x, y]) => {
                            pMinX = Math.min(pMinX, x);
                            pMinY = Math.min(pMinY, y);
                            pMaxX = Math.max(pMaxX, x);
                            pMaxY = Math.max(pMaxY, y);
                        });
                        
                        view.setFloat64(offset, pMinX, true); offset += 8;
                        view.setFloat64(offset, pMinY, true); offset += 8;
                        view.setFloat64(offset, pMaxX, true); offset += 8;
                        view.setFloat64(offset, pMaxY, true); offset += 8;
                        view.setInt32(offset, numPoints, true); offset += 4;
                        
                        coords.forEach(([x, y]) => {
                            view.setFloat64(offset, x, true); offset += 8;
                            view.setFloat64(offset, y, true); offset += 8;
                        });
                    }
                } else if (shapeType === 3) { // PolyLine
                    let allParts = [];
                    let allPoints = [];
                    
                    if (geomType === 'LineString') {
                        // Single LineString
                        allParts = [0];
                        allPoints = coords;
                    } else if (geomType === 'MultiLineString') {
                        // MultiLineString
                        let pointCount = 0;
                        coords.forEach(line => {
                            allParts.push(pointCount);
                            allPoints = allPoints.concat(line);
                            pointCount += line.length;
                        });
                    }
                    
                    const numParts = allParts.length;
                    const numPoints = allPoints.length;
                    
                    // Calculate bounding box
                    let lMinX = Infinity, lMinY = Infinity, lMaxX = -Infinity, lMaxY = -Infinity;
                    allPoints.forEach(([x, y]) => {
                        lMinX = Math.min(lMinX, x);
                        lMinY = Math.min(lMinY, y);
                        lMaxX = Math.max(lMaxX, x);
                        lMaxY = Math.max(lMaxY, y);
                    });
                    
                    recordContent = new ArrayBuffer(44 + 4 * numParts + 16 * numPoints);
                    const view = new DataView(recordContent);
                    
                    let offset = 0;
                    view.setInt32(offset, 3, true); offset += 4; // Shape Type: PolyLine
                    view.setFloat64(offset, lMinX, true); offset += 8;
                    view.setFloat64(offset, lMinY, true); offset += 8;
                    view.setFloat64(offset, lMaxX, true); offset += 8;
                    view.setFloat64(offset, lMaxY, true); offset += 8;
                    view.setInt32(offset, numParts, true); offset += 4;
                    view.setInt32(offset, numPoints, true); offset += 4;
                    
                    // Parts array
                    allParts.forEach(partIndex => {
                        view.setInt32(offset, partIndex, true); offset += 4;
                    });
                    
                    // Points array
                    allPoints.forEach(([x, y]) => {
                        view.setFloat64(offset, x, true); offset += 8;
                        view.setFloat64(offset, y, true); offset += 8;
                    });
                } else if (shapeType === 5) { // Polygon
                    let allParts = [];
                    let allPoints = [];
                    
                    if (geomType === 'Polygon') {
                        // Single Polygon
                        let pointCount = 0;
                        coords.forEach(ring => {
                            allParts.push(pointCount);
                            allPoints = allPoints.concat(ring);
                            pointCount += ring.length;
                        });
                    } else if (geomType === 'MultiPolygon') {
                        // MultiPolygon
                        let pointCount = 0;
                        coords.forEach(polygon => {
                            polygon.forEach(ring => {
                                allParts.push(pointCount);
                                allPoints = allPoints.concat(ring);
                                pointCount += ring.length;
                            });
                        });
                    }
                    
                    const numParts = allParts.length;
                    const numPoints = allPoints.length;
                    
                    // Calculate bounding box
                    let pMinX = Infinity, pMinY = Infinity, pMaxX = -Infinity, pMaxY = -Infinity;
                    allPoints.forEach(([x, y]) => {
                        pMinX = Math.min(pMinX, x);
                        pMinY = Math.min(pMinY, y);
                        pMaxX = Math.max(pMaxX, x);
                        pMaxY = Math.max(pMaxY, y);
                    });
                    
                    recordContent = new ArrayBuffer(44 + 4 * numParts + 16 * numPoints);
                    const view = new DataView(recordContent);
                    
                    let offset = 0;
                    view.setInt32(offset, 5, true); offset += 4; // Shape Type: Polygon
                    view.setFloat64(offset, pMinX, true); offset += 8;
                    view.setFloat64(offset, pMinY, true); offset += 8;
                    view.setFloat64(offset, pMaxX, true); offset += 8;
                    view.setFloat64(offset, pMaxY, true); offset += 8;
                    view.setInt32(offset, numParts, true); offset += 4;
                    view.setInt32(offset, numPoints, true); offset += 4;
                    
                    // Parts array
                    allParts.forEach(partIndex => {
                        view.setInt32(offset, partIndex, true); offset += 4;
                    });
                    
                    // Points array
                    allPoints.forEach(([x, y]) => {
                        view.setFloat64(offset, x, true); offset += 8;
                        view.setFloat64(offset, y, true); offset += 8;
                    });
                }
                
                if (!recordContent) {
                    console.error(`Could not create record content for feature ${index}`, feature);
                    return;
                }
                
                // Record content length in 16-bit words (big-endian)
                recordHeaderView.setInt32(4, recordContent.byteLength / 2, false);
                
                records.push(recordHeader);
                records.push(recordContent);
                fileLength += 8 + recordContent.byteLength;
            });
            
            // Create header
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            
            headerView.setInt32(0, 9994, false); // File code (big-endian)
            // Skip bytes 4-20 (unused)
            headerView.setInt32(24, fileLength / 2, false); // File length in 16-bit words (big-endian)
            headerView.setInt32(28, 1000, true); // Version (little-endian)
            headerView.setInt32(32, shapeType, true); // Shape type (little-endian)
            headerView.setFloat64(36, minX, true); // Xmin
            headerView.setFloat64(44, minY, true); // Ymin
            headerView.setFloat64(52, maxX, true); // Xmax
            headerView.setFloat64(60, maxY, true); // Ymax
            // Zmin, Zmax, Mmin, Mmax (bytes 68-99) can be 0
            
            // Combine header and records
            const result = new Uint8Array(fileLength);
            let offset = 0;
            
            result.set(new Uint8Array(header), offset);
            offset += 100;
            
            records.forEach(record => {
                result.set(new Uint8Array(record), offset);
                offset += record.byteLength;
            });
            
            return result;
        }
        
        // Create .shx file (Index)
        function createShxFile(features, shapeType, minX, minY, maxX, maxY) {
            const numRecords = features.length;
            const fileLength = 100 + (numRecords * 8);
            const buffer = new ArrayBuffer(fileLength);
            const view = new DataView(buffer);
            
            // Header (same structure as .shp)
            view.setInt32(0, 9994, false); // File code (big-endian)
            view.setInt32(24, fileLength / 2, false); // File length in 16-bit words (big-endian)
            view.setInt32(28, 1000, true); // Version (little-endian)
            view.setInt32(32, shapeType, true); // Shape type (little-endian)
            view.setFloat64(36, minX, true); // Xmin
            view.setFloat64(44, minY, true); // Ymin
            view.setFloat64(52, maxX, true); // Xmax
            view.setFloat64(60, maxY, true); // Ymax
            
            // Index records - calculate actual record sizes
            let offset = 50; // Start after header (in 16-bit words)
            
            for (let i = 0; i < numRecords; i++) {
                const feature = features[i];
                let recordLength;
                
                if (shapeType === 1) { // Point
                    recordLength = 10; // 20 bytes / 2 = 10 words
                } else if (shapeType === 8) { // MultiPoint
                    const numPoints = feature.geometry.coordinates.length;
                    recordLength = 20 + 8 * numPoints; // (40 + 16*n bytes) / 2
                } else if (shapeType === 3) { // PolyLine
                    const geomType = feature.geometry.type;
                    let numPoints, numParts;
                    
                    if (geomType === 'LineString') {
                        numParts = 1;
                        numPoints = feature.geometry.coordinates.length;
                    } else { // MultiLineString
                        numParts = feature.geometry.coordinates.length;
                        numPoints = feature.geometry.coordinates.reduce((sum, line) => sum + line.length, 0);
                    }
                    recordLength = 22 + 2 * numParts + 8 * numPoints; // (44 + 4*p + 16*n bytes) / 2
                } else if (shapeType === 5) { // Polygon
                    const geomType = feature.geometry.type;
                    let numPoints, numParts;
                    
                    if (geomType === 'Polygon') {
                        numParts = feature.geometry.coordinates.length;
                        numPoints = feature.geometry.coordinates.reduce((sum, ring) => sum + ring.length, 0);
                    } else { // MultiPolygon
                        numParts = 0;
                        numPoints = 0;
                        feature.geometry.coordinates.forEach(polygon => {
                            numParts += polygon.length;
                            polygon.forEach(ring => {
                                numPoints += ring.length;
                            });
                        });
                    }
                    recordLength = 22 + 2 * numParts + 8 * numPoints; // (44 + 4*p + 16*n bytes) / 2
                }
                
                // Write offset and length (big-endian)
                view.setInt32(100 + i * 8, offset, false);
                view.setInt32(104 + i * 8, recordLength, false);
                
                offset += recordLength + 4; // Record length + header (8 bytes = 4 words)
            }
            
            return new Uint8Array(buffer);
        }
        
        // Create .dbf file (dBASE format) with full Thai support
        function createDbfFile(features) {
            // Get all unique attribute keys and determine their types
            const fieldInfo = new Map();
            
            features.forEach(f => {
                if (f.properties) {
                    Object.entries(f.properties).forEach(([key, value]) => {
                        if (!fieldInfo.has(key)) {
                            // Determine field type and length based on all values
                            let fieldType = 'C'; // Character (default)
                            let fieldLength = 254;
                            let decimal = 0;
                            
                            if (typeof value === 'number') {
                                if (Number.isInteger(value)) {
                                    fieldType = 'N'; // Numeric
                                    const maxVal = Math.max(...features.map(f => Math.abs(f.properties?.[key] || 0)));
                                    fieldLength = Math.min(18, Math.max(10, String(Math.floor(maxVal)).length + 1));
                                    decimal = 0;
                                } else {
                                    fieldType = 'F'; // Float
                                    fieldLength = 19;
                                    decimal = 11;
                                }
                            } else if (typeof value === 'boolean') {
                                fieldType = 'L'; // Logical
                                fieldLength = 1;
                                decimal = 0;
                            } else if (value instanceof Date || (typeof value === 'string' && !isNaN(Date.parse(value)))) {
                                fieldType = 'D'; // Date
                                fieldLength = 8;
                                decimal = 0;
                            } else if (typeof value === 'string') {
                                // Calculate max length needed for this field across all features
                                const maxLength = Math.max(...features.map(f => {
                                    const val = f.properties?.[key];
                                    if (val === null || val === undefined) return 0;
                                    // Count bytes for Thai characters (3 bytes per Thai char in UTF-8)
                                    const str = String(val);
                                    let byteCount = 0;
                                    for (let i = 0; i < str.length; i++) {
                                        const code = str.charCodeAt(i);
                                        if (code >= 0x0E00 && code <= 0x0E7F) {
                                            byteCount += 3; // Thai character
                                        } else if (code > 127) {
                                            byteCount += 2; // Other Unicode
                                        } else {
                                            byteCount += 1; // ASCII
                                        }
                                    }
                                    return byteCount;
                                }));
                                fieldLength = Math.min(254, Math.max(50, maxLength + 10)); // Add buffer
                            }
                            
                            fieldInfo.set(key, { 
                                type: fieldType, 
                                length: fieldLength, 
                                decimal: decimal,
                                originalKey: key
                            });
                        }
                    });
                }
            });
            
            // Convert to array - keep ALL fields up to DBF limit
            const allFields = Array.from(fieldInfo.entries());
            
            // Create field definitions
            const fields = allFields.map(([name, info]) => {
                // Preserve original field name but limit length
                let fieldName = name;
                
                // If field name is Thai or contains special chars, create safe name
                let safeName = fieldName;
                const hasThaiOrSpecial = /[^\x00-\x7F]/.test(fieldName) || /[^A-Za-z0-9_]/.test(fieldName);
                
                if (hasThaiOrSpecial) {
                    // Create abbreviated English name
                    safeName = 'FIELD_' + (allFields.indexOf([name, info]) + 1);
                }
                
                safeName = safeName.substring(0, 10).toUpperCase();
                
                return {
                    name: safeName,
                    originalName: fieldName,
                    type: info.type,
                    length: info.length,
                    decimal: info.decimal
                };
            });
            
            // Add default FID field if no fields exist
            if (fields.length === 0) {
                fields.push({ 
                    name: 'FID', 
                    originalName: 'FID',
                    type: 'N', 
                    length: 10,
                    decimal: 0
                });
            }
            
            const numRecords = features.length;
            const numFields = fields.length;
            const headerLength = 32 + (numFields * 32) + 1;
            const recordLength = fields.reduce((sum, f) => sum + f.length, 1); // +1 for deletion flag
            
            const fileLength = headerLength + (numRecords * recordLength) + 1; // +1 for EOF marker
            const buffer = new ArrayBuffer(fileLength);
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);
            
            // Header
            const now = new Date();
            view.setUint8(0, 0x03); // Version: dBASE III
            view.setUint8(1, now.getFullYear() - 1900); // Year
            view.setUint8(2, now.getMonth() + 1); // Month
            view.setUint8(3, now.getDate()); // Day
            view.setUint32(4, numRecords, true); // Number of records
            view.setUint16(8, headerLength, true); // Header length
            view.setUint16(10, recordLength, true); // Record length
            // Bytes 12-13: Reserved
            // Byte 14: Flag for incomplete transaction
            // Byte 15: Encryption flag
            // Bytes 16-27: Reserved for multi-user
            // Byte 28: MDX flag
            view.setUint8(29, 0x03); // Language driver ID (0x03 = Windows ANSI)
            
            // Field descriptors
            let offset = 32;
            
            fields.forEach((field, idx) => {
                // Field name (11 bytes, null-terminated)
                const fieldNameBytes = new TextEncoder().encode(field.name);
                for (let i = 0; i < Math.min(fieldNameBytes.length, 10); i++) {
                    bytes[offset + i] = fieldNameBytes[i];
                }
                for (let i = fieldNameBytes.length; i < 11; i++) {
                    bytes[offset + i] = 0x00;
                }
                
                bytes[offset + 11] = field.type.charCodeAt(0); // Field type
                view.setUint32(offset + 12, 0, true); // Field data address (not used)
                bytes[offset + 16] = field.length; // Field length
                bytes[offset + 17] = field.decimal; // Decimal count
                // Bytes 18-19: Work area ID
                // Byte 20: Example
                // Bytes 21-30: Reserved
                // Byte 31: MDX field flag
                
                offset += 32;
            });
            
            bytes[offset] = 0x0D; // Field descriptor terminator
            offset++;
            
            // Records
            features.forEach((feature, idx) => {
                bytes[offset] = 0x20; // Not deleted (space character)
                offset++;
                
                fields.forEach((field, fieldIdx) => {
                    let value = '';
                    const propValue = feature.properties?.[field.originalName];
                    
                    if (propValue !== undefined && propValue !== null) {
                        if (field.type === 'N') {
                            // Numeric (Integer)
                            const num = Number(propValue);
                            if (!isNaN(num)) {
                                value = String(Math.floor(num)).substring(0, field.length).padStart(field.length, ' ');
                            } else {
                                value = ''.padStart(field.length, ' ');
                            }
                        } else if (field.type === 'F') {
                            // Float
                            const num = Number(propValue);
                            if (!isNaN(num)) {
                                value = num.toFixed(field.decimal).substring(0, field.length).padStart(field.length, ' ');
                            } else {
                                value = ''.padStart(field.length, ' ');
                            }
                        } else if (field.type === 'L') {
                            // Logical
                            const bool = Boolean(propValue);
                            value = bool ? 'T' : 'F';
                        } else if (field.type === 'D') {
                            // Date (YYYYMMDD)
                            let date = propValue instanceof Date ? propValue : new Date(propValue);
                            if (!isNaN(date.getTime())) {
                                const year = date.getFullYear();
                                const month = String(date.getMonth() + 1).padStart(2, '0');
                                const day = String(date.getDate()).padStart(2, '0');
                                value = `${year}${month}${day}`;
                            } else {
                                value = '        '; // 8 spaces for invalid date
                            }
                        } else {
                            // Character - encode to TIS-620 for Thai support
                            const str = String(propValue);
                            value = encodeToTIS620(str, field.length);
                        }
                    } else if (field.originalName === 'FID') {
                        // Default FID field
                        value = String(idx + 1).padStart(field.length, ' ');
                    } else {
                        // Empty value
                        value = ''.padStart(field.length, ' ');
                    }
                    
                    // Ensure value is exactly field.length
                    if (value.length > field.length) {
                        value = value.substring(0, field.length);
                    } else if (value.length < field.length) {
                        value = value.padEnd(field.length, ' ');
                    }
                    
                    // Write to buffer as bytes
                    const valueBytes = encodeStringToBytes(value);
                    for (let i = 0; i < field.length; i++) {
                        bytes[offset + i] = i < valueBytes.length ? valueBytes[i] : 0x20;
                    }
                    offset += field.length;
                });
            });
            
            bytes[offset] = 0x1A; // EOF marker
            
            return bytes;
        }
        
        // Helper function to encode Thai text to TIS-620
        function encodeToTIS620(str, maxLength) {
            const bytes = [];
            
            for (let i = 0; i < str.length && bytes.length < maxLength; i++) {
                const char = str[i];
                const code = str.charCodeAt(i);
                
                // Thai characters (Unicode 0x0E00-0x0E7F â†’ TIS-620 0xA0-0xFF)
                if (code >= 0x0E00 && code <= 0x0E7F) {
                    const tis620Code = code - 0x0E00 + 0xA0;
                    bytes.push(tis620Code);
                }
                // ASCII characters
                else if (code <= 0x7F) {
                    bytes.push(code);
                }
                // Other Unicode characters - try to preserve or use placeholder
                else {
                    bytes.push(0x3F); // Question mark for unsupported characters
                }
            }
            
            // Convert bytes array to string
            let result = '';
            for (let i = 0; i < bytes.length; i++) {
                result += String.fromCharCode(bytes[i]);
            }
            
            return result;
        }
        
        // Helper function to encode string to bytes
        function encodeStringToBytes(str) {
            const bytes = [];
            for (let i = 0; i < str.length; i++) {
                bytes.push(str.charCodeAt(i) & 0xFF);
            }
            return bytes;
        }
        
        // Create field mapping file for Thai field names
        function createFieldMappingFile(features) {
            const fieldInfo = new Map();
            
            features.forEach(f => {
                if (f.properties) {
                    Object.keys(f.properties).forEach(key => {
                        if (!fieldInfo.has(key)) {
                            fieldInfo.set(key, true);
                        }
                    });
                }
            });
            
            const allFields = Array.from(fieldInfo.keys());
            let mapping = '====================================\n';
            mapping += 'Field Name Mapping (DBF â†” Original)\n';
            mapping += '====================================\n\n';
            mapping += 'DBF files have limitations on field names:\n';
            mapping += '- Maximum 10 characters\n';
            mapping += '- ASCII characters only (A-Z, 0-9, _)\n\n';
            mapping += 'This file maps the shortened field names in the .dbf file\n';
            mapping += 'to the original field names from your GeoJSON.\n\n';
            mapping += 'Format: DBF_FIELD_NAME = Original Field Name\n';
            mapping += '----------------------------------------\n\n';
            
            allFields.forEach((originalName, idx) => {
                const hasThaiOrSpecial = /[^\x00-\x7F]/.test(originalName) || /[^A-Za-z0-9_]/.test(originalName);
                let safeName;
                
                if (hasThaiOrSpecial) {
                    safeName = 'FIELD_' + (idx + 1);
                } else {
                    safeName = originalName.substring(0, 10).toUpperCase();
                }
                
                mapping += `${safeName.padEnd(12)} = ${originalName}\n`;
            });
            
            mapping += '\n====================================\n';
            mapping += `Total Fields: ${allFields.length}\n`;
            mapping += 'Encoding: UTF-8\n';
            mapping += '====================================\n';
            
            return mapping;
        }
        
        // Create field mapping file for Thai field names
        function createFieldMappingFile(features) {
            const fieldInfo = new Map();
            
            features.forEach(f => {
                if (f.properties) {
                    Object.keys(f.properties).forEach(key => {
                        if (!fieldInfo.has(key)) {
                            fieldInfo.set(key, true);
                        }
                    });
                }
            });
            
            const allFields = Array.from(fieldInfo.keys());
            let mapping = '====================================\n';
            mapping += 'Field Name Mapping (DBF â†” Original)\n';
            mapping += '====================================\n\n';
            mapping += 'DBF files have limitations on field names:\n';
            mapping += '- Maximum 10 characters\n';
            mapping += '- ASCII characters only (A-Z, 0-9, _)\n\n';
            mapping += 'This file maps the shortened field names in the .dbf file\n';
            mapping += 'to the original field names from your GeoJSON.\n\n';
            mapping += 'Format: DBF_FIELD_NAME = Original Field Name\n';
            mapping += '----------------------------------------\n\n';
            
            allFields.forEach((originalName, idx) => {
                const hasThaiOrSpecial = /[^\x00-\x7F]/.test(originalName) || /[^A-Za-z0-9_]/.test(originalName);
                let safeName;
                
                if (hasThaiOrSpecial) {
                    safeName = 'FIELD_' + (idx + 1);
                } else {
                    safeName = originalName.substring(0, 10).toUpperCase();
                }
                
                mapping += `${safeName.padEnd(12)} = ${originalName}\n`;
            });
            
            mapping += '\n====================================\n';
            mapping += `Total Fields: ${allFields.length}\n`;
            mapping += 'Character Encoding: UTF-8\n';
            mapping += 'Thai text encoded in: TIS-620 (in DBF)\n';
            mapping += '====================================\n';
            
            return mapping;
        }
        
        // Create .xml metadata file
        function createXmlMetadata(baseName, type, featureCount, crs) {
            return `<?xml version="1.0" encoding="UTF-8"?>
<metadata xml:lang="th">
  <Esri>
    <CreaDate>${new Date().toISOString().split('T')[0]}</CreaDate>
    <CreaTime>${new Date().toTimeString().split(' ')[0].replace(/:/g, '')}</CreaTime>
    <ArcGISFormat>1.0</ArcGISFormat>
    <SyncOnce>TRUE</SyncOnce>
    <DataProperties>
      <lineage>
        <Process ToolSource="MAPRAW GIS File Converter">
          <export>GeoJSON to Shapefile</export>
        </Process>
      </lineage>
    </DataProperties>
  </Esri>
  <dataIdInfo>
    <idCitation>
      <resTitle>${baseName}</resTitle>
    </idCitation>
    <searchKeys>
      <keyword>Shapefile</keyword>
      <keyword>${type}</keyword>
      <keyword>GIS</keyword>
    </searchKeys>
    <dataLang>
      <languageCode value="tha"/>
      <countryCode value="TH"/>
    </dataLang>
    <dataChar>
      <CharSetCd value="021"/>
    </dataChar>
  </dataIdInfo>
  <distInfo>
    <distributor>
      <distorCont>
        <rpOrgName>MAPRAW</rpOrgName>
      </distorCont>
    </distributor>
    <distFormat>
      <formatName>Shapefile</formatName>
    </distFormat>
  </distInfo>
  <spatRepInfo>
    <VectSpatRep>
      <geometObjs>
        <geoObjTyp>
          <GeoObjTypCd value="${type === 'point' ? '1' : type === 'line' ? '2' : '3'}"/>
        </geoObjTyp>
        <geoObjCnt>${featureCount}</geoObjCnt>
      </geometObjs>
    </VectSpatRep>
  </spatRepInfo>
  <refSysInfo>
    <RefSystem>
      <refSysID>
        <identCode>${crs}</identCode>
      </refSysID>
    </RefSystem>
  </refSysInfo>
</metadata>`;
        }

        function updatePreview2(geojson) {
            const jsonString = JSON.stringify(geojson, null, 2);
            const preview = jsonString.length > 500 
                ? jsonString.substring(0, 500) + '...' 
                : jsonString;
            
            resultPreview2.textContent = preview;
            resultPreview2.style.display = 'block';
        }

        function downloadShapefile() {
            if (!shapefileZip) return;
            saveAs(shapefileZip, `${fileName2}_shapefile.zip`);
            showMessage2('à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸”à¹„à¸Ÿà¸¥à¹Œ Shapefile à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§!', 'success');
        }

        function resetUI2() {
            errorMessage2.style.display = 'none';
            successMessage2.style.display = 'none';
            resultPreview2.style.display = 'none';
            resultContainer2.classList.add('hidden');
            projectionInfo.classList.add('hidden');
        }

        function showLoading2() {
            loadingSpinner2.classList.remove('hidden');
        }

        function hideLoading2() {
            loadingSpinner2.classList.add('hidden');
        }

        function showSuccess2() {
            resultContainer2.classList.remove('hidden');
            showMessage2('à¸à¸²à¸£à¹à¸›à¸¥à¸‡à¹„à¸Ÿà¸¥à¹Œà¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ!', 'success');
        }

        function showError2(message) {
            errorMessage2.textContent = message;
            errorMessage2.style.display = 'block';
            successMessage2.style.display = 'none';
        }

        function showMessage2(message, type) {
            if (type === 'error') {
                errorMessage2.textContent = message;
                errorMessage2.style.display = 'block';
                successMessage2.style.display = 'none';
            } else {
                successMessage2.textContent = message;
                successMessage2.style.display = 'block';
                errorMessage2.style.display = 'none';
            }
        }

        // ============================================
        // Mobile Menu Handler
        // ============================================
        const menuBtn = document.getElementById('mobileMenuBtn');
        const nav = document.getElementById('mainNav');

        menuBtn.addEventListener('click', () => {
            menuBtn.classList.toggle('active');
            nav.classList.toggle('active');
        });

        function toggleMobileDropdown(element) {
            if (window.innerWidth <= 1200) {
                element.classList.toggle('active');
            }
        }
        
        // à¸›à¸´à¸”à¹€à¸¡à¸™à¸¹à¹€à¸¡à¸·à¹ˆà¸­à¸„à¸¥à¸´à¸à¸à¸·à¹‰à¸™à¸—à¸µà¹ˆà¸§à¹ˆà¸²à¸‡
        document.addEventListener('click', (e) => {
            if (!nav.contains(e.target) && !menuBtn.contains(e.target) && nav.classList.contains('active')) {
                nav.classList.remove('active');
                menuBtn.classList.remove('active');
            }
        });
    </script>
</body>
</html>
