<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONVERT GIS FILE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shpjs/3.6.3/shp.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shpwrite@latest/shpwrite.js"></script>
    <style>
    /* =========================================
       1. CORE VARIABLES (THEME FROM PAGE 11)
       ========================================= */
    :root {
        --primary-gradient: linear-gradient(135deg, #1e88e5 0%, #1565c0 50%, #0d47a1 100%);
        --primary-solid: #1565c0;
        --primary-dark: #0d47a1;
        --primary-light: #e3f2fd;
        --text-white: #ffffff;
        --text-yellow: #ffeb3b;
        --text-gray: #546e7a;
        
        --bg-glass: rgba(255, 255, 255, 0.1);
        --bg-glass-hover: rgba(255, 255, 255, 0.25);
        --header-height: 70px;
        --radius-md: 12px;
        --radius-sm: 8px;
    }

    /* Import Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Prompt:wght@300;400;500;600;700&display=swap');
    @import url('https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
        font-family: 'Prompt', sans-serif;
        margin: 0;
        padding-top: calc(var(--header-height) + 20px);
        background: linear-gradient(180deg, #f0f7ff 0%, #ffffff 100%);
        min-height: 100vh;
        color: #333;
        padding-bottom: 40px;
    }

    /* =========================================
       2. HEADER STYLES (MATCHING PAGE 11)
       *‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ HTML Header ‡πÅ‡∏ö‡∏ö Page 11*
       ========================================= */
    .mapraw-header {
        background: var(--primary-gradient);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: fixed;
        top: 0; left: 0; width: 100%; z-index: 1000;
        height: var(--header-height);
    }
    
    .mapraw-header-content {
        max-width: 100%; margin: 0 auto; display: flex;
        align-items: center; justify-content: space-between;
        padding: 0 20px; height: 100%;
    }
    
    .mapraw-logo-section { display: flex; flex-direction: column; justify-content: center; padding-right: 15px; }
    .mapraw-logo-main { color: var(--text-white); font-size: 1.2rem; font-weight: 700; margin: 0; line-height: 1; white-space: nowrap; }
    .mapraw-logo-main span { color: var(--text-yellow); text-shadow: 0 0 10px rgba(255, 235, 59, 0.5); }
    .mapraw-page-title { color: #e3f2fd; font-size: 1rem; font-weight: 400; margin: 2px 0 0 0; white-space: nowrap; }
    
    .mapraw-nav { display: flex; gap: 8px; align-items: center; height: 100%; }
    .mapraw-nav-item { position: relative; height: 100%; display: flex; align-items: center; }
    
    .mapraw-nav-btn {
        background: var(--bg-glass); color: white; border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 0.85rem; font-weight: 500;
        transition: all 0.2s ease; text-decoration: none; display: flex; align-items: center; gap: 6px;
        font-family: 'Prompt', sans-serif; white-space: nowrap;
    }
    .mapraw-nav-btn:hover { background: var(--bg-glass-hover); transform: translateY(-1px); }
    .mapraw-nav-btn.home-btn { background: rgba(255, 235, 59, 0.15); border-color: #ffeb3b; color: #ffeb3b; }
    .mapraw-nav-btn.home-btn:hover { background: #ffeb3b; color: #1565c0; }

    .mapraw-dropdown {
        position: absolute; top: calc(100% - 10px); left: 50%; transform: translateX(-50%) translateY(10px);
        background: white; border-radius: 8px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        min-width: 200px; opacity: 0; visibility: hidden; transition: all 0.2s ease; padding: 5px 0; z-index: 1001;
    }
    @media (min-width: 1201px) { .mapraw-nav-item:hover .mapraw-dropdown { opacity: 1; visibility: visible; transform: translateX(-50%) translateY(0); } }
    .mapraw-dropdown-item { display: block; padding: 10px 20px; color: #333; text-decoration: none; font-size: 0.9rem; transition: background 0.2s; white-space: nowrap; }
    .mapraw-dropdown-item:hover { background: #f1f8ff; color: var(--primary-solid); }

    .mobile-menu-toggle { display: none; background: none; border: none; cursor: pointer; padding: 10px; z-index: 1002; }
    .bar { display: block; width: 25px; height: 3px; margin: 5px auto; background-color: white; transition: all 0.3s ease-in-out; border-radius: 2px; }

    /* =========================================
       3. PAGE 11D CONTAINER STYLES
       ========================================= */
    .container {
        max-width: 1000px;
        margin: 0 auto;
        background-color: white;
        border-radius: var(--radius-md);
        box-shadow: 0 4px 20px rgba(30, 136, 229, 0.15);
        padding: 30px;
        border-top: 4px solid var(--primary-solid);
    }

    h1 {
        text-align: center;
        color: var(--primary-dark);
        margin-bottom: 30px;
        font-weight: 700;
        font-size: 24px;
        position: relative;
        padding-bottom: 10px;
    }
    
    h1:after {
        content: '';
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 60px;
        height: 4px;
        background-color: var(--text-yellow);
        border-radius: 2px;
    }

    h2 {
        text-align: center;
        color: var(--text-gray);
        font-size: 1.25rem;
        margin-bottom: 20px;
        font-weight: 600;
    }

    /* =========================================
       4. TABS & UI ELEMENTS
       ========================================= */
    .tabs {
        display: flex;
        border-bottom: 2px solid #e5e7eb;
        margin-bottom: 30px;
        gap: 10px;
    }

    .tab {
        padding: 12px 25px;
        cursor: pointer;
        background-color: transparent;
        border: 2px solid transparent;
        border-radius: var(--radius-sm) var(--radius-sm) 0 0;
        font-weight: 500;
        color: var(--text-gray);
        transition: all 0.3s;
        margin-bottom: -2px;
    }

    .tab:hover {
        color: var(--primary-solid);
        background-color: #f8f9fa;
    }

    .tab.active {
        background-color: white;
        color: var(--primary-solid);
        border-color: #e5e7eb;
        border-bottom-color: white;
        border-top: 3px solid var(--primary-solid);
    }

    .tab-content { display: none; animation: fadeIn 0.3s ease; }
    .tab-content.active { display: block; }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    /* Upload Area */
    .upload-area {
        border: 2px dashed #bbdefb;
        border-radius: var(--radius-md);
        padding: 40px;
        text-align: center;
        background-color: #f8fbff;
        margin-bottom: 25px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .upload-area:hover {
        border-color: var(--primary-solid);
        background-color: #e3f2fd;
        transform: translateY(-2px);
    }

    .upload-icon {
        font-size: 48px;
        color: var(--primary-solid);
        margin-bottom: 15px;
    }
    
    .upload-area p {
        color: var(--text-gray);
        font-size: 1rem;
    }

    /* Buttons */
    .btn {
        background: var(--primary-gradient);
        color: white;
        border: none;
        padding: 12px 30px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 16px;
        font-family: 'Prompt', sans-serif;
        font-weight: 500;
        transition: all 0.3s;
        margin: 5px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(21, 101, 192, 0.2);
        background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);
    }

    .btn:disabled {
        background: #cfd8dc;
        cursor: not-allowed;
        box-shadow: none;
        transform: none;
    }

    /* Results and Feedback */
    .result-area {
        margin-top: 20px;
        border: 1px solid #e0e0e0;
        border-radius: var(--radius-sm);
        padding: 15px;
        background-color: #fafafa;
        max-height: 300px;
        overflow-y: auto;
        white-space: pre-wrap;
        display: none;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 14px;
        color: #333;
    }

    .spinner {
        display: inline-block;
        width: 40px;
        height: 40px;
        border: 4px solid rgba(21, 101, 192, 0.2);
        border-radius: 50%;
        border-top-color: var(--primary-solid);
        animation: spin 1s ease-in-out infinite;
        margin-bottom: 10px;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .error-message {
        color: #c62828;
        background-color: #ffebee;
        padding: 15px;
        border-radius: var(--radius-sm);
        margin-bottom: 20px;
        display: none;
        border-left: 4px solid #c62828;
    }

    .success-message {
        color: #2e7d32;
        background-color: #e8f5e9;
        padding: 15px;
        border-radius: var(--radius-sm);
        margin-bottom: 20px;
        display: none;
        border-left: 4px solid #2e7d32;
    }

    .hidden { display: none; }

    /* Projection Options */
    .projection-options {
        margin-top: 20px;
        padding: 20px;
        border: 1px solid #e3f2fd;
        border-radius: var(--radius-sm);
        background-color: #f1f8ff;
    }

    .projection-title {
        font-weight: 600;
        margin-bottom: 15px;
        color: var(--primary-dark);
    }

    .radio-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .radio-option {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.95rem;
        color: var(--text-gray);
    }

    .radio-option input {
        margin-right: 12px;
        accent-color: var(--primary-solid);
        width: 18px;
        height: 18px;
    }
    
    /* Info Box */
    .info-box {
        background-color: #e3f2fd;
        border-left: 4px solid var(--primary-solid);
        padding: 15px 20px;
        margin-bottom: 25px;
        border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
        color: #455a64;
    }

    .detected-projection {
        font-weight: bold;
        color: var(--primary-dark);
    }

    /* Navigation Buttons (Bottom) */
    .navigation-buttons {
        display: flex;
        justify-content: center;
        margin-top: 40px;
        gap: 20px;
    }

    .nav-btn {
        background-color: white;
        color: var(--text-gray);
        border: 2px solid #e0e0e0;
        padding: 10px 25px;
        border-radius: 50px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        font-family: 'Prompt', sans-serif;
        font-weight: 500;
    }

    .nav-btn:hover {
        background-color: white;
        border-color: var(--primary-solid);
        color: var(--primary-solid);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .nav-btn.home-btn, .nav-btn.area-btn {
        background-color: white; /* Override styles */
    }

    footer {
        text-align: center;
        margin-top: 40px;
        color: var(--text-gray);
        font-size: 14px;
        border-top: 1px solid #e3f2fd;
        padding-top: 20px;
    }

    /* =========================================
       5. RESPONSIVE QUERIES
       ========================================= */
    @media (max-width: 1400px) { .mapraw-nav-btn { padding: 6px 8px; font-size: 0.8rem; } .mapraw-nav { gap: 4px; } }
    @media (max-width: 1200px) {
        .mobile-menu-toggle { display: block; }
        .mapraw-nav { position: fixed; top: var(--header-height); right: -100%; width: 280px; height: calc(100vh - var(--header-height)); background: white; flex-direction: column; align-items: stretch; gap: 0; padding: 10px 0; transition: right 0.3s ease; box-shadow: -5px 0 15px rgba(0,0,0,0.1); overflow-y: auto; }
        .mapraw-nav.active { right: 0; }
        .mapraw-nav-item { height: auto; flex-direction: column; width: 100%; display: block; border-bottom: 1px solid #eee; }
        .mapraw-nav-btn { background: white; color: #333; border: none; border-radius: 0; padding: 15px 20px; font-size: 1rem; justify-content: space-between; width: 100%; }
        .mapraw-nav-btn:hover { background: #f5f5f5; color: var(--primary-solid); transform: none; }
        .mapraw-dropdown { position: static; transform: none; visibility: visible; opacity: 1; box-shadow: none; min-width: 100%; background: #f9f9f9; display: none; padding: 0; }
        .mapraw-nav-item.active .mapraw-dropdown { display: block; }
        .mapraw-dropdown-item { padding-left: 40px; color: #666; }
        .mobile-menu-toggle.active .bar:nth-child(2) { opacity: 0; }
        .mobile-menu-toggle.active .bar:nth-child(1) { transform: translateY(8px) rotate(45deg); }
        .mobile-menu-toggle.active .bar:nth-child(3) { transform: translateY(-8px) rotate(-45deg); }
    }
    @media (max-width: 480px) { 
        .mapraw-logo-main { font-size: 1rem; } 
        .mapraw-page-title { font-size: 0.75rem; }
        .container { padding: 20px; }
        .tabs { flex-direction: column; gap: 0; }
        .tab { width: 100%; text-align: center; border-radius: var(--radius-sm); margin-bottom: 5px; }
        .tab.active { border: 2px solid var(--primary-solid); }
    }
</style>
</head>
<body>
    </head>
<body>
        <header class="mapraw-header">
    <div class="mapraw-header-content">
        <div class="mapraw-logo-section">
            <h1 class="mapraw-logo-main">TOOL FROM <span>MAPRAW</span></h1>
            <p class="mapraw-page-title">Calculate AREA</p>
        </div>
        
        <button class="mobile-menu-toggle" id="mobileMenuBtn">
            <span class="bar"></span>
            <span class="bar"></span>
            <span class="bar"></span>
        </button>

        <nav class="mapraw-nav" id="mainNav">
            <div class="mapraw-nav-item">
                <a href="index.html" class="mapraw-nav-btn home-btn">
                    <span>üè† ‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</span>
                </a>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üìã ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏£‡∏ß‡∏à</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page1.html" class="mapraw-dropdown-item">NoteMAP</a>
                    <a href="#" class="mapraw-dropdown-item">SURVEY WORK</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üîß ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page2.html" class="mapraw-dropdown-item">Reclass BLDG</a>
                    <a href="page5.html" class="mapraw-dropdown-item">Prepare PLLU</a>
                    <a href="page8.html" class="mapraw-dropdown-item">SHAPEFILE TO EXCEL</a>
                    <a href="page10.html" class="mapraw-dropdown-item">CAPTURE MAP</a>
                    <a href="page13.html" class="mapraw-dropdown-item">Perpendicular Line</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>‚öôÔ∏è ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page3.html" class="mapraw-dropdown-item">Calculate Landuse</a>
                    <a href="page6.html" class="mapraw-dropdown-item">Calculate Population</a>
                    <a href="page11.html" class="mapraw-dropdown-item">Calculate AREA</a>
                    <a href="page14.html" class="mapraw-dropdown-item">RECLASS FACTORY</a>
                    <a href="page12.html" class="mapraw-dropdown-item">COMPARISON LANDUSE</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>‚öñÔ∏è ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page4.html" class="mapraw-dropdown-item">Town Planning Laws</a>
                    <a href="page15.html" class="mapraw-dropdown-item">Building Laws</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üßÆ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page7.html" class="mapraw-dropdown-item">AREA Calculator</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üéØ ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏≠‡∏∑‡πà‡∏ô‡πÜ</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page9.html" class="mapraw-dropdown-item">CREATE QRCODE</a>
                </div>
            </div>
        </nav>
    </div>
</header>
    <div class="container">
        <h1>CONVERT GIS FILE</h1>
        
        <div class="tabs">
            <div class="tab active" data-tab="tab1">Shapefile ‚Üí GeoJSON</div>
            <div class="tab" data-tab="tab2">GeoJSON ‚Üí Shapefile</div>
        </div>
        
        <!-- Tab 1: Shapefile to GeoJSON -->
        <div class="tab-content active" id="tab1">
            <h2>Shapefile to GeoJSON Converter</h2>
            
            <div class="error-message" id="errorMessage1"></div>
            <div class="success-message" id="successMessage1"></div>
            
            <div class="upload-area" id="uploadArea1">
                <div class="upload-icon">üìÅ</div>
                <p>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏ó‡∏µ‡πà‡∏°‡∏µ Shapefile (.shp, .dbf, etc.) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á</p>
                <input type="file" id="fileInput1" accept=".zip" style="display: none;">
            </div>
            
            <div class="projection-options">
                <div class="projection-title">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô (‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î):</div>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="original" checked>
                        <span>‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:4326 (WGS84 - ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö GeoJSON)</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="EPSG:32647">
                        <span>‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:32647 (UTM Zone 47N)</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="projection1" value="EPSG:32648">
                        <span>‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:32648 (UTM Zone 48N)</span>
                    </label>
                </div>
            </div>
            
            <div id="loadingSpinner1" class="hidden" style="text-align: center;">
                <div class="spinner"></div>
                <p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile...</p>
            </div>
            
            <div id="resultContainer1" class="hidden" style="text-align: center;">
                <p>‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!</p>
                <button id="downloadBtn1" class="btn">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î GeoJSON</button>
            </div>
            
            <pre id="resultPreview1" class="result-area"></pre>
        </div>
        
        <!-- Tab 2: GeoJSON to Shapefile -->
        <div class="tab-content" id="tab2">
            <h2>GeoJSON to Shapefile Converter</h2>
            
            <div class="error-message" id="errorMessage2"></div>
            <div class="success-message" id="successMessage2"></div>
            
            <div id="projectionInfo" class="info-box hidden">
                <p>‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô: <span id="detectedProjection" class="detected-projection">EPSG:4326 (WGS84)</span></p>
                <p>‡∏à‡∏∞‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Shapefile ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö</p>
            </div>
            
            <div class="upload-area" id="uploadArea2">
                <div class="upload-icon">üìä</div>
                <p>‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà‡∏´‡∏£‡∏∑‡∏≠‡∏•‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå GeoJSON (.geojson, .json) ‡∏°‡∏≤‡∏ß‡∏≤‡∏á</p>
                <input type="file" id="fileInput2" accept=".geojson,.json" style="display: none;">
            </div>
            
            <div id="loadingSpinner2" class="hidden" style="text-align: center;">
                <div class="spinner"></div>
                <p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå GeoJSON...</p>
            </div>
            
            <div id="resultContainer2" class="hidden" style="text-align: center;">
                <p>‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!</p>
                <button id="downloadBtn2" class="btn">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Shapefile (ZIP)</button>
            </div>
            
            <pre id="resultPreview2" class="result-area"></pre>
        </div>


    <script>
        // Tab Switching
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(c => c.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                tab.classList.add('active');
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId === 'tab1' ? 'tab1' : 'tab2').classList.add('active');
            });
        });
        
        // Define projection definitions
        const projDefinitions = {
            'EPSG:4326': '+proj=longlat +datum=WGS84 +no_defs', // WGS84 - standard GeoJSON
            'EPSG:32647': '+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs', // UTM zone 47N
            'EPSG:32648': '+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs'  // UTM zone 48N
        };
        
        // Register projections with proj4js
        for (const [code, def] of Object.entries(projDefinitions)) {
            proj4.defs(code, def);
        }
        
        // ******************************************
        // PART 1: SHAPEFILE TO GEOJSON
        // ******************************************
        
        // DOM Elements
        const uploadArea1 = document.getElementById('uploadArea1');
        const fileInput1 = document.getElementById('fileInput1');
        const loadingSpinner1 = document.getElementById('loadingSpinner1');
        const resultContainer1 = document.getElementById('resultContainer1');
        const downloadBtn1 = document.getElementById('downloadBtn1');
        const resultPreview1 = document.getElementById('resultPreview1');
        const errorMessage1 = document.getElementById('errorMessage1');
        const successMessage1 = document.getElementById('successMessage1');
        const projectionOptions1 = document.getElementsByName('projection1');
        
        // Global variables
        let originalGeoJSON = null;
        let convertedGeoJSON = null;
        let fileName1 = 'converted';
        
        // Setup event listeners
        uploadArea1.addEventListener('click', () => fileInput1.click());
        uploadArea1.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#2563eb';
            uploadArea1.style.backgroundColor = '#f0f4ff';
        });
        uploadArea1.addEventListener('dragleave', () => {
            uploadArea1.style.borderColor = '#ccc';
            uploadArea1.style.backgroundColor = '#f8f9fa';
        });
        uploadArea1.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea1.style.borderColor = '#ccc';
            uploadArea1.style.backgroundColor = '#f8f9fa';
            
            if (e.dataTransfer.files.length) {
                handleShapefileUpload(e.dataTransfer.files[0]);
            }
        });
        fileInput1.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleShapefileUpload(e.target.files[0]);
            }
        });
        downloadBtn1.addEventListener('click', downloadGeoJSON);
        
        // Add event listeners for projection change
        projectionOptions1.forEach(option => {
            option.addEventListener('change', () => {
                if (originalGeoJSON) {
                    const selectedProjection = getSelectedProjection1();
                    
                    if (selectedProjection === 'original') {
                        convertedGeoJSON = originalGeoJSON;
                        updatePreview1(convertedGeoJSON);
                        showMessage1('‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô EPSG:4326 (WGS84) ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß', 'success');
                    } else {
                        try {
                            convertedGeoJSON = transformGeoJSON(originalGeoJSON, selectedProjection);
                            updatePreview1(convertedGeoJSON);
                            showMessage1(`‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô ${selectedProjection} ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß`, 'success');
                        } catch (error) {
                            showError1(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô: ${error.message}`);
                        }
                    }
                }
            });
        });
        
        // Function to get selected projection
        function getSelectedProjection1() {
            for (const option of projectionOptions1) {
                if (option.checked) {
                    return option.value;
                }
            }
            return 'original';
        }
        
        // Function to handle file upload
        function handleShapefileUpload(file) {
            if (!file.name.endsWith('.zip')) {
                showError1('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• shapefile');
                return;
            }
            
            fileName1 = file.name.replace('.zip', '');
            resetUI1();
            showLoading1();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const zipData = e.target.result;
                    await processShapefileZip(zipData);
                } catch (error) {
                    console.error('Conversion error:', error);
                    showError1(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå: ${error.message}`);
                    hideLoading1();
                }
            };
            reader.onerror = () => {
                showError1('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå');
                hideLoading1();
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Process zip file
        async function processShapefileZip(zipData) {
            try {
                const zip = await JSZip.loadAsync(zipData);
                const fileNames = Object.keys(zip.files);
                
                // Check for required shapefile components
                const hasSHP = fileNames.some(name => name.toLowerCase().endsWith('.shp'));
                const hasDBF = fileNames.some(name => name.toLowerCase().endsWith('.dbf'));
                
                if (!hasSHP || !hasDBF) {
                    throw new Error('‡πÑ‡∏ü‡∏•‡πå ZIP ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå .shp ‡πÅ‡∏•‡∏∞ .dbf ‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢');
                }
                
                // Using shp.js to convert
                const geojson = await shp(zipData);
                originalGeoJSON = geojson;
                
                // Apply projection transformation if needed
                const selectedProjection = getSelectedProjection1();
                if (selectedProjection !== 'original') {
                    convertedGeoJSON = transformGeoJSON(originalGeoJSON, selectedProjection);
                } else {
                    convertedGeoJSON = originalGeoJSON;
                }
                
                // Update preview
                updatePreview1(convertedGeoJSON);
                
                // Show success
                hideLoading1();
                showSuccess1();
                
            } catch (error) {
                console.error('Error processing zip:', error);
                showError1(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå ZIP: ${error.message}`);
                hideLoading1();
            }
        }
        
        // Function to transform GeoJSON to a different projection
        function transformGeoJSON(geojson, targetProjection) {
            // Deep clone the original GeoJSON to avoid modifying it
            const transformedGeoJSON = JSON.parse(JSON.stringify(geojson));
            
            // Function to transform coordinates
            function transformCoordinates(coords) {
                if (Array.isArray(coords[0]) && typeof coords[0][0] === 'number') {
                    // This is a LineString
                    return coords.map(coord => proj4('EPSG:4326', targetProjection, coord));
                } else if (Array.isArray(coords[0]) && Array.isArray(coords[0][0])) {
                    // This is a Polygon or MultiLineString
                    return coords.map(line => transformCoordinates(line));
                } else if (Array.isArray(coords[0]) && Array.isArray(coords[0][0]) && Array.isArray(coords[0][0][0])) {
                    // This is a MultiPolygon
                    return coords.map(polygon => transformCoordinates(polygon));
                } else {
                    // This is a Point
                    return proj4('EPSG:4326', targetProjection, coords);
                }
            }
            
            // Process each feature
            if (transformedGeoJSON.type === 'FeatureCollection') {
                transformedGeoJSON.features.forEach(feature => {
                    if (feature.geometry) {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (transformedGeoJSON.type === 'Feature') {
                transformedGeoJSON.geometry.coordinates = transformCoordinates(transformedGeoJSON.geometry.coordinates);
            }
            
            // Update CRS property
            transformedGeoJSON.crs = {
                type: 'name',
                properties: {
                    name: targetProjection
                }
            };
            
            return transformedGeoJSON;
        }
        
        // Update preview
        function updatePreview1(geojson) {
            const jsonString = JSON.stringify(geojson, null, 2);
            const preview = jsonString.length > 500 
                ? jsonString.substring(0, 500) + '...' 
                : jsonString;
            
            resultPreview1.textContent = preview;
            resultPreview1.style.display = 'block';
        }
        
        // Download GeoJSON function
        function downloadGeoJSON() {
            if (!convertedGeoJSON) return;
            
            const jsonString = JSON.stringify(convertedGeoJSON);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const selectedProjection = getSelectedProjection1();
            let downloadFileName = fileName1;
            
            if (selectedProjection !== 'original') {
                downloadFileName += `_${selectedProjection.replace(':', '_')}`;
            }
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${downloadFileName}.geojson`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage1('‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå GeoJSON ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!', 'success');
        }
        
        // UI Helper functions
        function resetUI1() {
            errorMessage1.style.display = 'none';
            successMessage1.style.display = 'none';
            resultPreview1.style.display = 'none';
            resultContainer1.classList.add('hidden');
        }
        
        function showLoading1() {
            loadingSpinner1.classList.remove('hidden');
        }
        
        function hideLoading1() {
            loadingSpinner1.classList.add('hidden');
        }
        
        function showSuccess1() {
            resultContainer1.classList.remove('hidden');
            showMessage1('‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!', 'success');
        }
        
        function showError1(message) {
            errorMessage1.textContent = message;
            errorMessage1.style.display = 'block';
            successMessage1.style.display = 'none';
        }
        
        function showMessage1(message, type) {
            if (type === 'error') {
                errorMessage1.textContent = message;
                errorMessage1.style.display = 'block';
                successMessage1.style.display = 'none';
            } else {
                successMessage1.textContent = message;
                successMessage1.style.display = 'block';
                errorMessage1.style.display = 'none';
            }
        }
        
        // ******************************************
        // PART 2: GEOJSON TO SHAPEFILE
        // ******************************************
        
        // DOM Elements
        const uploadArea2 = document.getElementById('uploadArea2');
        const fileInput2 = document.getElementById('fileInput2');
        const loadingSpinner2 = document.getElementById('loadingSpinner2');
        const resultContainer2 = document.getElementById('resultContainer2');
        const downloadBtn2 = document.getElementById('downloadBtn2');
        const resultPreview2 = document.getElementById('resultPreview2');
        const errorMessage2 = document.getElementById('errorMessage2');
        const successMessage2 = document.getElementById('successMessage2');
        const projectionInfo = document.getElementById('projectionInfo');
        const detectedProjection = document.getElementById('detectedProjection');
        
        // Global variables for GeoJSON to Shapefile
        let originalGeoJSONData = null;
        let fileName2 = 'converted';
        let detectedCRS = 'EPSG:4326'; // Default CRS
        let shapefileZip = null;
        
        // Setup event listeners
        uploadArea2.addEventListener('click', () => fileInput2.click());
        uploadArea2.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#2563eb';
            uploadArea2.style.backgroundColor = '#f0f4ff';
        });
        uploadArea2.addEventListener('dragleave', () => {
            uploadArea2.style.borderColor = '#ccc';
            uploadArea2.style.backgroundColor = '#f8f9fa';
        });
        uploadArea2.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea2.style.borderColor = '#ccc';
            uploadArea2.style.backgroundColor = '#f8f9fa';
            
            if (e.dataTransfer.files.length) {
                handleGeoJSONUpload(e.dataTransfer.files[0]);
            }
        });
        fileInput2.addEventListener('change', (e) => {
            if (e.target.files.length) {
                handleGeoJSONUpload(e.target.files[0]);
            }
        });
        downloadBtn2.addEventListener('click', downloadShapefile);
        
        // Function to handle GeoJSON file upload
        function handleGeoJSONUpload(file) {
            if (!file.name.endsWith('.geojson') && !file.name.endsWith('.json')) {
                showError2('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏õ‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå GeoJSON (.geojson ‡∏´‡∏£‡∏∑‡∏≠ .json)');
                return;
            }
            
            fileName2 = file.name.replace('.geojson', '').replace('.json', '');
            resetUI2();
            showLoading2();
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const jsonData = e.target.result;
                    await processGeoJSONFile(jsonData);
                } catch (error) {
                    console.error('GeoJSON processing error:', error);
                    showError2(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå GeoJSON: ${error.message}`);
                    hideLoading2();
                }
            };
            reader.onerror = () => {
                showError2('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå');
                hideLoading2();
            };
            reader.readAsText(file);
        }
        
        // Process GeoJSON file
        async function processGeoJSONFile(jsonData) {
            try {
                // Parse the GeoJSON data
                const geoJSONObj = JSON.parse(jsonData);
                originalGeoJSONData = geoJSONObj;
                
                // Detect the projection/CRS from the GeoJSON
                detectGeoJSONProjection(geoJSONObj);
                
                // Process with the detected projection
                await processGeoJSONWithProjection();
                
                // Show success
                hideLoading2();
                showSuccess2();
                
            } catch (error) {
                console.error('Error processing GeoJSON:', error);
                showError2(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå GeoJSON: ${error.message}`);
                hideLoading2();
            }
        }
        
        // Function to detect projection from GeoJSON
        function detectGeoJSONProjection(geoJSON) {
            let crs = 'EPSG:4326'; // Default
            
            // Check if the GeoJSON has a CRS property
            if (geoJSON.crs && geoJSON.crs.properties && geoJSON.crs.properties.name) {
                const crsName = geoJSON.crs.properties.name;
                
                // Handle different CRS formats (e.g., 'EPSG:4326', 'urn:ogc:def:crs:EPSG::4326', etc.)
                if (crsName.includes('EPSG')) {
                    // Extract the EPSG code
                    let epsgCode = '';
                    
                    if (crsName.startsWith('EPSG:')) {
                        epsgCode = crsName; // Already in the right format
                    } else if (crsName.includes('EPSG')) {
                        // Try to extract the code using regex
                        const epsgMatch = crsName.match(/EPSG[:]{0,2}(\d+)/);
                        if (epsgMatch && epsgMatch[1]) {
                            epsgCode = `EPSG:${epsgMatch[1]}`;
                        }
                    }
                    
                    // Check if we found a valid EPSG code and it's in our supported list
                    if (epsgCode && projDefinitions[epsgCode]) {
                        crs = epsgCode;
                    }
                }
            }
            
            // Update the detected projection information
            detectedCRS = crs;
            detectedProjection.textContent = crs === 'EPSG:4326' ? 
                'EPSG:4326 (WGS84)' : 
                crs === 'EPSG:32647' ? 
                'EPSG:32647 (UTM Zone 47N)' : 
                crs === 'EPSG:32648' ? 
                'EPSG:32648 (UTM Zone 48N)' : 
                crs;
            
            // Show the projection info box
            projectionInfo.classList.remove('hidden');
            
            return crs;
        }
        
        // Process GeoJSON with detected projection
        async function processGeoJSONWithProjection() {
            try {
                // Use only the detected projection
                await createShapefile(originalGeoJSONData);
                
                // Update preview
                updatePreview2(originalGeoJSONData);
                
                showMessage2(`GeoJSON ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô Shapefile ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô ${detectedCRS}`, 'success');
                
            } catch (error) {
                console.error('Error processing GeoJSON with projection:', error);
                showError2(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ê‡∏≤‡∏ô: ${error.message}`);
            }
        }
        
        // Function to create Shapefile from GeoJSON
        async function createShapefile(geoJSON) {
            try {
                // Create a new instance of JSZip
                const zip = new JSZip();
                
                // Extract features from GeoJSON
                let features = [];
                if (geoJSON.type === 'FeatureCollection') {
                    features = geoJSON.features;
                } else if (geoJSON.type === 'Feature') {
                    features = [geoJSON];
                }
                
                if (features.length === 0) {
                    throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Feature ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå GeoJSON');
                }
                
                // Group features by geometry type
                let points = [];
                let lines = [];
                let polygons = [];
                
                features.forEach(feature => {
                    if (!feature.geometry) return;
                    
                    const geomType = feature.geometry.type.toLowerCase();
                    
                    if (geomType === 'point' || geomType === 'multipoint') {
                        points.push(feature);
                    } else if (geomType === 'linestring' || geomType === 'multilinestring') {
                        lines.push(feature);
                    } else if (geomType === 'polygon' || geomType === 'multipolygon') {
                        polygons.push(feature);
                    }
                });
                
                // Flag to track if we added any shapefiles
                let filesAdded = false;
                
                // Create a .prj file with the correct projection
                let prjContent = '';
                
                if (detectedCRS === 'EPSG:4326' || detectedCRS.includes('4326')) {
                    // WGS84
                    prjContent = 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]';
                } else if (detectedCRS === 'EPSG:32647' || detectedCRS.includes('32647')) {
                    // UTM Zone 47N
                    prjContent = 'PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",99],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
                } else if (detectedCRS === 'EPSG:32648' || detectedCRS.includes('32648')) {
                    // UTM Zone 48N
                    prjContent = 'PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",105],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
                }
                
                // Create separate shapefiles for each geometry type
                // Points
                if (points.length > 0) {
                    const pointGeoJSON = {
                        type: 'FeatureCollection',
                        features: points,
                        crs: geoJSON.crs
                    };
                    
                    await createShapefileForFeatureType(pointGeoJSON, 'point', zip, prjContent);
                    filesAdded = true;
                }
                
                // Lines
                if (lines.length > 0) {
                    const lineGeoJSON = {
                        type: 'FeatureCollection',
                        features: lines,
                        crs: geoJSON.crs
                    };
                    
                    await createShapefileForFeatureType(lineGeoJSON, 'line', zip, prjContent);
                    filesAdded = true;
                }
                
                // Polygons
                if (polygons.length > 0) {
                    const polygonGeoJSON = {
                        type: 'FeatureCollection',
                        features: polygons,
                        crs: geoJSON.crs
                    };
                    
                    await createShapefileForFeatureType(polygonGeoJSON, 'polygon', zip, prjContent);
                    filesAdded = true;
                }
                
                if (!filesAdded) {
                    throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile ‡πÑ‡∏î‡πâ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• GeoJSON ‡∏≠‡∏≤‡∏à‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                }
                
                // Generate the ZIP file
                shapefileZip = await zip.generateAsync({type: 'blob'});
                
                return true;
                
            } catch (error) {
                console.error('Error creating shapefile:', error);
                throw new Error(`‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile: ${error.message}`);
            }
        }
        
        // Create a shapefile for a specific feature type
        async function createShapefileForFeatureType(geoJSON, type, zip, prjContent) {
            try {
                const typeSuffix = type === 'point' ? 'point' : (type === 'line' ? 'line' : 'poly');
                const baseName = `${fileName2}_${typeSuffix}`;
                
                // Use shpwrite to create proper shapefile binary data
                return new Promise((resolve, reject) => {
                    try {
                        // Determine geometry type for shpwrite
                        let geomType;
                        if (type === 'point') {
                            geomType = 'POINT';
                        } else if (type === 'line') {
                            geomType = 'POLYLINE';
                        } else {
                            geomType = 'POLYGON';
                        }
                        
                        // Use shpwrite to generate shapefile components
                        shpwrite.write(geoJSON.features, geomType, function(err, files) {
                            if (err) {
                                console.error('shpwrite error:', err);
                                // Use fallback method
                                createBasicShapefile(geoJSON, type, zip, prjContent)
                                    .then(resolve)
                                    .catch(reject);
                                return;
                            }
                            
                            try {
                                // Add shapefile components to zip
                                if (files.shp) {
                                    zip.file(`${baseName}.shp`, files.shp.buffer, {binary: true});
                                }
                                if (files.shx) {
                                    zip.file(`${baseName}.shx`, files.shx.buffer, {binary: true});
                                }
                                if (files.dbf) {
                                    zip.file(`${baseName}.dbf`, files.dbf.buffer, {binary: true});
                                }
                                
                                // Add custom PRJ file with correct projection
                                if (prjContent) {
                                    zip.file(`${baseName}.prj`, prjContent);
                                }
                                
                                // Add CPG file for UTF-8 encoding
                                zip.file(`${baseName}.cpg`, 'UTF-8');
                                
                                resolve(true);
                            } catch (error) {
                                console.error('Error adding files to zip:', error);
                                reject(error);
                            }
                        });
                    } catch (error) {
                        console.error('Error in shpwrite.write:', error);
                        // Use fallback method
                        createBasicShapefile(geoJSON, type, zip, prjContent)
                            .then(resolve)
                            .catch(reject);
                    }
                });
            } catch (error) {
                console.error(`Error creating ${type} shapefile:`, error);
                // Use fallback method
                return createBasicShapefile(geoJSON, type, zip, prjContent);
            }
        }
        
        // Fallback function to create basic shapefile structure with proper binary format
        async function createBasicShapefile(geoJSON, type, zip, prjContent) {
            try {
                const typeSuffix = type === 'point' ? 'point' : (type === 'line' ? 'line' : 'poly');
                const baseName = `${fileName2}_${typeSuffix}`;
                
                // Collect all coordinates and properties
                const features = geoJSON.features;
                const properties = features.length > 0 ? Object.keys(features[0].properties || {}) : [];
                
                // Calculate bounding box
                const bbox = calculateBoundingBox(geoJSON);
                
                // Determine shape type
                let shapeType = 0;
                if (type === 'point') shapeType = 1;      // Point
                else if (type === 'line') shapeType = 3;   // Polyline
                else if (type === 'polygon') shapeType = 5; // Polygon
                
                // Create SHP file
                const shpData = createCompleteShpFile(features, shapeType, bbox);
                zip.file(`${baseName}.shp`, shpData, {binary: true});
                
                // Create SHX file (index)
                const shxData = createCompleteShxFile(features, shapeType);
                zip.file(`${baseName}.shx`, shxData, {binary: true});
                
                // Create DBF file (attributes)
                const dbfData = createCompleteDbfFile(features, properties);
                zip.file(`${baseName}.dbf`, dbfData, {binary: true});
                
                // Add PRJ file
                if (prjContent) {
                    zip.file(`${baseName}.prj`, prjContent);
                }
                
                // Add CPG file for UTF-8 encoding
                zip.file(`${baseName}.cpg`, 'UTF-8');
                
                return true;
            } catch (error) {
                console.error('Error in fallback shapefile creation:', error);
                throw error;
            }
        }
        
        // Create complete SHP file with proper structure
        function createCompleteShpFile(features, shapeType, bbox) {
            const records = [];
            let offset = 50; // Header is 100 bytes = 50 16-bit words
            
            features.forEach((feature, index) => {
                const recordHeader = new ArrayBuffer(8);
                const recordHeaderView = new DataView(recordHeader);
                
                // Record number (1-based, big-endian)
                recordHeaderView.setInt32(0, index + 1, false);
                
                // Content length will be calculated based on geometry
                let contentLength = 0;
                let shapeData;
                
                if (shapeType === 1) { // Point
                    contentLength = 10; // 20 bytes = 10 words (4 for type + 16 for coordinates)
                    shapeData = createPointRecord(feature.geometry);
                } else if (shapeType === 3) { // Polyline
                    const result = createPolylineRecord(feature.geometry);
                    contentLength = result.length;
                    shapeData = result.data;
                } else if (shapeType === 5) { // Polygon
                    const result = createPolygonRecord(feature.geometry);
                    contentLength = result.length;
                    shapeData = result.data;
                }
                
                recordHeaderView.setInt32(4, contentLength, false);
                
                records.push({
                    header: recordHeader,
                    data: shapeData,
                    offset: offset,
                    length: contentLength
                });
                
                offset += 4 + contentLength; // 4 words for record header + content length
            });
            
            // Calculate total file length in 16-bit words
            const fileLengthWords = offset;
            
            // Create main header (100 bytes)
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            
            // File code (9994) - big endian
            headerView.setInt32(0, 9994, false);
            
            // Unused positions (5 int32)
            for (let i = 4; i < 24; i += 4) {
                headerView.setInt32(i, 0, false);
            }
            
            // File length in 16-bit words - big endian
            headerView.setInt32(24, fileLengthWords, false);
            
            // Version (1000) - little endian
            headerView.setInt32(28, 1000, true);
            
            // Shape type - little endian
            headerView.setInt32(32, shapeType, true);
            
            // Bounding box - little endian
            headerView.setFloat64(36, bbox.xmin, true);
            headerView.setFloat64(44, bbox.ymin, true);
            headerView.setFloat64(52, bbox.xmax, true);
            headerView.setFloat64(60, bbox.ymax, true);
            
            // Z range (unused, set to 0)
            headerView.setFloat64(68, 0, true);
            headerView.setFloat64(76, 0, true);
            
            // M range (unused, set to 0)
            headerView.setFloat64(84, 0, true);
            headerView.setFloat64(92, 0, true);
            
            // Combine header and all records
            const totalSize = 100 + records.reduce((sum, rec) => sum + 8 + rec.data.byteLength, 0);
            const result = new Uint8Array(totalSize);
            
            // Copy header
            result.set(new Uint8Array(header), 0);
            
            // Copy records
            let position = 100;
            records.forEach(record => {
                result.set(new Uint8Array(record.header), position);
                position += 8;
                result.set(new Uint8Array(record.data), position);
                position += record.data.byteLength;
            });
            
            return result.buffer;
        }
        
        // Create point record
        function createPointRecord(geometry) {
            const buffer = new ArrayBuffer(20); // 4 bytes type + 16 bytes coordinates
            const view = new DataView(buffer);
            
            // Shape type (1 = Point)
            view.setInt32(0, 1, true);
            
            // X coordinate
            view.setFloat64(4, geometry.coordinates[0], true);
            
            // Y coordinate
            view.setFloat64(12, geometry.coordinates[1], true);
            
            return buffer;
        }
        
        // Create polyline record
        function createPolylineRecord(geometry) {
            const coords = geometry.type === 'LineString' ? [geometry.coordinates] : geometry.coordinates;
            const numParts = coords.length;
            const numPoints = coords.reduce((sum, part) => sum + part.length, 0);
            
            // Calculate size: 4 (type) + 32 (bbox) + 4 (numParts) + 4 (numPoints) + 4*numParts (parts) + 16*numPoints (points)
            const size = 44 + 4 * numParts + 16 * numPoints;
            const buffer = new ArrayBuffer(size);
            const view = new DataView(buffer);
            
            // Shape type (3 = Polyline)
            view.setInt32(0, 3, true);
            
            // Bounding box
            const bbox = calculateGeometryBbox(coords);
            view.setFloat64(4, bbox.xmin, true);
            view.setFloat64(12, bbox.ymin, true);
            view.setFloat64(20, bbox.xmax, true);
            view.setFloat64(28, bbox.ymax, true);
            
            // Number of parts
            view.setInt32(36, numParts, true);
            
            // Number of points
            view.setInt32(40, numPoints, true);
            
            // Parts (starting index of each part)
            let offset = 44;
            let pointIndex = 0;
            for (let i = 0; i < numParts; i++) {
                view.setInt32(offset, pointIndex, true);
                offset += 4;
                pointIndex += coords[i].length;
            }
            
            // Points
            coords.forEach(part => {
                part.forEach(point => {
                    view.setFloat64(offset, point[0], true);
                    view.setFloat64(offset + 8, point[1], true);
                    offset += 16;
                });
            });
            
            return {
                data: buffer,
                length: size / 2 // Length in 16-bit words
            };
        }
        
        // Create polygon record
        function createPolygonRecord(geometry) {
            const coords = geometry.type === 'Polygon' ? [geometry.coordinates] : geometry.coordinates;
            const allRings = coords.flat();
            const numParts = allRings.length;
            const numPoints = allRings.reduce((sum, ring) => sum + ring.length, 0);
            
            // Calculate size
            const size = 44 + 4 * numParts + 16 * numPoints;
            const buffer = new ArrayBuffer(size);
            const view = new DataView(buffer);
            
            // Shape type (5 = Polygon)
            view.setInt32(0, 5, true);
            
            // Bounding box
            const bbox = calculateGeometryBbox(allRings);
            view.setFloat64(4, bbox.xmin, true);
            view.setFloat64(12, bbox.ymin, true);
            view.setFloat64(20, bbox.xmax, true);
            view.setFloat64(28, bbox.ymax, true);
            
            // Number of parts
            view.setInt32(36, numParts, true);
            
            // Number of points
            view.setInt32(40, numPoints, true);
            
            // Parts
            let offset = 44;
            let pointIndex = 0;
            for (let i = 0; i < numParts; i++) {
                view.setInt32(offset, pointIndex, true);
                offset += 4;
                pointIndex += allRings[i].length;
            }
            
            // Points
            allRings.forEach(ring => {
                ring.forEach(point => {
                    view.setFloat64(offset, point[0], true);
                    view.setFloat64(offset + 8, point[1], true);
                    offset += 16;
                });
            });
            
            return {
                data: buffer,
                length: size / 2
            };
        }
        
        // Create complete SHX file
        function createCompleteShxFile(features, shapeType) {
            // Header (100 bytes) + 8 bytes per record
            const size = 100 + features.length * 8;
            const buffer = new ArrayBuffer(size);
            const view = new DataView(buffer);
            
            // File code (9994) - big endian
            view.setInt32(0, 9994, false);
            
            // File length in 16-bit words - big endian
            view.setInt32(24, size / 2, false);
            
            // Version (1000) - little endian
            view.setInt32(28, 1000, true);
            
            // Shape type - little endian
            view.setInt32(32, shapeType, true);
            
            // Write record offsets and lengths
            let offset = 50; // Start after header (100 bytes / 2)
            let position = 100;
            
            features.forEach((feature, index) => {
                // Record offset in 16-bit words - big endian
                view.setInt32(position, offset, false);
                
                // Content length in 16-bit words - big endian
                let contentLength = 10; // Default for points
                
                if (shapeType === 3 || shapeType === 5) {
                    // Calculate for polyline/polygon
                    const coords = feature.geometry.type.includes('Multi') 
                        ? feature.geometry.coordinates.flat()
                        : (feature.geometry.type === 'Polygon' ? feature.geometry.coordinates : [feature.geometry.coordinates]);
                    const numParts = coords.length;
                    const numPoints = coords.reduce((sum, part) => sum + part.length, 0);
                    contentLength = (44 + 4 * numParts + 16 * numPoints) / 2;
                }
                
                view.setInt32(position + 4, contentLength, false);
                
                offset += 4 + contentLength;
                position += 8;
            });
            
            return buffer;
        }
        
        // Create complete DBF file
        // Create complete DBF file with proper field types and lengths
        function createCompleteDbfFile(features, properties) {
            const numRecords = features.length;
            
            // Analyze field types and calculate appropriate lengths
            const fieldDefinitions = [];
            
            // Add FID field
            fieldDefinitions.push({
                name: 'FID',
                type: 'N',
                length: 10,
                decimal: 0
            });
            
            // Analyze properties from first few features to determine types and lengths
            properties.forEach(prop => {
                let fieldType = 'C'; // Default to Character
                let maxLength = 10;
                let decimalCount = 0;
                
                // Sample data from features to determine type and max length
                let hasNumber = false;
                let hasDecimal = false;
                let hasDate = false;
                
                features.forEach(feature => {
                    if (!feature.properties || feature.properties[prop] === undefined || feature.properties[prop] === null) {
                        return;
                    }
                    
                    const value = feature.properties[prop];
                    const valueStr = value.toString();
                    
                    // Check if it's a number
                    if (typeof value === 'number' || !isNaN(parseFloat(valueStr))) {
                        hasNumber = true;
                        if (valueStr.includes('.')) {
                            hasDecimal = true;
                            const parts = valueStr.split('.');
                            if (parts[1]) {
                                decimalCount = Math.max(decimalCount, parts[1].length);
                            }
                        }
                    }
                    
                    // Check if it's a date
                    if (value instanceof Date || /^\d{4}-\d{2}-\d{2}/.test(valueStr)) {
                        hasDate = true;
                    }
                    
                    // Track max length
                    maxLength = Math.max(maxLength, valueStr.length);
                });
                
                // Determine field type
                if (hasDate) {
                    fieldType = 'D';
                    maxLength = 8; // YYYYMMDD format
                    decimalCount = 0;
                } else if (hasNumber) {
                    fieldType = hasDecimal ? 'F' : 'N'; // Float or Numeric
                    maxLength = Math.min(Math.max(maxLength, 10), 20);
                    if (hasDecimal) {
                        decimalCount = Math.min(decimalCount, 6);
                    }
                } else {
                    fieldType = 'C'; // Character
                    maxLength = Math.min(Math.max(maxLength, 10), 254); // DBF max is 254
                }
                
                fieldDefinitions.push({
                    name: prop.substring(0, 10), // Field name max 10 chars
                    type: fieldType,
                    length: maxLength,
                    decimal: decimalCount
                });
            });
            
            const numFields = fieldDefinitions.length;
            
            // Calculate record size
            const recordSize = fieldDefinitions.reduce((sum, field) => sum + field.length, 0) + 1; // +1 for deletion flag
            
            // Header: 32 bytes + 32 bytes per field + 1 terminator
            const headerSize = 32 + numFields * 32 + 1;
            const totalSize = headerSize + numRecords * recordSize + 1; // +1 for EOF marker
            
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);
            
            // Write DBF Header (32 bytes)
            view.setUint8(0, 0x03); // dBASE III
            
            // Last update date
            const now = new Date();
            view.setUint8(1, now.getFullYear() - 1900);
            view.setUint8(2, now.getMonth() + 1);
            view.setUint8(3, now.getDate());
            
            // Number of records (little-endian)
            view.setUint32(4, numRecords, true);
            
            // Header size (little-endian)
            view.setUint16(8, headerSize, true);
            
            // Record size (little-endian)
            view.setUint16(10, recordSize, true);
            
            // Reserved bytes (12-31) are already 0
            
            // Write Field Descriptors
            let fieldOffset = 32;
            
            fieldDefinitions.forEach(field => {
                // Field name (11 bytes, null-terminated)
                for (let i = 0; i < field.name.length && i < 10; i++) {
                    uint8View[fieldOffset + i] = field.name.charCodeAt(i);
                }
                // Fill remaining with null
                for (let i = field.name.length; i < 11; i++) {
                    uint8View[fieldOffset + i] = 0x00;
                }
                
                // Field type (1 byte)
                uint8View[fieldOffset + 11] = field.type.charCodeAt(0);
                
                // Field data address (4 bytes) - not used in DBF III, set to 0
                view.setUint32(fieldOffset + 12, 0, true);
                
                // Field length (1 byte)
                view.setUint8(fieldOffset + 16, field.length);
                
                // Decimal count (1 byte)
                view.setUint8(fieldOffset + 17, field.decimal);
                
                // Reserved bytes (18-31) are already 0
                
                fieldOffset += 32;
            });
            
            // Field descriptor terminator
            uint8View[fieldOffset] = 0x0D;
            
            // Write Records
            let recordOffset = headerSize;
            
            features.forEach((feature, index) => {
                // Deletion flag (0x20 = not deleted, 0x2A = deleted)
                uint8View[recordOffset] = 0x20;
                recordOffset++;
                
                // Write each field value
                fieldDefinitions.forEach((field, fieldIndex) => {
                    let value = '';
                    
                    if (fieldIndex === 0) {
                        // FID field
                        value = (index + 1).toString();
                    } else {
                        // Property field
                        const propName = properties[fieldIndex - 1];
                        const propValue = feature.properties && feature.properties[propName];
                        
                        if (propValue !== undefined && propValue !== null) {
                            if (field.type === 'D' && propValue instanceof Date) {
                                // Date format: YYYYMMDD
                                const year = propValue.getFullYear().toString().padStart(4, '0');
                                const month = (propValue.getMonth() + 1).toString().padStart(2, '0');
                                const day = propValue.getDate().toString().padStart(2, '0');
                                value = year + month + day;
                            } else if (field.type === 'D' && typeof propValue === 'string') {
                                // Try to parse date string
                                const dateMatch = propValue.match(/(\d{4})-(\d{2})-(\d{2})/);
                                if (dateMatch) {
                                    value = dateMatch[1] + dateMatch[2] + dateMatch[3];
                                } else {
                                    value = propValue.replace(/[^0-9]/g, '').substring(0, 8);
                                }
                            } else if (field.type === 'N' || field.type === 'F') {
                                // Numeric or Float
                                const numValue = typeof propValue === 'number' ? propValue : parseFloat(propValue);
                                if (!isNaN(numValue)) {
                                    if (field.decimal > 0) {
                                        value = numValue.toFixed(field.decimal);
                                    } else {
                                        value = Math.round(numValue).toString();
                                    }
                                } else {
                                    value = '';
                                }
                            } else {
                                // Character
                                value = propValue.toString();
                            }
                        }
                    }
                    
                    // Trim or pad value to field length
                    if (field.type === 'N' || field.type === 'F') {
                        // Right-align numeric fields
                        value = value.substring(0, field.length).padStart(field.length, ' ');
                    } else {
                        // Left-align character and date fields
                        value = value.substring(0, field.length).padEnd(field.length, ' ');
                    }
                    
                    // Write field value
                    for (let i = 0; i < field.length; i++) {
                        uint8View[recordOffset + i] = value.charCodeAt(i) || 0x20; // Use space if undefined
                    }
                    
                    recordOffset += field.length;
                });
            });
            
            // End of file marker
            uint8View[totalSize - 1] = 0x1A;
            
            return buffer;
        }
        
        // Calculate geometry bounding box
        function calculateGeometryBbox(coords) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            const processCoord = (coord) => {
                if (Array.isArray(coord[0])) {
                    coord.forEach(processCoord);
                } else {
                    xmin = Math.min(xmin, coord[0]);
                    ymin = Math.min(ymin, coord[1]);
                    xmax = Math.max(xmax, coord[0]);
                    ymax = Math.max(ymax, coord[1]);
                }
            };
            
            coords.forEach(processCoord);
            
            return { xmin, ymin, xmax, ymax };
        }
        
        // Helper function to calculate bounding box
        function calculateBoundingBox(geoJSON) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            geoJSON.features.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;
                
                const coords = feature.geometry.coordinates;
                const processCoord = (coord) => {
                    if (Array.isArray(coord[0])) {
                        coord.forEach(processCoord);
                    } else {
                        xmin = Math.min(xmin, coord[0]);
                        ymin = Math.min(ymin, coord[1]);
                        xmax = Math.max(xmax, coord[0]);
                        ymax = Math.max(ymax, coord[1]);
                    }
                };
                processCoord(coords);
            });
            
            return { xmin, ymin, xmax, ymax };
        }
        
        // Update preview for GeoJSON
        function updatePreview2(geojson) {
            const jsonString = JSON.stringify(geojson, null, 2);
            const preview = jsonString.length > 500 
                ? jsonString.substring(0, 500) + '...' 
                : jsonString;
            
            resultPreview2.textContent = preview;
            resultPreview2.style.display = 'block';
        }
        
        // Download Shapefile function
        function downloadShapefile() {
            if (!shapefileZip) return;
            
            // Create a URL for the blob
            const url = URL.createObjectURL(shapefileZip);
            
            // Create a download link
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName2}_shapefile.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showMessage2('‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Shapefile ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!', 'success');
        }
        
        // UI Helper functions for GeoJSON to Shapefile
        function resetUI2() {
            errorMessage2.style.display = 'none';
            successMessage2.style.display = 'none';
            resultPreview2.style.display = 'none';
            resultContainer2.classList.add('hidden');
            projectionInfo.classList.add('hidden');
        }
        
        function showLoading2() {
            loadingSpinner2.classList.remove('hidden');
        }
        
        function hideLoading2() {
            loadingSpinner2.classList.add('hidden');
        }
        
        function showSuccess2() {
            resultContainer2.classList.remove('hidden');
            showMessage2('‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå!', 'success');
        }
        
        function showError2(message) {
            errorMessage2.textContent = message;
            errorMessage2.style.display = 'block';
            successMessage2.style.display = 'none';
        }
        
        function showMessage2(message, type) {
            if (type === 'error') {
                errorMessage2.textContent = message;
                errorMessage2.style.display = 'block';
                successMessage2.style.display = 'none';
            } else {
                successMessage2.textContent = message;
                successMessage2.style.display = 'block';
                errorMessage2.style.display = 'none';
            }
        }
    </script>
<script>
    const menuBtn = document.getElementById('mobileMenuBtn');
    const nav = document.getElementById('mainNav');

    menuBtn.addEventListener('click', () => {
        menuBtn.classList.toggle('active');
        nav.classList.toggle('active');
    });

    function toggleMobileDropdown(element) {
        if (window.innerWidth <= 1200) {
            element.classList.toggle('active');
        }
    }
    
    // ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏ô‡∏π‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á
    document.addEventListener('click', (e) => {
        if (!nav.contains(e.target) && !menuBtn.contains(e.target) && nav.classList.contains('active')) {
            nav.classList.remove('active');
            menuBtn.classList.remove('active');
        }
    });
</script>
</body>
</html>