<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Sarabun', sans-serif; background: #f5f5f5; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 400px; background: white; padding: 20px; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        h1 { font-size: 20px; margin-bottom: 20px; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .section { margin-bottom: 25px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
        .section-title { font-weight: bold; margin-bottom: 12px; color: #2c3e50; font-size: 16px; }
        .file-input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; color: #555; font-weight: 500; }
        input[type="file"] { width: 100%; padding: 8px; border: 2px dashed #3498db; border-radius: 5px; background: white; cursor: pointer; }
        input[type="number"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: white; font-size: 14px; }
        input[type="number"]:focus { outline: none; border-color: #3498db; box-shadow: 0 0 5px rgba(52, 152, 219, 0.3); }
        select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: white; margin-bottom: 10px; }
        button { width: 100%; padding: 12px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px; transition: background 0.3s; }
        button:hover { background: #2980b9; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        #map { flex: 1; height: 100vh; }
        .status { padding: 10px; margin-top: 10px; border-radius: 5px; font-size: 13px; display: none; font-weight: 500; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        #processingProgress { background: linear-gradient(90deg, #e8f4f8 0%, #d1ecf1 100%); color: #0c5460; border-left: 4px solid #3498db; padding: 12px; font-weight: 500; border-radius: 5px; margin-top: 10px; animation: pulse 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .loading { display: none; text-align: center; padding: 10px; color: #3498db; }
        .loading.active { display: block; }
        .progress-bar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin-top: 10px; display: none; }
        .progress-bar.active { display: block; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); transition: width 0.3s; text-align: center; color: white; font-size: 12px; line-height: 20px; }
        .layer-item { display: flex; align-items: center; padding: 8px; margin-bottom: 5px; background: white; border-radius: 5px; border: 1px solid #e0e0e0; transition: background 0.2s; }
        .layer-item:hover { background: #f8f9fa; }
        .layer-item input[type="checkbox"] { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }
        .layer-item label { cursor: pointer; user-select: none; flex: 1; margin: 0; }
        .legend { background: white; padding: 15px; border-radius: 5px; margin-top: 10px; max-height: 400px; overflow-y: auto; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
        .legend-color { width: 30px; height: 20px; border: 1px solid #333; margin-right: 10px; border-radius: 3px; }
        .summary-box { background: white; padding: 12px; border-radius: 5px; margin-top: 10px; }
        .summary-item { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #eee; }
        .summary-item:last-child { border-bottom: none; }
        
        #showAllLayers, #hideAllLayers {
            transition: all 0.2s;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 3px;
        }
        #showAllLayers:hover {
            background: #229954 !important;
            transform: translateY(-1px);
        }
        #hideAllLayers:hover {
            background: #c0392b !important;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üè¢ ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á</h1>

            <div class="section">
                <div class="section-title">1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô</div>
                <label>‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:</label>
                <select id="epsgSelect">
                    <option value="EPSG:32647">WGS84 UTM Zone 47N (EPSG:32647)</option>
                    <option value="EPSG:32648">WGS84 UTM Zone 48N (EPSG:32648)</option>
                </select>
            </div>

            <div class="section">
                <div class="section-title">2. ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå Shapefile (ZIP)</div>
                <div class="file-input-group">
                    <label>üìÅ ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (.zip)</label>
                    <input type="file" id="buildingFiles" accept=".zip">
                </div>
                <div class="file-input-group">
                    <label>üìÅ ‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (.zip)</label>
                    <input type="file" id="parcelFiles" accept=".zip">
                </div>
                <button id="loadFiles">‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå</button>
                <div class="loading" id="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</div>
                <div id="loadStatus"></div>
            </div>

            <div class="section" id="fieldSection" style="display: none;">
                <div class="section-title">3. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</div>
                <label>Field ‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</label>
                <select id="areaField">
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
                <label>Field ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (TYPE_BUILD):</label>
                <select id="typeField">
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
                <label>Field Class (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö major_use2):</label>
                <select id="classField">
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
            </div>

            <div class="section" id="processSection" style="display: none;">
                <div class="section-title">4. ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å</div>
                <button id="processBtn">üîÑ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á</button>
                <div class="loading" id="processingLoading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div id="processStatus"></div>
            </div>

            <div class="section" id="resultSection" style="display: none;">
                <div class="section-title">5. ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</div>
                <div class="summary-box" id="resultSummary"></div>
            </div>

            <div class="legend" id="layerControl" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px;">
                    <div style="font-weight: bold;">üóÇÔ∏è ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>
                    <div style="display: flex; gap: 5px;">
                        <button id="showAllLayers" style="padding: 4px 8px; font-size: 11px; background: #27ae60; width: auto;">‡πÄ‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                        <button id="hideAllLayers" style="padding: 4px 8px; font-size: 11px; background: #e74c3c; width: auto;">‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #555; font-size: 14px;">üìÅ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö</div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleBuildings" checked>
                        <label for="toggleBuildings">
                            <span style="color: #FF69B4; font-weight: bold;">‚ñ†</span> ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á)
                        </label>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleParcels" checked>
                        <label for="toggleParcels">
                            <span style="color: #000; font-weight: bold;">‚ñ†</span> ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô
                        </label>
                    </div>
                </div>

                <div id="resultLayersSection" style="display: none;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #555; font-size: 14px;">üìä ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå</div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleResult" checked>
                        <label for="toggleResult">
                            <span style="color: #4ECDC4; font-weight: bold;">‚ñ†</span> ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå)
                        </label>
                    </div>
                </div>
            </div>

            <div class="section" id="exportSection" style="display: none;">
                <div class="section-title">6. ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>
                <button id="exportResult">üì• ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå</button>
            </div>

            <div id="legend" class="section" style="display: none;">
                <div class="section-title">üìä ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏µ TYPE_BUILD</div>
                <div id="legendContent"></div>
            </div>
        </div>

        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shpjs@5.0.1/dist/shp.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script>
        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î proj4 definitions
        proj4.defs("EPSG:32647", "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs");
        proj4.defs("EPSG:32648", "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs");

        let map, buildingData = null, parcelData = null, buildingLayer = null, parcelLayer = null;
        let buildingCentroidLayer = null, resultLayer = null, resultData = null;
        let selectedEPSG = 'EPSG:32647';
        let buildingCentroids = null; // ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏ã‡πâ‡∏≥

        function initMap() {
            map = L.map('map').setView([13.7563, 100.5018], 6);
            L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                attribution: '¬© Google',
                maxZoom: 20
            }).addTo(map);
        }

        function showStatus(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = 'status ' + type;
            el.textContent = message;
            el.style.display = 'block';
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            progressBar.classList.add('active');
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';
        }

        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }

        // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î
        function transformCoordinates(coords, sourceProj) {
            if (!sourceProj || sourceProj === 'EPSG:4326') return coords;
            const transform = (coord) => {
                if (Array.isArray(coord[0])) return coord.map(c => transform(c));
                const [lon, lat] = proj4(sourceProj, 'EPSG:4326', coord);
                return [lon, lat];
            };
            return transform(coords);
        }

        function transformBackToUTM(coords, targetEPSG) {
            if (!targetEPSG || targetEPSG === 'EPSG:4326') return coords;
            
            const transform = (coord) => {
                if (Array.isArray(coord[0])) return coord.map(c => transform(c));
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ coordinates ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                if (!isFinite(coord[0]) || !isFinite(coord[1])) {
                    console.warn('Invalid coordinate:', coord);
                    return [0, 0]; // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                }
                
                try {
                    const [x, y] = proj4('EPSG:4326', targetEPSG, coord);
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                    if (!isFinite(x) || !isFinite(y)) {
                        console.warn('Invalid transformed coordinate:', x, y);
                        return [0, 0];
                    }
                    
                    return [x, y];
                } catch (e) {
                    console.error('Transform error:', e, coord);
                    return [0, 0];
                }
            };
            return transform(coords);
        }

        // ‡πÇ‡∏´‡∏•‡∏î Shapefile ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö UTF-8 (‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢)
        async function loadShapefile(zipFile, selectedEPSG) {
            const zip = await JSZip.loadAsync(zipFile);
            let shpBuffer, dbfBuffer, cpgContent = null;
            
            for (let filename in zip.files) {
                const file = zip.files[filename];
                const lowerName = filename.toLowerCase();
                if (lowerName.endsWith('.shp')) {
                    shpBuffer = await file.async('arraybuffer');
                } else if (lowerName.endsWith('.dbf')) {
                    dbfBuffer = await file.async('arraybuffer');
                } else if (lowerName.endsWith('.cpg')) {
                    cpgContent = await file.async('string');
                    console.log('‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå .cpg, encoding:', cpgContent);
                }
            }
            
            if (!shpBuffer || !dbfBuffer) {
                throw new Error('‡πÑ‡∏ü‡∏•‡πå zip ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ .shp ‡πÅ‡∏•‡∏∞ .dbf');
            }
            
            // shp.js ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö UTF-8 ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
            // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå .cpg ‡∏à‡∏∞‡πÉ‡∏ä‡πâ encoding ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
            const geojson = await shp.combine([
                shp.parseShp(shpBuffer), 
                shp.parseDbf(dbfBuffer, cpgContent || 'utf-8')
            ]);

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
            if (geojson.features.length > 0) {
                console.log('‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• properties:', geojson.features[0].properties);
            }

            // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î
            if (selectedEPSG !== 'EPSG:4326') {
                geojson.features.forEach(feature => {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates, selectedEPSG);
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        feature.geometry.coordinates = feature.geometry.coordinates.map(p => transformCoordinates(p, selectedEPSG));
                    } else if (feature.geometry.type === 'Point') {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates, selectedEPSG);
                    }
                });
            }
            
            return geojson;
        }

        function getColorForType(type) {
            const colors = {
                '‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢': '#FF6B6B',
                '‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°': '#4ECDC4',
                '‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°': '#95E1D3',
                '‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏π‡∏õ‡πÇ‡∏†‡∏Ñ': '#F38181',
                '‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£': '#AA96DA',
                '‡∏®‡∏≤‡∏™‡∏ô‡∏≤': '#FCBAD3',
                '‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤': '#FFFFD2',
                '‡∏™‡∏±‡∏ô‡∏ó‡∏ô‡∏≤‡∏Å‡∏≤‡∏£': '#A8D8EA',
                '‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡∏Å‡∏£‡∏£‡∏°': '#C7CEEA',
                '‡∏Ñ‡∏°‡∏ô‡∏≤‡∏Ñ‡∏°': '#FFDAB9',
                '‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤': '#E0E0E0'
            };
            
            if (!colors[type]) {
                let hash = 0;
                for (let i = 0; i < type.length; i++) {
                    hash = type.charCodeAt(i) + ((hash << 5) - hash);
                }
                colors[type] = 'hsl(' + (hash % 360) + ', 70%, 60%)';
            }
            return colors[type];
        }

        function updateBuildingColors(typeField) {
            if (!buildingCentroidLayer || !buildingData) return;

            const types = new Set();
            buildingData.features.forEach(f => {
                const type = f.properties[typeField];
                if (type) types.add(type);
            });

            buildingCentroidLayer.eachLayer(layer => {
                const type = layer.feature.properties[typeField];
                const color = getColorForType(type);
                layer.setStyle({ 
                    color: color, 
                    fillColor: color,
                    fillOpacity: 0.7,
                    weight: 1,
                    radius: 5
                });
            });

            updateLegend(Array.from(types), typeField);
        }

        function updateLegend(types, field) {
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';
            
            types.sort();
            types.forEach(type => {
                const color = getColorForType(type);
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = '<div class="legend-color" style="background: ' + color + ';"></div><span>' + type + '</span>';
                legendContent.appendChild(item);
            });

            document.getElementById('legend').style.display = 'block';
        }

        function convertToCentroids(geojson) {
            const centroids = {
                type: 'FeatureCollection',
                features: []
            };

            geojson.features.forEach(feature => {
                if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                    const centroid = turf.centroid(feature);
                    centroid.properties = { ...feature.properties };
                    centroids.features.push(centroid);
                } else if (feature.geometry.type === 'Point') {
                    centroids.features.push(feature);
                }
            });

            return centroids;
        }

        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ö‡∏ö batch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡πâ‡∏≤‡∏á
        async function processMajorUse() {
            const areaField = document.getElementById('areaField').value;
            const typeField = document.getElementById('typeField').value;
            const classField = document.getElementById('classField').value;

            if (!areaField || !typeField || !classField) {
                showStatus('processStatus', 'error', '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô');
                return;
            }

            document.getElementById('processingLoading').classList.add('active');
            document.getElementById('processBtn').disabled = true;
            updateProgress(0);

            try {
                // ‡πÉ‡∏ä‡πâ centroids ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
                if (!buildingCentroids) {
                    buildingCentroids = convertToCentroids(buildingData);
                }

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á
                parcelData.features.forEach((feature, index) => {
                    feature.properties.parcel_id = '‡πÅ‡∏õ‡∏•‡∏á_' + (index + 1);
                });

                const results = {
                    type: 'FeatureCollection',
                    features: []
                };

                const totalParcels = parcelData.features.length;
                const batchSize = 50; // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ó‡∏µ‡∏•‡∏∞ 50 ‡πÅ‡∏õ‡∏•‡∏á
                
                // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ö‡∏ö batch
                for (let start = 0; start < totalParcels; start += batchSize) {
                    const end = Math.min(start + batchSize, totalParcels);
                    const batch = parcelData.features.slice(start, end);

                    // ‡πÉ‡∏´‡πâ browser ‡∏û‡∏±‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• batch ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                    await new Promise(resolve => setTimeout(resolve, 0));

                    for (const parcel of batch) {
                        const parcelPoly = turf.feature(parcel.geometry);
                        const buildingsInParcel = [];

                        // ‡∏´‡∏≤‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á
                        for (const building of buildingCentroids.features) {
                            const point = turf.point(building.geometry.coordinates);
                            try {
                                if (turf.booleanPointInPolygon(point, parcelPoly)) {
                                    buildingsInParcel.push(building);
                                }
                            } catch (e) {
                                // ‡∏Ç‡πâ‡∏≤‡∏° geometry ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤
                                continue;
                            }
                        }

                        // ‡∏™‡∏£‡πâ‡∏≤‡∏á properties ‡πÉ‡∏´‡∏°‡πà ‡πÇ‡∏î‡∏¢‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏ß‡∏¢ (‡∏£‡∏ß‡∏° parcel_id ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ)
                        const newProperties = { ...parcel.properties }; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡πÅ‡∏•‡∏∞ parcel_id
                        
                        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
                        newProperties.building_count = buildingsInParcel.length;

                        if (buildingsInParcel.length > 0) {
                            // major_use1
                            const typeAreaSum = {};
                            buildingsInParcel.forEach(b => {
                                const type = String(b.properties[typeField] || '');
                                const area = parseFloat(b.properties[areaField]) || 0;
                                typeAreaSum[type] = (typeAreaSum[type] || 0) + area;
                            });

                            let maxType = null;
                            let maxArea = 0;
                            for (const type in typeAreaSum) {
                                if (typeAreaSum[type] > maxArea) {
                                    maxArea = typeAreaSum[type];
                                    maxType = type;
                                }
                            }
                            newProperties.major_use1 = maxType;
                            newProperties.major_use1_area = maxArea.toFixed(2);

                            const typeDetails = [];
                            for (const type in typeAreaSum) {
                                typeDetails.push(type + ': ' + typeAreaSum[type].toFixed(2) + ' ‡∏ï‡∏£.‡∏°.');
                            }
                            newProperties.type_details = typeDetails.join('; ');

                            // major_use2: ‡∏ï‡∏≤‡∏° class priority
                            const class30Buildings = buildingsInParcel.filter(b => 
                                String(b.properties[classField]) === '30' || String(b.properties[classField]) === '30.0'
                            );
                            const class20Buildings = buildingsInParcel.filter(b => 
                                String(b.properties[classField]) === '20' || String(b.properties[classField]) === '20.0'
                            );
                            const class10Buildings = buildingsInParcel.filter(b => 
                                String(b.properties[classField]) === '10' || String(b.properties[classField]) === '10.0'
                            );

                            let targetBuildings = null;
                            let selectedClass = null;

                            // Priority: 30 > 20 > 10 > ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
                            if (class30Buildings.length > 0) {
                                targetBuildings = class30Buildings;
                                selectedClass = '30';
                            } else if (class20Buildings.length > 0) {
                                targetBuildings = class20Buildings;
                                selectedClass = '20';
                            } else if (class10Buildings.length > 0) {
                                targetBuildings = class10Buildings;
                                selectedClass = '10';
                            } else {
                                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ class 20/30/10 ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                                targetBuildings = buildingsInParcel;
                                selectedClass = '‡∏≠‡∏∑‡πà‡∏ô‡πÜ';
                            }

                            if (targetBuildings && targetBuildings.length > 0) {
                                const classTypeAreaSum = {};
                                targetBuildings.forEach(b => {
                                    const type = String(b.properties[typeField] || '');
                                    const area = parseFloat(b.properties[areaField]) || 0;
                                    classTypeAreaSum[type] = (classTypeAreaSum[type] || 0) + area;
                                });

                                let maxClassType = null;
                                let maxClassArea = 0;
                                for (const type in classTypeAreaSum) {
                                    if (classTypeAreaSum[type] > maxClassArea) {
                                        maxClassArea = classTypeAreaSum[type];
                                        maxClassType = type;
                                    }
                                }

                                newProperties.major_use2 = maxClassType;
                                newProperties.major_use2_class = selectedClass;
                                newProperties.major_use2_area = maxClassArea.toFixed(2);
                            } else {
                                newProperties.major_use2 = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
                                newProperties.major_use2_class = '-';
                                newProperties.major_use2_area = '0';
                            }
                        } else {
                            newProperties.major_use1 = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£';
                            newProperties.major_use1_area = '0';
                            newProperties.type_details = '-';
                            newProperties.major_use2 = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£';
                            newProperties.major_use2_class = '-';
                            newProperties.major_use2_area = '0';
                        }

                        results.features.push({
                            type: 'Feature',
                            geometry: parcel.geometry,
                            properties: newProperties
                        });
                    }

                    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó progress
                    updateProgress((end / totalParcels) * 100);
                }

                resultData = results;

                // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
                if (resultLayer) map.removeLayer(resultLayer);
                resultLayer = L.geoJSON(resultData, {
                    style: feature => {
                        const majorUse = feature.properties.major_use1;
                        return {
                            color: '#333',
                            weight: 2,
                            fillColor: getColorForType(majorUse),
                            fillOpacity: 0.4
                        };
                    },
                    onEachFeature: (f, l) => {
                        let popup = '<div style="font-family: Sarabun, Arial, sans-serif; font-size: 13px; line-height: 1.6;">';
                        popup += '<div style="background: #3498db; color: white; padding: 8px; margin: -10px -10px 10px -10px; font-weight: bold; border-radius: 3px 3px 0 0;">';
                        popup += 'üìã ' + (f.properties.parcel_id || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏') + '</div>';
                        
                        popup += '<div style="margin-bottom: 8px;">';
                        popup += '<strong>üè¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</strong> ' + (f.properties.building_count || 0) + ' ‡∏´‡∏•‡∏±‡∏á<br>';
                        popup += '</div>';
                        
                        popup += '<div style="background: #f8f9fa; padding: 8px; border-radius: 4px; margin-bottom: 8px;">';
                        popup += '<strong style="color: #2ecc71;">üìä ‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å 1:</strong><br>';
                        popup += '<span style="margin-left: 15px;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ' + (f.properties.major_use1 || '-') + '</span><br>';
                        popup += '<span style="margin-left: 15px;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°: ' + (f.properties.major_use1_area || '0') + ' ‡∏ï‡∏£.‡∏°.</span>';
                        popup += '</div>';
                        
                        popup += '<div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 8px;">';
                        popup += '<strong style="color: #e67e22;">üìä ‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å 2:</strong><br>';
                        popup += '<span style="margin-left: 15px;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ' + (f.properties.major_use2 || '-') + '</span><br>';
                        popup += '<span style="margin-left: 15px;">Class: ' + (f.properties.major_use2_class || '-') + '</span><br>';
                        popup += '<span style="margin-left: 15px;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°: ' + (f.properties.major_use2_area || '0') + ' ‡∏ï‡∏£.‡∏°.</span>';
                        popup += '</div>';
                        
                        if (f.properties.type_details && f.properties.type_details !== '-') {
                            popup += '<div style="border-top: 1px solid #ddd; padding-top: 8px; margin-top: 8px;">';
                            popup += '<strong>üìù ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</strong><br>';
                            popup += '<div style="margin-left: 15px; font-size: 12px;">';
                            const details = f.properties.type_details.split('; ');
                            details.forEach(detail => {
                                if (detail.trim()) {
                                    popup += '‚Ä¢ ' + detail + '<br>';
                                }
                            });
                            popup += '</div>';
                            popup += '</div>';
                        }
                        
                        popup += '</div>';
                        l.bindPopup(popup, { maxWidth: 350 });
                    }
                }).addTo(map);

                // ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
                const parcelsWithBuilding = results.features.filter(f => f.properties.building_count > 0).length;
                const summaryHtml = `
                    <div class="summary-item"><span>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</span><strong>${totalParcels}</strong></div>
                    <div class="summary-item"><span>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</span><strong>${parcelsWithBuilding}</strong></div>
                    <div class="summary-item"><span>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</span><strong>${totalParcels - parcelsWithBuilding}</strong></div>
                `;
                document.getElementById('resultSummary').innerHTML = summaryHtml;

                document.getElementById('resultSection').style.display = 'block';
                document.getElementById('exportSection').style.display = 'block';
                document.getElementById('resultLayersSection').style.display = 'block';

                showStatus('processStatus', 'success', '‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏£‡∏ß‡∏° ' + totalParcels + ' ‡πÅ‡∏õ‡∏•‡∏á');

                setupLayerToggles();

            } catch (error) {
                showStatus('processStatus', 'error', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
                console.error(error);
            } finally {
                document.getElementById('processingLoading').classList.remove('active');
                document.getElementById('processBtn').disabled = false;
                hideProgress();
            }
        }

        function setupLayerToggles() {
            const toggleBuildings = document.getElementById('toggleBuildings');
            const toggleParcels = document.getElementById('toggleParcels');
            const toggleResult = document.getElementById('toggleResult');

            const newToggleBuildings = toggleBuildings.cloneNode(true);
            const newToggleParcels = toggleParcels.cloneNode(true);
            const newToggleResult = toggleResult.cloneNode(true);
            
            toggleBuildings.parentNode.replaceChild(newToggleBuildings, toggleBuildings);
            toggleParcels.parentNode.replaceChild(newToggleParcels, toggleParcels);
            toggleResult.parentNode.replaceChild(newToggleResult, toggleResult);

            newToggleBuildings.addEventListener('change', e => {
                if (buildingCentroidLayer) {
                    if (e.target.checked) map.addLayer(buildingCentroidLayer);
                    else map.removeLayer(buildingCentroidLayer);
                }
            });

            newToggleParcels.addEventListener('change', e => {
                if (parcelLayer) {
                    if (e.target.checked) map.addLayer(parcelLayer);
                    else map.removeLayer(parcelLayer);
                }
            });

            newToggleResult.addEventListener('change', e => {
                if (resultLayer) {
                    if (e.target.checked) map.addLayer(resultLayer);
                    else map.removeLayer(resultLayer);
                }
            });
        }

        // ========== Shapefile Creation Functions (‡∏à‡∏≤‡∏Å‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ) ==========
        
        // ========== Shapefile Creation Functions ==========
        
        // ========== Shapefile Functions (from stable index.html) ==========
        
        // Validate and fix polygon geometry (less strict - keep all valid polygons)
        
        function createSHPFile(features) {
            const shapeType = 5; // Polygon
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            // Calculate bounds
            features.forEach(f => {
                const coords = f.geometry.type === 'Polygon' ? f.geometry.coordinates : f.geometry.coordinates[0];
                coords[0].forEach(([x, y]) => {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                });
            });

            const records = [];
            let fileLength = 100; // Header size

            features.forEach((feature, index) => {
                const recordHeader = new ArrayBuffer(8);
                const headerView = new DataView(recordHeader);
                headerView.setInt32(0, index + 1, false); // Record number (big-endian)
                
                const recordContent = createPolygonRecord(feature);
                headerView.setInt32(4, recordContent.byteLength / 2, false);
                records.push(recordHeader);
                records.push(recordContent);
                fileLength += 8 + recordContent.byteLength;
            });

            // Create header
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            headerView.setInt32(0, 9994, false); // File code
            headerView.setInt32(24, fileLength / 2, false); // File length (words)
            headerView.setInt32(28, 1000, true); // Version
            headerView.setInt32(32, shapeType, true); // Shape type
            headerView.setFloat64(36, minX, true);
            headerView.setFloat64(44, minY, true);
            headerView.setFloat64(52, maxX, true);
            headerView.setFloat64(60, maxY, true);

            // Combine
            const result = new Uint8Array(fileLength);
            let offset = 0;
            result.set(new Uint8Array(header), offset);
            offset += 100;
            records.forEach(record => {
                result.set(new Uint8Array(record), offset);
                offset += record.byteLength;
            });

            return result;
        }

        function createPolygonRecord(feature) {
            const coords = feature.geometry.type === 'Polygon' 
                ? feature.geometry.coordinates 
                : feature.geometry.coordinates[0];
            
            const numParts = coords.length;
            const numPoints = coords.reduce((sum, ring) => sum + ring.length, 0);
            const contentLength = 44 + (4 * numParts) + (16 * numPoints);
            
            const buffer = new ArrayBuffer(contentLength);
            const view = new DataView(buffer);
            
            view.setInt32(0, 5, true); // Polygon type
            
            // Bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            coords.forEach(ring => {
                ring.forEach(([x, y]) => {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                });
            });
            
            view.setFloat64(4, minX, true);
            view.setFloat64(12, minY, true);
            view.setFloat64(20, maxX, true);
            view.setFloat64(28, maxY, true);
            view.setInt32(36, numParts, true);
            view.setInt32(40, numPoints, true);
            
            // Parts
            let offset = 44;
            let partStart = 0;
            coords.forEach((ring, i) => {
                view.setInt32(offset, partStart, true);
                offset += 4;
                partStart += ring.length;
            });
            
            // Points
            coords.forEach(ring => {
                ring.forEach(([x, y]) => {
                    view.setFloat64(offset, x, true);
                    view.setFloat64(offset + 8, y, true);
                    offset += 16;
                });
            });
            
            return buffer;
        }

        function createSHXFile(features) {
            const numRecords = features.length;
            const fileLength = 100 + (numRecords * 8);
            const buffer = new ArrayBuffer(fileLength);
            const view = new DataView(buffer);
            
            // Header (same as SHP)
            view.setInt32(0, 9994, false);
            view.setInt32(24, fileLength / 2, false);
            view.setInt32(28, 1000, true);
            view.setInt32(32, 5, true); // Polygon
            
            // Index records
            let offset = 50; // in words
            for (let i = 0; i < numRecords; i++) {
                const feature = features[i];
                const coords = feature.geometry.type === 'Polygon' 
                    ? feature.geometry.coordinates 
                    : feature.geometry.coordinates[0];
                const numParts = coords.length;
                const numPoints = coords.reduce((sum, ring) => sum + ring.length, 0);
                const recordLength = 22 + (2 * numParts) + (8 * numPoints);
                
                view.setInt32(100 + i * 8, offset, false);
                view.setInt32(104 + i * 8, recordLength, false);
                offset += recordLength + 4;
            }
            
            return new Uint8Array(buffer);
        }

        // Convert UTF-8 string to Windows-874 (TIS-620) bytes for ArcMap
        function encodeWindows874(str) {
            const bytes = [];
            for (let i = 0; i < str.length; i++) {
                const charCode = str.charCodeAt(i);
                
                // Thai characters: U+0E01 to U+0E5B ‚Üí Windows-874: 0xA1 to 0xFB
                if (charCode >= 0x0E01 && charCode <= 0x0E5B) {
                    bytes.push(charCode - 0x0E00 + 0xA0);
                }
                // ASCII characters (0x00 - 0x7F): keep as is
                else if (charCode <= 0x7F) {
                    bytes.push(charCode);
                }
                // Other characters: use '?' as placeholder
                else {
                    bytes.push(0x3F); // '?'
                }
            }
            return new Uint8Array(bytes);
        }

        function createDBFFile(features) {
            // Auto-detect fields from properties
            const allFields = new Set();
            features.forEach(f => {
                if (f.properties) {
                    Object.keys(f.properties).forEach(key => allFields.add(key));
                }
            });
            
            const fieldMapping = {};
            const usedNames = new Set();
            
            // Create field mapping dynamically
            Array.from(allFields).forEach(key => {
                let fieldName = key.substring(0, 10).toUpperCase().replace(/[^A-Z0-9_]/g, '_');
                
                // Avoid name collision
                let counter = 1;
                let originalName = fieldName;
                while (usedNames.has(fieldName)) {
                    fieldName = originalName.substring(0, 8) + '_' + counter;
                    counter++;
                }
                usedNames.add(fieldName);
                
                // Determine field type
                const sampleValue = features.find(f => f.properties?.[key] != null)?.properties?.[key];
                let fieldType = 'C';
                let fieldLength = 254;
                let fieldDecimal = 0;
                
                if (typeof sampleValue === 'number') {
                    if (Number.isInteger(sampleValue)) {
                        fieldType = 'N';
                        fieldLength = 18;
                        fieldDecimal = 0;
                    } else {
                        fieldType = 'F';
                        fieldLength = 19;
                        fieldDecimal = 2;
                    }
                } else {
                    // For strings, calculate max length (Windows-874)
                    const maxLen = Math.max(...features.map(f => {
                        const v = f.properties?.[key];
                        if (v === null || v === undefined) return 0;
                        return encodeWindows874(String(v)).length;
                    }));
                    fieldLength = Math.min(254, Math.max(10, maxLen + 10));
                }
                
                fieldMapping[key] = {
                    name: fieldName,
                    type: fieldType,
                    length: fieldLength,
                    decimal: fieldDecimal
                };
            });

            const fields = [];
            const fieldKeys = new Set();
            
            // Collect fields
            features.forEach(f => {
                if (f.properties) {
                    Object.keys(f.properties).forEach(key => {
                        if (fieldMapping[key] && !fieldKeys.has(key)) {
                            fieldKeys.add(key);
                            fields.push({
                                ...fieldMapping[key],
                                originalName: key
                            });
                        }
                    });
                }
            });
            
            const headerLength = 32 + (fields.length * 32) + 1;
            const recordLength = fields.reduce((sum, f) => sum + f.length, 0) + 1;
            const fileLength = headerLength + (features.length * recordLength) + 1;
            
            const bytes = new Uint8Array(fileLength);
            const view = new DataView(bytes.buffer);
            
            // Header
            bytes[0] = 0x03; // dBASE III
            const now = new Date();
            bytes[1] = now.getFullYear() - 1900;
            bytes[2] = now.getMonth() + 1;
            bytes[3] = now.getDate();
            view.setUint32(4, features.length, true);
            view.setUint16(8, headerLength, true);
            view.setUint16(10, recordLength, true);
            bytes[29] = 0x7C; // Windows-874 (TIS-620) encoding for Thai - LDID = 124
            
            // Field descriptors
            let offset = 32;
            fields.forEach(field => {
                for (let i = 0; i < 11; i++) {
                    bytes[offset + i] = i < field.name.length ? field.name.charCodeAt(i) : 0;
                }
                bytes[offset + 11] = field.type.charCodeAt(0);
                bytes[offset + 16] = field.length;
                bytes[offset + 17] = field.decimal;
                offset += 32;
            });
            bytes[offset++] = 0x0D; // Field descriptor terminator
            
            // Records
            features.forEach((feature, idx) => {
                bytes[offset++] = 0x20; // Not deleted
                fields.forEach(field => {
                    const value = feature.properties?.[field.originalName];
                    
                    if (field.type === 'N' || field.type === 'F') {
                        // Numeric field - right-aligned ASCII
                        let str = '';
                        if (value !== null && value !== undefined && !isNaN(value)) {
                            const numValue = Number(value);
                            if (field.type === 'F') {
                                // Float with decimals
                                str = numValue.toFixed(field.decimal);
                            } else {
                                // Integer
                                str = Math.floor(numValue).toString();
                            }
                            // Trim if too long
                            if (str.length > field.length) {
                                str = str.substring(0, field.length);
                            }
                        }
                        // Right-align
                        str = str.padStart(field.length, ' ');
                        
                        // Write ASCII
                        for (let i = 0; i < field.length; i++) {
                            bytes[offset++] = i < str.length ? str.charCodeAt(i) : 0x20;
                        }
                    } else {
                        // Character field - Windows-874 (TIS-620) for Thai
                        if (value !== null && value !== undefined) {
                            const valueStr = String(value);
                            const valueBytes = encodeWindows874(valueStr);
                            
                            // Write Windows-874 bytes
                            let written = 0;
                            for (let i = 0; i < Math.min(field.length, valueBytes.length); i++) {
                                bytes[offset++] = valueBytes[i];
                                written++;
                            }
                            // Pad with spaces
                            for (let i = written; i < field.length; i++) {
                                bytes[offset++] = 0x20;
                            }
                        } else {
                            // Empty - pad with spaces
                            for (let i = 0; i < field.length; i++) {
                                bytes[offset++] = 0x20;
                            }
                        }
                    }
                });
            });
            bytes[offset] = 0x1A; // EOF
            
            console.log('Created', features.length, 'DBF records');
            
            return bytes;
        }

        function getPRJContent(epsg) {
            if (epsg === 'EPSG:32647') {
                return `PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]`;
            } else if (epsg === 'EPSG:32648') {
                return `PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",105.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]`;
            }
            return '';
        }

        // Export Shapefile (simplified from index.html)
        async function exportShapefile(geojson, filename) {
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å');
                return;
            }

            try {
                showStatus('processStatus', 'info', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile...');
                
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('Shapefile Export - Simple Method (from index.html)');
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('Total parcels processed:', geojson.features.length);
                
                // FILTER: ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
                const parcelsWithBuildings = geojson.features.filter(f => {
                    const buildingCount = f.properties?.building_count || 0;
                    return buildingCount > 0;
                });
                
                console.log('Parcels with buildings:', parcelsWithBuildings.length);
                console.log('Parcels without buildings (filtered out):', geojson.features.length - parcelsWithBuildings.length);
                
                if (parcelsWithBuildings.length === 0) {
                    throw new Error('‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å');
                }
                
                // Transform coordinates back to UTM (simple method - no validation)
                console.log('Transforming coordinates...');
                const utmData = {
                    type: 'FeatureCollection',
                    features: parcelsWithBuildings.map(feature => {
                        let coords = feature.geometry.coordinates;
                        if (feature.geometry.type === 'Polygon') {
                            coords = transformBackToUTM(coords, selectedEPSG);
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            coords = coords.map(p => transformBackToUTM(p, selectedEPSG));
                        }
                        return {
                            type: 'Feature',
                            geometry: { type: feature.geometry.type, coordinates: coords },
                            properties: feature.properties
                        };
                    })
                };
                
                console.log('All features transformed successfully!');
                console.log('Creating shapefile files...');

                // Create Shapefile
                const zip = new JSZip();
                const baseName = filename.replace(/\.(geojson|zip)$/i, '');
                
                // Create shapefile files (same as index.html)
                const shpFile = createSHPFile(utmData.features);
                console.log('‚úì SHP:', shpFile.length, 'bytes,', utmData.features.length, 'records');
                
                const shxFile = createSHXFile(utmData.features);
                console.log('‚úì SHX:', shxFile.length, 'bytes');
                
                const dbfFile = createDBFFile(utmData.features);
                console.log('‚úì DBF:', dbfFile.length, 'bytes');
                
                const prjContent = getPRJContent(selectedEPSG);
                console.log('‚úì PRJ: created for', selectedEPSG);
                
                // Add files to ZIP
                zip.file(`${baseName}.shp`, shpFile);
                zip.file(`${baseName}.shx`, shxFile);
                zip.file(`${baseName}.dbf`, dbfFile);
                zip.file(`${baseName}.prj`, prjContent);
                zip.file(`${baseName}.cpg`, 'Windows-874');
                
                console.log('Generating ZIP file...');
                const content = await zip.generateAsync({ type: 'blob' });
                saveAs(content, `${baseName}.zip`);
                
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('‚úÖ Export completed successfully!');
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
                console.log('üì¶ File:', baseName + '.zip');
                console.log('üìä Parcels exported:', utmData.features.length);
                console.log('üè¢ All parcels have buildings (building_count > 0)');
                console.log('üó∫Ô∏è  Coordinate system:', selectedEPSG);
                console.log('üî§ Encoding: Windows-874 (TIS-620) for ArcMap');
                console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

                showStatus('processStatus', 'success', 
                    `‚úÖ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! (${utmData.features.length} ‡πÅ‡∏õ‡∏•‡∏á)\n` +
                    `üìÅ Shapefile: ${baseName}.zip\n` +
                    `üè¢ ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô\n` +
                    `üåè Windows-874 (TIS-620) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö ArcMap\n` +
                    `‚úì ‡πÄ‡∏õ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡πÉ‡∏ô ArcMap ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏°‡∏µ error`);

            } catch (error) {
                showStatus('processStatus', 'error', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å: ' + error.message);
                console.error('Export error:', error);
            }
        }

        // Event Listeners
        document.getElementById('loadFiles').addEventListener('click', async () => {
            const buildingFiles = document.getElementById('buildingFiles').files;
            const parcelFiles = document.getElementById('parcelFiles').files;
            selectedEPSG = document.getElementById('epsgSelect').value;

            if (!buildingFiles.length || !parcelFiles.length) {
                showStatus('loadStatus', 'error', '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô');
                return;
            }

            document.getElementById('loading').classList.add('active');
            document.getElementById('loadFiles').disabled = true;

            try {
                buildingData = await loadShapefile(buildingFiles[0], selectedEPSG);
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                if (buildingData.features.length > 0) {
                    console.log('‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢):', buildingData.features[0].properties);
                }
                
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
                buildingCentroids = convertToCentroids(buildingData);
                if (buildingCentroidLayer) map.removeLayer(buildingCentroidLayer);
                buildingCentroidLayer = L.geoJSON(buildingCentroids, {
                    pointToLayer: (feature, latlng) => {
                        return L.circleMarker(latlng, {
                            radius: 5,
                            fillColor: '#FF69B4',
                            color: '#000',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.7
                        });
                    },
                    onEachFeature: (f, l) => {
                        let popup = '<div style="font-family: Sarabun, sans-serif;"><strong>‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á)</strong><br>';
                        for (let k in f.properties) {
                            popup += '<strong>' + k + ':</strong> ' + f.properties[k] + '<br>';
                        }
                        popup += '</div>';
                        l.bindPopup(popup);
                    }
                }).addTo(map);

                parcelData = await loadShapefile(parcelFiles[0], selectedEPSG);
                
                if (parcelLayer) map.removeLayer(parcelLayer);
                parcelLayer = L.geoJSON(parcelData, {
                    style: { color: '#000000', weight: 2, fillOpacity: 0 },
                    onEachFeature: (f, l) => {
                        let popup = '<div style="font-family: Sarabun, sans-serif;"><strong>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô</strong><br>';
                        for (let k in f.properties) {
                            popup += '<strong>' + k + ':</strong> ' + f.properties[k] + '<br>';
                        }
                        popup += '</div>';
                        l.bindPopup(popup);
                    }
                }).addTo(map);

                map.fitBounds(buildingCentroidLayer.getBounds().extend(parcelLayer.getBounds()));

                // ‡πÄ‡∏ï‡∏¥‡∏° field dropdown
                const fields = Object.keys(buildingData.features[0].properties);
                const areaSelect = document.getElementById('areaField');
                const typeSelect = document.getElementById('typeField');
                const classSelect = document.getElementById('classField');

                areaSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';
                typeSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';
                classSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';

                fields.forEach(field => {
                    areaSelect.add(new Option(field, field));
                    typeSelect.add(new Option(field, field));
                    classSelect.add(new Option(field, field));

                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Field ‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å BL_AREA ‡∏Å‡πà‡∏≠‡∏ô
                    if (field === 'BL_AREA') {
                        areaSelect.value = field;
                    } else if (!areaSelect.value && field.toUpperCase().includes('AREA')) {
                        areaSelect.value = field;
                    }
                    
                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö TYPE_BUILD
                    if (field === 'TYPE_BUILD' || field.toUpperCase().includes('TYPE')) {
                        typeSelect.value = field;
                    }
                    
                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö class
                    if (field.toLowerCase() === 'class') {
                        classSelect.value = field;
                    }
                });

                document.getElementById('fieldSection').style.display = 'block';
                document.getElementById('processSection').style.display = 'block';
                document.getElementById('layerControl').style.display = 'block';

                showStatus('loadStatus', 'success', 
                    '‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£: ' + buildingData.features.length + ', ‡πÅ‡∏õ‡∏•‡∏á: ' + parcelData.features.length);

                setupLayerToggles();

            } catch (error) {
                showStatus('loadStatus', 'error', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
                console.error(error);
            } finally {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loadFiles').disabled = false;
            }
        });

        document.getElementById('typeField').addEventListener('change', e => {
            if (e.target.value && buildingCentroidLayer) {
                updateBuildingColors(e.target.value);
            }
        });

        document.getElementById('processBtn').addEventListener('click', processMajorUse);

        document.getElementById('showAllLayers').addEventListener('click', () => {
            document.getElementById('toggleBuildings').checked = true;
            document.getElementById('toggleParcels').checked = true;
            if (document.getElementById('toggleResult')) {
                document.getElementById('toggleResult').checked = true;
            }
            
            if (buildingCentroidLayer) map.addLayer(buildingCentroidLayer);
            if (parcelLayer) map.addLayer(parcelLayer);
            if (resultLayer) map.addLayer(resultLayer);
        });

        document.getElementById('hideAllLayers').addEventListener('click', () => {
            document.getElementById('toggleBuildings').checked = false;
            document.getElementById('toggleParcels').checked = false;
            if (document.getElementById('toggleResult')) {
                document.getElementById('toggleResult').checked = false;
            }
            
            if (buildingCentroidLayer) map.removeLayer(buildingCentroidLayer);
            if (parcelLayer) map.removeLayer(parcelLayer);
            if (resultLayer) map.removeLayer(resultLayer);
        });

        document.getElementById('exportResult').addEventListener('click', () => {
            if (resultData) {
                exportShapefile(resultData, 'parcel_major_use');
            } else {
                alert('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å');
            }
        });

        initMap();
    </script>
    <script data-goatcounter="https://mponline.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> 
</body>
</html>
