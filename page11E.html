<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Sarabun', sans-serif; background: #f5f5f5; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 400px; background: white; padding: 20px; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        h1 { font-size: 20px; margin-bottom: 20px; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .section { margin-bottom: 25px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
        .section-title { font-weight: bold; margin-bottom: 12px; color: #2c3e50; font-size: 16px; }
        .file-input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; color: #555; font-weight: 500; }
        input[type="file"] { width: 100%; padding: 8px; border: 2px dashed #3498db; border-radius: 5px; background: white; cursor: pointer; }
        input[type="number"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: white; font-size: 14px; }
        input[type="number"]:focus { outline: none; border-color: #3498db; box-shadow: 0 0 5px rgba(52, 152, 219, 0.3); }
        select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: white; margin-bottom: 10px; }
        button { width: 100%; padding: 12px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px; transition: background 0.3s; }
        button:hover { background: #2980b9; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        #map { flex: 1; height: 100vh; }
        .status { padding: 10px; margin-top: 10px; border-radius: 5px; font-size: 13px; display: none; font-weight: 500; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        #processingProgress { background: linear-gradient(90deg, #e8f4f8 0%, #d1ecf1 100%); color: #0c5460; border-left: 4px solid #3498db; padding: 12px; font-weight: 500; border-radius: 5px; margin-top: 10px; animation: pulse 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .loading { display: none; text-align: center; padding: 10px; color: #3498db; }
        .loading.active { display: block; }
        .progress-bar { width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; overflow: hidden; margin-top: 10px; display: none; }
        .progress-bar.active { display: block; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #3498db, #2ecc71); transition: width 0.3s; text-align: center; color: white; font-size: 12px; line-height: 20px; }
        .layer-item { display: flex; align-items: center; padding: 8px; margin-bottom: 5px; background: white; border-radius: 5px; border: 1px solid #e0e0e0; transition: background 0.2s; }
        .layer-item:hover { background: #f8f9fa; }
        .layer-item input[type="checkbox"] { margin-right: 8px; cursor: pointer; width: 16px; height: 16px; }
        .layer-item label { cursor: pointer; user-select: none; flex: 1; margin: 0; }
        .legend { background: white; padding: 15px; border-radius: 5px; margin-top: 10px; max-height: 400px; overflow-y: auto; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
        .legend-color { width: 30px; height: 20px; border: 1px solid #333; margin-right: 10px; border-radius: 3px; }
        .summary-box { background: white; padding: 12px; border-radius: 5px; margin-top: 10px; }
        .summary-item { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #eee; }
        .summary-item:last-child { border-bottom: none; }
        
        #showAllLayers, #hideAllLayers {
            transition: all 0.2s;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 3px;
        }
        #showAllLayers:hover {
            background: #229954 !important;
            transform: translateY(-1px);
        }
        #hideAllLayers:hover {
            background: #c0392b !important;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üè¢ ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á</h1>

            <div class="section">
                <div class="section-title">1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô</div>
                <label>‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:</label>
                <select id="epsgSelect">
                    <option value="EPSG:32647">WGS84 UTM Zone 47N (EPSG:32647)</option>
                    <option value="EPSG:32648">WGS84 UTM Zone 48N (EPSG:32648)</option>
                </select>
            </div>

            <div class="section">
                <div class="section-title">2. ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå Shapefile (ZIP)</div>
                <div class="file-input-group">
                    <label>üìÅ ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (.zip)</label>
                    <input type="file" id="buildingFiles" accept=".zip">
                </div>
                <div class="file-input-group">
                    <label>üìÅ ‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (.zip)</label>
                    <input type="file" id="parcelFiles" accept=".zip">
                </div>
                <button id="loadFiles">‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå</button>
                <div class="loading" id="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</div>
                <div id="loadStatus"></div>
            </div>

            <div class="section" id="fieldSection" style="display: none;">
                <div class="section-title">3. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</div>
                <label>Field ‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</label>
                <select id="areaField">
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
                <label>Field ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (TYPE_BUILD):</label>
                <select id="typeField">
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
                <label>Field Class (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö major_use2):</label>
                <select id="classField">
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
            </div>

            <div class="section" id="processSection" style="display: none;">
                <div class="section-title">4. ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å</div>
                <button id="processBtn">üîÑ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á</button>
                <div class="loading" id="processingLoading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</div>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div id="processStatus"></div>
            </div>

            <div class="section" id="resultSection" style="display: none;">
                <div class="section-title">5. ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</div>
                <div class="summary-box" id="resultSummary"></div>
            </div>

            <div class="legend" id="layerControl" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px;">
                    <div style="font-weight: bold;">üóÇÔ∏è ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>
                    <div style="display: flex; gap: 5px;">
                        <button id="showAllLayers" style="padding: 4px 8px; font-size: 11px; background: #27ae60; width: auto;">‡πÄ‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                        <button id="hideAllLayers" style="padding: 4px 8px; font-size: 11px; background: #e74c3c; width: auto;">‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #555; font-size: 14px;">üìÅ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö</div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleBuildings" checked>
                        <label for="toggleBuildings">
                            <span style="color: #FF69B4; font-weight: bold;">‚ñ†</span> ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á)
                        </label>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleParcels" checked>
                        <label for="toggleParcels">
                            <span style="color: #000; font-weight: bold;">‚ñ†</span> ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô
                        </label>
                    </div>
                </div>

                <div id="resultLayersSection" style="display: none;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #555; font-size: 14px;">üìä ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå</div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleResult" checked>
                        <label for="toggleResult">
                            <span style="color: #4ECDC4; font-weight: bold;">‚ñ†</span> ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå)
                        </label>
                    </div>
                </div>
            </div>

            <div class="section" id="exportSection" style="display: none;">
                <div class="section-title">6. ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>
                <button id="exportResult">üì• ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå</button>
            </div>

            <div id="legend" class="section" style="display: none;">
                <div class="section-title">üìä ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏µ TYPE_BUILD</div>
                <div id="legendContent"></div>
            </div>
        </div>

        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shpjs@5.0.1/dist/shp.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script>
        // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î proj4 definitions
        proj4.defs("EPSG:32647", "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs");
        proj4.defs("EPSG:32648", "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs");

        let map, buildingData = null, parcelData = null, buildingLayer = null, parcelLayer = null;
        let buildingCentroidLayer = null, resultLayer = null, resultData = null;
        let selectedEPSG = 'EPSG:32647';
        let buildingCentroids = null; // ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ß‡πâ‡πÉ‡∏ä‡πâ‡∏ã‡πâ‡∏≥

        function initMap() {
            map = L.map('map').setView([13.7563, 100.5018], 6);
            L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                attribution: '¬© Google',
                maxZoom: 20
            }).addTo(map);
        }

        function showStatus(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = 'status ' + type;
            el.textContent = message;
            el.style.display = 'block';
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            progressBar.classList.add('active');
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';
        }

        function hideProgress() {
            document.getElementById('progressBar').classList.remove('active');
        }

        // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î
        function transformCoordinates(coords, sourceProj) {
            if (!sourceProj || sourceProj === 'EPSG:4326') return coords;
            const transform = (coord) => {
                if (Array.isArray(coord[0])) return coord.map(c => transform(c));
                const [lon, lat] = proj4(sourceProj, 'EPSG:4326', coord);
                return [lon, lat];
            };
            return transform(coords);
        }

        function transformBackToUTM(coords, targetEPSG) {
            if (!targetEPSG || targetEPSG === 'EPSG:4326') return coords;
            
            const transform = (coord) => {
                if (Array.isArray(coord[0])) return coord.map(c => transform(c));
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ coordinates ‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                if (!isFinite(coord[0]) || !isFinite(coord[1])) {
                    console.warn('Invalid coordinate:', coord);
                    return [0, 0]; // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
                }
                
                try {
                    const [x, y] = proj4('EPSG:4326', targetEPSG, coord);
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                    if (!isFinite(x) || !isFinite(y)) {
                        console.warn('Invalid transformed coordinate:', x, y);
                        return [0, 0];
                    }
                    
                    return [x, y];
                } catch (e) {
                    console.error('Transform error:', e, coord);
                    return [0, 0];
                }
            };
            return transform(coords);
        }

        // ‡πÇ‡∏´‡∏•‡∏î Shapefile ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö UTF-8 (‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢)
        async function loadShapefile(zipFile, selectedEPSG) {
            const zip = await JSZip.loadAsync(zipFile);
            let shpBuffer, dbfBuffer, cpgContent = null;
            
            for (let filename in zip.files) {
                const file = zip.files[filename];
                const lowerName = filename.toLowerCase();
                if (lowerName.endsWith('.shp')) {
                    shpBuffer = await file.async('arraybuffer');
                } else if (lowerName.endsWith('.dbf')) {
                    dbfBuffer = await file.async('arraybuffer');
                } else if (lowerName.endsWith('.cpg')) {
                    cpgContent = await file.async('string');
                    console.log('‡∏û‡∏ö‡πÑ‡∏ü‡∏•‡πå .cpg, encoding:', cpgContent);
                }
            }
            
            if (!shpBuffer || !dbfBuffer) {
                throw new Error('‡πÑ‡∏ü‡∏•‡πå zip ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ .shp ‡πÅ‡∏•‡∏∞ .dbf');
            }
            
            // shp.js ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö UTF-8 ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
            // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå .cpg ‡∏à‡∏∞‡πÉ‡∏ä‡πâ encoding ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
            const geojson = await shp.combine([
                shp.parseShp(shpBuffer), 
                shp.parseDbf(dbfBuffer, cpgContent || 'utf-8')
            ]);

            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á
            if (geojson.features.length > 0) {
                console.log('‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• properties:', geojson.features[0].properties);
            }

            // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î
            if (selectedEPSG !== 'EPSG:4326') {
                geojson.features.forEach(feature => {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates, selectedEPSG);
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        feature.geometry.coordinates = feature.geometry.coordinates.map(p => transformCoordinates(p, selectedEPSG));
                    } else if (feature.geometry.type === 'Point') {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates, selectedEPSG);
                    }
                });
            }
            
            return geojson;
        }

        function getColorForType(type) {
            const colors = {
                '‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢': '#FF6B6B',
                '‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°': '#4ECDC4',
                '‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°': '#95E1D3',
                '‡∏™‡∏≤‡∏ò‡∏≤‡∏£‡∏ì‡∏π‡∏õ‡πÇ‡∏†‡∏Ñ': '#F38181',
                '‡∏£‡∏≤‡∏ä‡∏Å‡∏≤‡∏£': '#AA96DA',
                '‡∏®‡∏≤‡∏™‡∏ô‡∏≤': '#FCBAD3',
                '‡∏Å‡∏≤‡∏£‡∏®‡∏∂‡∏Å‡∏©‡∏≤': '#FFFFD2',
                '‡∏™‡∏±‡∏ô‡∏ó‡∏ô‡∏≤‡∏Å‡∏≤‡∏£': '#A8D8EA',
                '‡πÄ‡∏Å‡∏©‡∏ï‡∏£‡∏Å‡∏£‡∏£‡∏°': '#C7CEEA',
                '‡∏Ñ‡∏°‡∏ô‡∏≤‡∏Ñ‡∏°': '#FFDAB9',
                '‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏õ‡∏•‡πà‡∏≤': '#E0E0E0'
            };
            
            if (!colors[type]) {
                let hash = 0;
                for (let i = 0; i < type.length; i++) {
                    hash = type.charCodeAt(i) + ((hash << 5) - hash);
                }
                colors[type] = 'hsl(' + (hash % 360) + ', 70%, 60%)';
            }
            return colors[type];
        }

        function updateBuildingColors(typeField) {
            if (!buildingCentroidLayer || !buildingData) return;

            const types = new Set();
            buildingData.features.forEach(f => {
                const type = f.properties[typeField];
                if (type) types.add(type);
            });

            buildingCentroidLayer.eachLayer(layer => {
                const type = layer.feature.properties[typeField];
                const color = getColorForType(type);
                layer.setStyle({ 
                    color: color, 
                    fillColor: color,
                    fillOpacity: 0.7,
                    weight: 1,
                    radius: 5
                });
            });

            updateLegend(Array.from(types), typeField);
        }

        function updateLegend(types, field) {
            const legendContent = document.getElementById('legendContent');
            legendContent.innerHTML = '';
            
            types.sort();
            types.forEach(type => {
                const color = getColorForType(type);
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = '<div class="legend-color" style="background: ' + color + ';"></div><span>' + type + '</span>';
                legendContent.appendChild(item);
            });

            document.getElementById('legend').style.display = 'block';
        }

        function convertToCentroids(geojson) {
            const centroids = {
                type: 'FeatureCollection',
                features: []
            };

            geojson.features.forEach(feature => {
                if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
                    const centroid = turf.centroid(feature);
                    centroid.properties = { ...feature.properties };
                    centroids.features.push(centroid);
                } else if (feature.geometry.type === 'Point') {
                    centroids.features.push(feature);
                }
            });

            return centroids;
        }

        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ö‡∏ö batch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡πâ‡∏≤‡∏á
        async function processMajorUse() {
            const areaField = document.getElementById('areaField').value;
            const typeField = document.getElementById('typeField').value;
            const classField = document.getElementById('classField').value;

            if (!areaField || !typeField || !classField) {
                showStatus('processStatus', 'error', '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô');
                return;
            }

            document.getElementById('processingLoading').classList.add('active');
            document.getElementById('processBtn').disabled = true;
            updateProgress(0);

            try {
                // ‡πÉ‡∏ä‡πâ centroids ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ‡πÅ‡∏•‡πâ‡∏ß
                if (!buildingCentroids) {
                    buildingCentroids = convertToCentroids(buildingData);
                }

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÅ‡∏õ‡∏•‡∏á
                parcelData.features.forEach((feature, index) => {
                    feature.properties.parcel_id = '‡πÅ‡∏õ‡∏•‡∏á_' + (index + 1);
                });

                const results = {
                    type: 'FeatureCollection',
                    features: []
                };

                const totalParcels = parcelData.features.length;
                const batchSize = 50; // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ó‡∏µ‡∏•‡∏∞ 50 ‡πÅ‡∏õ‡∏•‡∏á
                
                // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ö‡∏ö batch
                for (let start = 0; start < totalParcels; start += batchSize) {
                    const end = Math.min(start + batchSize, totalParcels);
                    const batch = parcelData.features.slice(start, end);

                    // ‡πÉ‡∏´‡πâ browser ‡∏û‡∏±‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• batch ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                    await new Promise(resolve => setTimeout(resolve, 0));

                    for (const parcel of batch) {
                        const parcelPoly = turf.feature(parcel.geometry);
                        const buildingsInParcel = [];

                        // ‡∏´‡∏≤‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á
                        for (const building of buildingCentroids.features) {
                            const point = turf.point(building.geometry.coordinates);
                            try {
                                if (turf.booleanPointInPolygon(point, parcelPoly)) {
                                    buildingsInParcel.push(building);
                                }
                            } catch (e) {
                                // ‡∏Ç‡πâ‡∏≤‡∏° geometry ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤
                                continue;
                            }
                        }

                        // ‡∏™‡∏£‡πâ‡∏≤‡∏á properties ‡πÉ‡∏´‡∏°‡πà ‡πÇ‡∏î‡∏¢‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏ß‡∏¢ (‡∏£‡∏ß‡∏° parcel_id ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ß‡πâ)
                        const newProperties = { ...parcel.properties }; // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡πÅ‡∏•‡∏∞ parcel_id
                        
                        // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
                        newProperties.building_count = buildingsInParcel.length;

                        if (buildingsInParcel.length > 0) {
                            // major_use1
                            const typeAreaSum = {};
                            buildingsInParcel.forEach(b => {
                                const type = String(b.properties[typeField] || '');
                                const area = parseFloat(b.properties[areaField]) || 0;
                                typeAreaSum[type] = (typeAreaSum[type] || 0) + area;
                            });

                            let maxType = null;
                            let maxArea = 0;
                            for (const type in typeAreaSum) {
                                if (typeAreaSum[type] > maxArea) {
                                    maxArea = typeAreaSum[type];
                                    maxType = type;
                                }
                            }
                            newProperties.major_use1 = maxType;
                            newProperties.major_use1_area = maxArea.toFixed(2);

                            const typeDetails = [];
                            for (const type in typeAreaSum) {
                                typeDetails.push(type + ': ' + typeAreaSum[type].toFixed(2) + ' ‡∏ï‡∏£.‡∏°.');
                            }
                            newProperties.type_details = typeDetails.join('; ');

                            // major_use2: ‡∏ï‡∏≤‡∏° class priority
                            const class30Buildings = buildingsInParcel.filter(b => 
                                String(b.properties[classField]) === '30' || String(b.properties[classField]) === '30.0'
                            );
                            const class20Buildings = buildingsInParcel.filter(b => 
                                String(b.properties[classField]) === '20' || String(b.properties[classField]) === '20.0'
                            );
                            const class10Buildings = buildingsInParcel.filter(b => 
                                String(b.properties[classField]) === '10' || String(b.properties[classField]) === '10.0'
                            );

                            let targetBuildings = null;
                            let selectedClass = null;

                            // Priority: 30 > 20 > 10 > ‡∏≠‡∏∑‡πà‡∏ô‡πÜ
                            if (class30Buildings.length > 0) {
                                targetBuildings = class30Buildings;
                                selectedClass = '30';
                            } else if (class20Buildings.length > 0) {
                                targetBuildings = class20Buildings;
                                selectedClass = '20';
                            } else if (class10Buildings.length > 0) {
                                targetBuildings = class10Buildings;
                                selectedClass = '10';
                            } else {
                                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ class 20/30/10 ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                                targetBuildings = buildingsInParcel;
                                selectedClass = '‡∏≠‡∏∑‡πà‡∏ô‡πÜ';
                            }

                            if (targetBuildings && targetBuildings.length > 0) {
                                const classTypeAreaSum = {};
                                targetBuildings.forEach(b => {
                                    const type = String(b.properties[typeField] || '');
                                    const area = parseFloat(b.properties[areaField]) || 0;
                                    classTypeAreaSum[type] = (classTypeAreaSum[type] || 0) + area;
                                });

                                let maxClassType = null;
                                let maxClassArea = 0;
                                for (const type in classTypeAreaSum) {
                                    if (classTypeAreaSum[type] > maxClassArea) {
                                        maxClassArea = classTypeAreaSum[type];
                                        maxClassType = type;
                                    }
                                }

                                newProperties.major_use2 = maxClassType;
                                newProperties.major_use2_class = selectedClass;
                                newProperties.major_use2_area = maxClassArea.toFixed(2);
                            } else {
                                newProperties.major_use2 = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•';
                                newProperties.major_use2_class = '-';
                                newProperties.major_use2_area = '0';
                            }
                        } else {
                            newProperties.major_use1 = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£';
                            newProperties.major_use1_area = '0';
                            newProperties.type_details = '-';
                            newProperties.major_use2 = '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£';
                            newProperties.major_use2_class = '-';
                            newProperties.major_use2_area = '0';
                        }

                        results.features.push({
                            type: 'Feature',
                            geometry: parcel.geometry,
                            properties: newProperties
                        });
                    }

                    // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó progress
                    updateProgress((end / totalParcels) * 100);
                }

                resultData = results;

                // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà
                if (resultLayer) map.removeLayer(resultLayer);
                resultLayer = L.geoJSON(resultData, {
                    style: feature => {
                        const majorUse = feature.properties.major_use1;
                        return {
                            color: '#333',
                            weight: 2,
                            fillColor: getColorForType(majorUse),
                            fillOpacity: 0.4
                        };
                    },
                    onEachFeature: (f, l) => {
                        let popup = '<div style="font-family: Sarabun, Arial, sans-serif; font-size: 13px; line-height: 1.6;">';
                        popup += '<div style="background: #3498db; color: white; padding: 8px; margin: -10px -10px 10px -10px; font-weight: bold; border-radius: 3px 3px 0 0;">';
                        popup += 'üìã ' + (f.properties.parcel_id || '‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏') + '</div>';
                        
                        popup += '<div style="margin-bottom: 8px;">';
                        popup += '<strong>üè¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</strong> ' + (f.properties.building_count || 0) + ' ‡∏´‡∏•‡∏±‡∏á<br>';
                        popup += '</div>';
                        
                        popup += '<div style="background: #f8f9fa; padding: 8px; border-radius: 4px; margin-bottom: 8px;">';
                        popup += '<strong style="color: #2ecc71;">üìä ‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å 1:</strong><br>';
                        popup += '<span style="margin-left: 15px;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ' + (f.properties.major_use1 || '-') + '</span><br>';
                        popup += '<span style="margin-left: 15px;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°: ' + (f.properties.major_use1_area || '0') + ' ‡∏ï‡∏£.‡∏°.</span>';
                        popup += '</div>';
                        
                        popup += '<div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 8px;">';
                        popup += '<strong style="color: #e67e22;">üìä ‡∏Å‡∏¥‡∏à‡∏Å‡∏≤‡∏£‡∏´‡∏•‡∏±‡∏Å 2:</strong><br>';
                        popup += '<span style="margin-left: 15px;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó: ' + (f.properties.major_use2 || '-') + '</span><br>';
                        popup += '<span style="margin-left: 15px;">Class: ' + (f.properties.major_use2_class || '-') + '</span><br>';
                        popup += '<span style="margin-left: 15px;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏£‡∏ß‡∏°: ' + (f.properties.major_use2_area || '0') + ' ‡∏ï‡∏£.‡∏°.</span>';
                        popup += '</div>';
                        
                        if (f.properties.type_details && f.properties.type_details !== '-') {
                            popup += '<div style="border-top: 1px solid #ddd; padding-top: 8px; margin-top: 8px;">';
                            popup += '<strong>üìù ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</strong><br>';
                            popup += '<div style="margin-left: 15px; font-size: 12px;">';
                            const details = f.properties.type_details.split('; ');
                            details.forEach(detail => {
                                if (detail.trim()) {
                                    popup += '‚Ä¢ ' + detail + '<br>';
                                }
                            });
                            popup += '</div>';
                            popup += '</div>';
                        }
                        
                        popup += '</div>';
                        l.bindPopup(popup, { maxWidth: 350 });
                    }
                }).addTo(map);

                // ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•
                const parcelsWithBuilding = results.features.filter(f => f.properties.building_count > 0).length;
                const summaryHtml = `
                    <div class="summary-item"><span>‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:</span><strong>${totalParcels}</strong></div>
                    <div class="summary-item"><span>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</span><strong>${parcelsWithBuilding}</strong></div>
                    <div class="summary-item"><span>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</span><strong>${totalParcels - parcelsWithBuilding}</strong></div>
                `;
                document.getElementById('resultSummary').innerHTML = summaryHtml;

                document.getElementById('resultSection').style.display = 'block';
                document.getElementById('exportSection').style.display = 'block';
                document.getElementById('resultLayersSection').style.display = 'block';

                showStatus('processStatus', 'success', '‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏£‡∏ß‡∏° ' + totalParcels + ' ‡πÅ‡∏õ‡∏•‡∏á');

                setupLayerToggles();

            } catch (error) {
                showStatus('processStatus', 'error', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
                console.error(error);
            } finally {
                document.getElementById('processingLoading').classList.remove('active');
                document.getElementById('processBtn').disabled = false;
                hideProgress();
            }
        }

        function setupLayerToggles() {
            const toggleBuildings = document.getElementById('toggleBuildings');
            const toggleParcels = document.getElementById('toggleParcels');
            const toggleResult = document.getElementById('toggleResult');

            const newToggleBuildings = toggleBuildings.cloneNode(true);
            const newToggleParcels = toggleParcels.cloneNode(true);
            const newToggleResult = toggleResult.cloneNode(true);
            
            toggleBuildings.parentNode.replaceChild(newToggleBuildings, toggleBuildings);
            toggleParcels.parentNode.replaceChild(newToggleParcels, toggleParcels);
            toggleResult.parentNode.replaceChild(newToggleResult, toggleResult);

            newToggleBuildings.addEventListener('change', e => {
                if (buildingCentroidLayer) {
                    if (e.target.checked) map.addLayer(buildingCentroidLayer);
                    else map.removeLayer(buildingCentroidLayer);
                }
            });

            newToggleParcels.addEventListener('change', e => {
                if (parcelLayer) {
                    if (e.target.checked) map.addLayer(parcelLayer);
                    else map.removeLayer(parcelLayer);
                }
            });

            newToggleResult.addEventListener('change', e => {
                if (resultLayer) {
                    if (e.target.checked) map.addLayer(resultLayer);
                    else map.removeLayer(resultLayer);
                }
            });
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡∏™‡∏£‡πâ‡∏≤‡∏á Shapefile components (‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ö‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö)
        
        function createShapefileFromGeoJSON(geojson) {
            const features = geojson.features;
            const records = [];
            let shpLength = 100;
            
            console.log('Creating shapefile from', features.length, 'features');
            
            for (let featureIndex = 0; featureIndex < features.length; featureIndex++) {
                const feature = features[featureIndex];
                
                if (!feature.geometry || !feature.geometry.coordinates) {
                    console.warn('Skip feature', featureIndex, 'without geometry');
                    continue;
                }
                
                try {
                    // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö MultiPolygon ‡πÄ‡∏≠‡∏≤‡πÅ‡∏Ñ‡πà polygon ‡πÅ‡∏£‡∏Å (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö)
                    const coords = feature.geometry.type === 'Polygon' 
                        ? feature.geometry.coordinates 
                        : feature.geometry.coordinates[0];
                    
                    if (!coords || !Array.isArray(coords)) {
                        console.warn('Invalid coords for feature', featureIndex);
                        continue;
                    }
                    
                    let numPoints = 0;
                    let parts = [];
                    let points = [];
                    
                    // ‡πÅ‡∏ï‡πà‡∏•‡∏∞ ring
                    for (let i = 0; i < coords.length; i++) {
                        parts.push(numPoints);
                        const ring = coords[i];
                        
                        if (!Array.isArray(ring)) {
                            console.warn('Invalid ring', i, 'for feature', featureIndex);
                            continue;
                        }
                        
                        for (const point of ring) {
                            if (Array.isArray(point) && point.length >= 2) {
                                points.push(point[0], point[1]);
                                numPoints++;
                            }
                        }
                    }
                    
                    if (numPoints === 0) {
                        console.warn('Feature', featureIndex, 'has no valid points');
                        continue;
                    }
                    
                    const recordLength = 44 + (4 * parts.length) + (16 * numPoints);
                    records.push({
                        parts: new Int32Array(parts),
                        points: new Float64Array(points),
                        numParts: parts.length,
                        numPoints: numPoints,
                        recordLength: recordLength
                    });
                    shpLength += 8 + recordLength;
                    
                } catch (error) {
                    console.error('Error processing feature', featureIndex, ':', error);
                    continue;
                }
            }
            
            if (records.length === 0) {
                throw new Error('No valid records to write');
            }
            
            console.log('Created', records.length, 'records for shapefile');
            
            const shpBuffer = new ArrayBuffer(shpLength);
            const shpView = new DataView(shpBuffer);
            
            shpView.setInt32(0, 9994, false);
            shpView.setInt32(24, shpLength / 2, false);
            shpView.setInt32(28, 1000, true);
            shpView.setInt32(32, 5, true);
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const record of records) {
                for (let i = 0; i < record.points.length; i += 2) {
                    const x = record.points[i];
                    const y = record.points[i + 1];
                    if (isFinite(x) && isFinite(y)) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            
            shpView.setFloat64(36, minX, true);
            shpView.setFloat64(44, minY, true);
            shpView.setFloat64(52, maxX, true);
            shpView.setFloat64(60, maxY, true);
            
            let offset = 100;
            for (let i = 0; i < records.length; i++) {
                const record = records[i];
                shpView.setInt32(offset, i + 1, false);
                shpView.setInt32(offset + 4, record.recordLength / 2, false);
                shpView.setInt32(offset + 8, 5, true);
                
                let recMinX = Infinity, recMinY = Infinity, recMaxX = -Infinity, recMaxY = -Infinity;
                for (let j = 0; j < record.points.length; j += 2) {
                    const x = record.points[j];
                    const y = record.points[j + 1];
                    if (isFinite(x) && isFinite(y)) {
                        if (x < recMinX) recMinX = x;
                        if (x > recMaxX) recMaxX = x;
                        if (y < recMinY) recMinY = y;
                        if (y > recMaxY) recMaxY = y;
                    }
                }
                
                shpView.setFloat64(offset + 12, recMinX, true);
                shpView.setFloat64(offset + 20, recMinY, true);
                shpView.setFloat64(offset + 28, recMaxX, true);
                shpView.setFloat64(offset + 36, recMaxY, true);
                shpView.setInt32(offset + 44, record.numParts, true);
                shpView.setInt32(offset + 48, record.numPoints, true);
                
                let pos = offset + 52;
                for (let j = 0; j < record.numParts; j++) {
                    shpView.setInt32(pos, record.parts[j], true);
                    pos += 4;
                }
                for (let j = 0; j < record.points.length; j++) {
                    shpView.setFloat64(pos, record.points[j], true);
                    pos += 8;
                }
                
                offset += 8 + record.recordLength;
            }
            
            return new Uint8Array(shpBuffer);
        }
        
        function createShxFromGeoJSON(geojson) {
            const features = geojson.features;
            const shxLength = 100 + (features.length * 8);
            const shxBuffer = new ArrayBuffer(shxLength);
            const shxView = new DataView(shxBuffer);
            
            shxView.setInt32(0, 9994, false);
            shxView.setInt32(24, shxLength / 2, false);
            shxView.setInt32(28, 1000, true);
            shxView.setInt32(32, 5, true);
            
            let offset = 50;
            let pos = 100;
            
            for (const feature of features) {
                if (!feature.geometry || !feature.geometry.coordinates) {
                    console.warn('Skip feature without geometry in SHX');
                    continue;
                }
                
                // ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô createShapefileFromGeoJSON - ‡πÄ‡∏≠‡∏≤‡πÅ‡∏Ñ‡πà polygon ‡πÅ‡∏£‡∏Å‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô MultiPolygon
                const coords = feature.geometry.type === 'Polygon' 
                    ? feature.geometry.coordinates 
                    : feature.geometry.coordinates[0];
                
                if (!coords || !Array.isArray(coords)) {
                    continue;
                }
                
                let numPoints = 0;
                const numParts = coords.length;
                
                for (const ring of coords) {
                    if (Array.isArray(ring)) {
                        numPoints += ring.length;
                    }
                }
                
                const recordLength = 44 + (4 * numParts) + (16 * numPoints);
                shxView.setInt32(pos, offset, false);
                shxView.setInt32(pos + 4, recordLength / 2, false);
                pos += 8;
                offset += 4 + recordLength / 2;
            }
            
            return new Uint8Array(shxBuffer);
        }
        
        function createDbfFromGeoJSON(geojson) {
            const features = geojson.features;
            if (features.length === 0) return new Uint8Array(0);
            
            const props = features[0].properties;
            const fields = [];
            const encoder = new TextEncoder();
            
            for (const key in props) {
                const maxLen = Math.max(...features.map(f => {
                    const v = f.properties[key];
                    if (v === null || v === undefined) return 0;
                    return encoder.encode(String(v)).length;
                }));
                
                const fieldLength = Math.min(254, Math.max(10, maxLen + 5));
                
                fields.push({
                    name: key.substring(0, 10).toUpperCase(),
                    type: 'C',
                    length: fieldLength,
                    decimal: 0
                });
            }
            
            const headerLength = 32 + (fields.length * 32) + 1;
            let recordLength = 1;
            for (const field of fields) {
                recordLength += field.length;
            }
            
            const fileSize = headerLength + (features.length * recordLength) + 1;
            const buffer = new ArrayBuffer(fileSize);
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);
            
            view.setUint8(0, 0x03);
            const now = new Date();
            view.setUint8(1, now.getFullYear() - 1900);
            view.setUint8(2, now.getMonth() + 1);
            view.setUint8(3, now.getDate());
            view.setUint32(4, features.length, true);
            view.setUint16(8, headerLength, true);
            view.setUint16(10, recordLength, true);
            
            let pos = 32;
            for (const field of fields) {
                const nameBytes = encoder.encode(field.name);
                for (let i = 0; i < Math.min(11, nameBytes.length); i++) {
                    bytes[pos + i] = nameBytes[i];
                }
                bytes[pos + 11] = field.type.charCodeAt(0);
                view.setUint8(pos + 16, field.length);
                view.setUint8(pos + 17, field.decimal);
                pos += 32;
            }
            
            bytes[pos] = 0x0D;
            pos++;
            
            for (const feature of features) {
                bytes[pos] = 0x20;
                pos++;
                
                for (const field of fields) {
                    const value = feature.properties[field.name] || feature.properties[field.name.toLowerCase()] || '';
                    const valueStr = String(value);
                    const valueBytes = encoder.encode(valueStr);
                    
                    let written = 0;
                    for (let i = 0; i < Math.min(field.length, valueBytes.length); i++) {
                        bytes[pos + i] = valueBytes[i];
                        written++;
                    }
                    for (let i = written; i < field.length; i++) {
                        bytes[pos + i] = 0x20;
                    }
                    pos += field.length;
                }
            }
            
            bytes[pos] = 0x1A;
            
            return bytes;
        }
        
        function createPrjContent(epsg) {
            if (epsg === 'EPSG:32647') {
                return `PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",99.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]`;
            } else if (epsg === 'EPSG:32648') {
                return `PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",105.0],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]`;
            }
            return '';
        }

        // ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile (GeoJSON -> Shapefile)
        async function exportShapefile(geojson, filename) {
            if (!geojson || !geojson.features || geojson.features.length === 0) {
                alert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å');
                return;
            }

            try {
                showStatus('processStatus', 'info', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...');

                // ========================================
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏™‡∏£‡πâ‡∏≤‡∏á GeoJSON ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô UTM
                // ========================================
                
                console.log('‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏™‡∏£‡πâ‡∏≤‡∏á GeoJSON ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å...');
                
                const utmGeoJSON = {
                    type: 'FeatureCollection',
                    features: []
                };

                for (const feature of geojson.features) {
                    if (!feature.geometry || !feature.geometry.coordinates) {
                        console.warn('Skip feature without geometry');
                        continue;
                    }

                    try {
                        const transformedCoords = transformBackToUTM(feature.geometry.coordinates, selectedEPSG);
                        
                        utmGeoJSON.features.push({
                            type: 'Feature',
                            properties: { ...feature.properties }, // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏£‡∏ß‡∏°‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢
                            geometry: {
                                type: feature.geometry.type,
                                coordinates: transformedCoords
                            }
                        });
                    } catch (e) {
                        console.error('Transform error for feature:', e);
                        continue;
                    }
                }

                if (utmGeoJSON.features.length === 0) {
                    throw new Error('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏î‡πâ');
                }

                console.log('‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á GeoJSON ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:', utmGeoJSON.features.length, 'features');

                // ========================================
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡πÅ‡∏õ‡∏•‡∏á GeoJSON ‡πÄ‡∏õ‡πá‡∏ô Shapefile
                // ========================================
                
                showStatus('processStatus', 'info', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á GeoJSON ‡πÄ‡∏õ‡πá‡∏ô Shapefile...');
                console.log('‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡πÅ‡∏õ‡∏•‡∏á GeoJSON ‡πÄ‡∏õ‡πá‡∏ô Shapefile...');
                
                // ‡∏¢‡πà‡∏≠‡∏ä‡∏∑‡πà‡∏≠‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö DBF (‡∏à‡∏≥‡∏Å‡∏±‡∏î 10 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£)
                const shpGeoJSON = {
                    type: 'FeatureCollection',
                    features: utmGeoJSON.features.map(feature => {
                        const newProps = {};
                        
                        for (const key in feature.properties) {
                            let shortKey = key;
                            
                            if (key.length > 10) {
                                const predefinedMapping = {
                                    'parcel_id': 'PARC_ID',
                                    'building_count': 'BLDG_CNT',
                                    'major_use1': 'MAJOR_US1',
                                    'major_use1_area': 'USE1_AREA',
                                    'major_use2': 'MAJOR_US2',
                                    'major_use2_class': 'USE2_CLS',
                                    'major_use2_area': 'USE2_AREA',
                                    'type_details': 'TYPE_DTL'
                                };
                                
                                if (predefinedMapping[key]) {
                                    shortKey = predefinedMapping[key];
                                } else {
                                    shortKey = key.substring(0, 10).replace(/[^a-zA-Z0-9_]/g, '_').toUpperCase();
                                }
                            }
                            
                            // ‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢
                            const value = feature.properties[key];
                            if (value !== null && value !== undefined) {
                                newProps[shortKey] = String(value);
                            } else {
                                newProps[shortKey] = '';
                            }
                        }

                        return {
                            type: 'Feature',
                            properties: newProps,
                            geometry: feature.geometry
                        };
                    })
                };

                console.log('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .shp, .shx, .dbf, .prj...');
                
                const shpData = createShapefileFromGeoJSON(shpGeoJSON);
                const shxData = createShxFromGeoJSON(shpGeoJSON);
                const dbfData = createDbfFromGeoJSON(shpGeoJSON);
                const prjContent = createPrjContent(selectedEPSG);
                
                // ========================================
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏™‡∏£‡πâ‡∏≤‡∏á ZIP ‡πÑ‡∏ü‡∏•‡πå
                // ========================================
                
                console.log('‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå ZIP...');
                
                const zip = new JSZip();
                zip.file(filename + '.shp', shpData);
                zip.file(filename + '.shx', shxData);
                zip.file(filename + '.dbf', dbfData);
                zip.file(filename + '.prj', prjContent);
                zip.file(filename + '.cpg', 'UTF-8'); // ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢!
                
                // ========================================
                // ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 4: ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Shapefile
                // ========================================
                
                console.log('‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 4: ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î...');
                const content = await zip.generateAsync({ type: 'blob' });
                saveAs(content, filename + '.zip');

                console.log('‚úÖ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!');

                showStatus('processStatus', 'success', 
                    '‚úÖ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! (' + utmGeoJSON.features.length + ' ‡πÅ‡∏õ‡∏•‡∏á)\n' +
                    'üìÅ Shapefile: ' + filename + '.zip\n' +
                    'üåè ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ UTF-8');

            } catch (error) {
                showStatus('processStatus', 'error', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å: ' + error.message);
                console.error('Export error:', error);
            }
        }

        // Event Listeners
        document.getElementById('loadFiles').addEventListener('click', async () => {
            const buildingFiles = document.getElementById('buildingFiles').files;
            const parcelFiles = document.getElementById('parcelFiles').files;
            selectedEPSG = document.getElementById('epsgSelect').value;

            if (!buildingFiles.length || !parcelFiles.length) {
                showStatus('loadStatus', 'error', '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô');
                return;
            }

            document.getElementById('loading').classList.add('active');
            document.getElementById('loadFiles').disabled = true;

            try {
                buildingData = await loadShapefile(buildingFiles[0], selectedEPSG);
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                if (buildingData.features.length > 0) {
                    console.log('‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢):', buildingData.features[0].properties);
                }
                
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
                buildingCentroids = convertToCentroids(buildingData);
                if (buildingCentroidLayer) map.removeLayer(buildingCentroidLayer);
                buildingCentroidLayer = L.geoJSON(buildingCentroids, {
                    pointToLayer: (feature, latlng) => {
                        return L.circleMarker(latlng, {
                            radius: 5,
                            fillColor: '#FF69B4',
                            color: '#000',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.7
                        });
                    },
                    onEachFeature: (f, l) => {
                        let popup = '<div style="font-family: Sarabun, sans-serif;"><strong>‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏à‡∏∏‡∏î‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á)</strong><br>';
                        for (let k in f.properties) {
                            popup += '<strong>' + k + ':</strong> ' + f.properties[k] + '<br>';
                        }
                        popup += '</div>';
                        l.bindPopup(popup);
                    }
                }).addTo(map);

                parcelData = await loadShapefile(parcelFiles[0], selectedEPSG);
                
                if (parcelLayer) map.removeLayer(parcelLayer);
                parcelLayer = L.geoJSON(parcelData, {
                    style: { color: '#000000', weight: 2, fillOpacity: 0 },
                    onEachFeature: (f, l) => {
                        let popup = '<div style="font-family: Sarabun, sans-serif;"><strong>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô</strong><br>';
                        for (let k in f.properties) {
                            popup += '<strong>' + k + ':</strong> ' + f.properties[k] + '<br>';
                        }
                        popup += '</div>';
                        l.bindPopup(popup);
                    }
                }).addTo(map);

                map.fitBounds(buildingCentroidLayer.getBounds().extend(parcelLayer.getBounds()));

                // ‡πÄ‡∏ï‡∏¥‡∏° field dropdown
                const fields = Object.keys(buildingData.features[0].properties);
                const areaSelect = document.getElementById('areaField');
                const typeSelect = document.getElementById('typeField');
                const classSelect = document.getElementById('classField');

                areaSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';
                typeSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';
                classSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';

                fields.forEach(field => {
                    areaSelect.add(new Option(field, field));
                    typeSelect.add(new Option(field, field));
                    classSelect.add(new Option(field, field));

                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Field ‡∏Ç‡∏ô‡∏≤‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà - ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å BL_AREA ‡∏Å‡πà‡∏≠‡∏ô
                    if (field === 'BL_AREA') {
                        areaSelect.value = field;
                    } else if (!areaSelect.value && field.toUpperCase().includes('AREA')) {
                        areaSelect.value = field;
                    }
                    
                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö TYPE_BUILD
                    if (field === 'TYPE_BUILD' || field.toUpperCase().includes('TYPE')) {
                        typeSelect.value = field;
                    }
                    
                    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö class
                    if (field.toLowerCase() === 'class') {
                        classSelect.value = field;
                    }
                });

                document.getElementById('fieldSection').style.display = 'block';
                document.getElementById('processSection').style.display = 'block';
                document.getElementById('layerControl').style.display = 'block';

                showStatus('loadStatus', 'success', 
                    '‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£: ' + buildingData.features.length + ', ‡πÅ‡∏õ‡∏•‡∏á: ' + parcelData.features.length);

                setupLayerToggles();

            } catch (error) {
                showStatus('loadStatus', 'error', '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + error.message);
                console.error(error);
            } finally {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loadFiles').disabled = false;
            }
        });

        document.getElementById('typeField').addEventListener('change', e => {
            if (e.target.value && buildingCentroidLayer) {
                updateBuildingColors(e.target.value);
            }
        });

        document.getElementById('processBtn').addEventListener('click', processMajorUse);

        document.getElementById('showAllLayers').addEventListener('click', () => {
            document.getElementById('toggleBuildings').checked = true;
            document.getElementById('toggleParcels').checked = true;
            if (document.getElementById('toggleResult')) {
                document.getElementById('toggleResult').checked = true;
            }
            
            if (buildingCentroidLayer) map.addLayer(buildingCentroidLayer);
            if (parcelLayer) map.addLayer(parcelLayer);
            if (resultLayer) map.addLayer(resultLayer);
        });

        document.getElementById('hideAllLayers').addEventListener('click', () => {
            document.getElementById('toggleBuildings').checked = false;
            document.getElementById('toggleParcels').checked = false;
            if (document.getElementById('toggleResult')) {
                document.getElementById('toggleResult').checked = false;
            }
            
            if (buildingCentroidLayer) map.removeLayer(buildingCentroidLayer);
            if (parcelLayer) map.removeLayer(parcelLayer);
            if (resultLayer) map.removeLayer(resultLayer);
        });

        document.getElementById('exportResult').addEventListener('click', () => {
            if (resultData) {
                exportShapefile(resultData, 'parcel_major_use');
            } else {
                alert('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å');
            }
        });

        initMap();
    </script>
</body>
</html>
