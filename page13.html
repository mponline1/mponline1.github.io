<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UTM Precision Splitter (Zone 47/48) - Enhanced</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;700&display=swap" rel="stylesheet">
    
    <!-- ‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/shpjs/3.6.3/shp.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Sarabun', sans-serif; height: 100vh; overflow: hidden; display: flex; background: #f8f9fa; }
        #map { flex-grow: 1; height: 100%; z-index: 1; background: #e0e0e0; }
        #controlPanel { width: 420px; height: 100%; background: white; box-shadow: -2px 0 20px rgba(0,0,0,0.1); overflow-y: auto; padding: 25px; z-index: 1000; }
        #header { background: #0079c1; color: white; padding: 20px; margin: -25px -25px 20px -25px; text-align: center; }
        .section { margin-bottom: 18px; padding: 15px; background: #fff; border-radius: 12px; border: 1px solid #ddd; border-left: 6px solid #0079c1; }
        .section.disabled { opacity: 0.4; pointer-events: none; filter: grayscale(1); }
        .section-title { font-size: 16px; font-weight: bold; margin-bottom: 12px; display: flex; align-items: center; gap: 10px; }
        .step-number { background: #0079c1; color: white; width: 26px; height: 26px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 13px; }
        button { width: 100%; padding: 12px; margin-bottom: 10px; border-radius: 8px; border: none; background: #0079c1; color: white; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:hover { background: #005a9e; }
        button.success { background: #28a745; }
        button.warning { background: #ff9800; }
        input, select { width: 100%; padding: 10px; margin-bottom: 10px; border-radius: 6px; border: 1px solid #ccc; font-family: 'Sarabun'; }
        .info-box { background: #e7f3ff; padding: 12px; border-radius: 8px; font-size: 13px; color: #004085; border: 1px solid #b8daff; }
        .utm-label { font-size: 11px; color: #666; font-weight: bold; margin-bottom: 5px; display: block; }
        .file-type-selector { display: flex; gap: 10px; margin-bottom: 10px; }
        .file-type-btn { flex: 1; padding: 8px; background: #f0f0f0; color: #333; border: 2px solid #ddd; }
        .file-type-btn.active { background: #0079c1; color: white; border-color: #0079c1; }
        .export-options { display: flex; gap: 8px; }
        .export-options button { flex: 1; font-size: 13px; }
        .loading { display: none; text-align: center; padding: 10px; }
        .loading.show { display: block; }
        .spinner { display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.3); border-radius: 50%; border-top-color: white; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="map"></div>
    
    <div id="controlPanel">
        <div id="header">
            <h2 style="font-size: 20px;">üìç UTM Precision Splitter</h2>
            <p style="font-size: 11px; opacity: 0.8; margin-top: 5px;">‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Shapefile & GeoJSON</p>
        </div>

        <div class="section" id="section1">
            <div class="section-title"><span class="step-number">1</span> ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ UTM & ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå</div>
            <label class="utm-label">‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå (‡πÄ‡∏°‡∏ï‡∏£)</label>
            <select id="utmZone">
                <option value="32647">WGS84 / UTM Zone 47N</option>
                <option value="32648">WGS84 / UTM Zone 48N</option>
            </select>
            
            <label class="utm-label">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå</label>
            <div class="file-type-selector">
                <button class="file-type-btn active" id="btnGeoJSON">GeoJSON</button>
                <button class="file-type-btn" id="btnShapefile">Shapefile (ZIP)</button>
            </div>
            
            <input type="file" id="fileInput" accept=".geojson,.json" style="display:block;">
            <input type="file" id="shapefileInput" accept=".zip" style="display:none;">
            
            <div class="loading" id="loadingIndicator">
                <div class="spinner"></div>
                <p style="margin-top: 5px; font-size: 12px;">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</p>
            </div>
            
            <div id="fileInfo" class="info-box" style="display:none; margin-top:10px;"></div>
        </div>

        <div class="section disabled" id="section2">
            <div class="section-title"><span class="step-number">2</span> ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î (Zero Error)</div>
            <label class="utm-label">Fuzzy Snap (‡πÄ‡∏°‡∏ï‡∏£) *‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏™‡πâ‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏Å‡∏±‡∏ô</label>
            <input type="number" id="snapTolerance" value="0.5" step="0.1">
            <button id="btnFindIntersections">‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏ó‡πâ‡∏à‡∏£‡∏¥‡∏á</button>
        </div>

        <div class="section disabled" id="section3">
            <div class="section-title"><span class="step-number">3</span> ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á</div>
            <div class="info-box">‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å <b>"‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏™‡∏µ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß"</b> ‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà</div>
            <div id="selectionPreview" style="margin-top:10px; font-size:12px; line-height:1.4; display:none; background: #fffbe6; padding: 8px; border-radius: 4px;"></div>
            <button id="btnConfirmSelection" class="success" style="display:none; margin-top:10px;">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</button>
        </div>

        <div class="section disabled" id="section4">
            <div class="section-title"><span class="step-number">4</span> ‡πÅ‡∏ö‡πà‡∏á‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ñ‡∏ô‡∏ô 360¬∞</div>
            <button id="btnSplit360">‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏ö‡πà‡∏á‡πÄ‡∏™‡πâ‡∏ô (Split)</button>
        </div>

        <div class="section disabled" id="section5">
            <div class="section-title"><span class="step-number">5</span> ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å 90¬∞</div>
            <div style="display:flex; gap:8px;">
                <div style="flex:1"><label style="font-size:11px; font-weight:bold;">‡∏£‡∏∞‡∏¢‡∏∞‡∏ï‡∏≤‡∏°‡πÄ‡∏™‡πâ‡∏ô (‡∏°.)</label><input type="number" id="distAlong" value="10"></div>
                <div style="flex:1"><label style="font-size:11px; font-weight:bold;">‡∏£‡∏∞‡∏¢‡∏∞‡∏â‡∏≤‡∏Å (‡∏°.)</label><input type="number" id="distPerp" value="5"></div>
            </div>
            <select id="direction">
                <option value="90">‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢ (90¬∞)</option>
                <option value="-90">‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏Ç‡∏ß‡∏≤ (-90¬∞)</option>
            </select>
            <button id="btnCreatePerp" class="success">‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏â‡∏≤‡∏Å</button>
        </div>

        <div class="section disabled" id="section6">
            <div class="section-title"><span class="step-number">6</span> ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå</div>
            <label class="utm-label">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å</label>
            <div class="export-options">
                <button id="btnExportGeoJSON" style="background:#6f42c1">üíæ GeoJSON</button>
                <button id="btnExportShapefile" style="background:#28a745">üì¶ Shapefile</button>
            </div>
            <button onclick="location.reload()" style="background:#d9534f; margin-top:5px;">üîÑ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏á‡∏≤‡∏ô‡πÉ‡∏´‡∏°‡πà</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js" crossorigin=""></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    
    <script>
        // --- ‚öôÔ∏è ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Ñ‡∏ä‡∏±‡∏ô‡∏û‡∏¥‡∏Å‡∏±‡∏î ---
        proj4.defs("EPSG:32647", "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs");
        proj4.defs("EPSG:32648", "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs");

        // ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà Deep Zoom 30
        const map = L.map('map', { zoomSnap: 0, maxZoom: 30, zoomControl: false }).setView([13.75, 100.5], 10);
        L.control.zoom({ position: 'topright' }).addTo(map);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { 
            maxNativeZoom: 19, 
            maxZoom: 30, 
            opacity: 0.5 
        }).addTo(map);

        const layers = {
            original: L.geoJson(null, { style: { color: '#888', weight: 2 } }).addTo(map),
            intersections: L.featureGroup().addTo(map),
            split: L.geoJson(null, { style: { color: '#1890ff', weight: 4 } }).addTo(map),
            perp: L.featureGroup().addTo(map)
        };

        let state = { roadsFC: null, selectedPoint: null, targetSubLine: null };
        let currentFileType = 'geojson';

        // --- ‡∏™‡∏•‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÑ‡∏ü‡∏•‡πå ---
        document.getElementById('btnGeoJSON').onclick = () => {
            currentFileType = 'geojson';
            document.getElementById('btnGeoJSON').classList.add('active');
            document.getElementById('btnShapefile').classList.remove('active');
            document.getElementById('fileInput').style.display = 'block';
            document.getElementById('shapefileInput').style.display = 'none';
            document.getElementById('fileInput').value = '';
        };

        document.getElementById('btnShapefile').onclick = () => {
            currentFileType = 'shapefile';
            document.getElementById('btnShapefile').classList.add('active');
            document.getElementById('btnGeoJSON').classList.remove('active');
            document.getElementById('fileInput').style.display = 'none';
            document.getElementById('shapefileInput').style.display = 'block';
            document.getElementById('shapefileInput').value = '';
        };

        // --- üìÇ 1. Load GeoJSON ---
        document.getElementById('fileInput').onchange = (e) => {
            const reader = new FileReader();
            const utmZone = "EPSG:" + document.getElementById('utmZone').value;

            document.getElementById('loadingIndicator').classList.add('show');

            reader.onload = (ev) => {
                try {
                    let fc = JSON.parse(ev.target.result);
                    processGeoJSON(fc, utmZone);
                } catch (error) {
                    alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå: ' + error.message);
                } finally {
                    document.getElementById('loadingIndicator').classList.remove('show');
                }
            };
            reader.readAsText(e.target.files[0]);
        };

        // --- üìÇ 2. Load Shapefile (ZIP) ---
        document.getElementById('shapefileInput').onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('loadingIndicator').classList.add('show');

            try {
                const arrayBuffer = await file.arrayBuffer();
                const geojson = await shp(arrayBuffer);
                
                // shpjs ‡∏≠‡∏≤‡∏à‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô FeatureCollection ‡∏´‡∏£‡∏∑‡∏≠ array ‡∏Ç‡∏≠‡∏á layers
                let fc;
                if (Array.isArray(geojson)) {
                    fc = geojson[0]; // ‡πÉ‡∏ä‡πâ layer ‡πÅ‡∏£‡∏Å
                } else if (geojson.type === 'FeatureCollection') {
                    fc = geojson;
                } else {
                    throw new Error('‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö Shapefile ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                }

                const utmZone = "EPSG:" + document.getElementById('utmZone').value;
                processGeoJSON(fc, utmZone);
            } catch (error) {
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô Shapefile: ' + error.message);
            } finally {
                document.getElementById('loadingIndicator').classList.remove('show');
            }
        };

        // --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• GeoJSON ---
        function processGeoJSON(fc, utmZone) {
            // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏≤‡∏Å UTM ‡πÄ‡∏õ‡πá‡∏ô WGS84 ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏ñ‡∏≤‡∏°)
            fc.features.forEach(feature => {
                turf.coordEach(feature, (coord) => {
                    // ‡∏´‡∏≤‡∏Å‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏ï‡∏±‡∏ß‡πÅ‡∏£‡∏Å > 180 ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô UTM (‡πÄ‡∏°‡∏ï‡∏£) ‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
                    if (Math.abs(coord[0]) > 180) {
                        const wgs84 = proj4(utmZone, "WGS84", coord);
                        coord[0] = wgs84[0];
                        coord[1] = wgs84[1];
                    }
                });
            });

            state.roadsFC = fc;
            layers.original.clearLayers().addData(state.roadsFC);
            map.fitBounds(layers.original.getBounds());
            
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('fileInfo').innerText = `‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (${fc.features.length} ‡πÄ‡∏™‡πâ‡∏ô) ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏á‡∏®‡∏≤‡∏ó‡∏®‡∏ô‡∏¥‡∏¢‡∏°‡πÅ‡∏•‡πâ‡∏ß`;
            enableSection('section2');
        }

        // --- üìç 2. ‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î (Zero Displacement) ---
        document.getElementById('btnFindIntersections').onclick = () => {
            layers.intersections.clearLayers();
            const points = [];
            const features = state.roadsFC.features;

            for (let i = 0; i < features.length; i++) {
                for (let j = i + 1; j < features.length; j++) {
                    const intersect = turf.lineIntersect(features[i], features[j]);
                    intersect.features.forEach(f => {
                        points.push(f.geometry.coordinates.map(c => Number(c.toFixed(14))));
                    });
                }
            }

            const uniquePoints = [];
            points.forEach(p => {
                if (!uniquePoints.some(up => turf.distance(p, up) < 0.0001)) uniquePoints.push(p);
            });

            uniquePoints.forEach(coord => {
                const marker = L.circleMarker([coord[1], coord[0]], { 
                    radius: 12, fillColor: "#28a745", color: "#fff", weight: 3, fillOpacity: 0.9 
                }).addTo(layers.intersections);

                marker.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    state.selectedPoint = coord; 
                    
                    const epsg = "EPSG:" + document.getElementById('utmZone').value;
                    const utm = proj4("WGS84", epsg, coord);
                    
                    layers.intersections.eachLayer(l => l.setStyle({ fillColor: '#28a745', radius: 12 }));
                    marker.setStyle({ fillColor: '#ffc107', radius: 16 });
                    
                    document.getElementById('selectionPreview').style.display = 'block';
                    document.getElementById('selectionPreview').innerHTML = `
                        <b>‡∏û‡∏¥‡∏Å‡∏±‡∏î UTM (Lock):</b> E ${utm[0].toFixed(3)}, N ${utm[1].toFixed(3)}<br>
                        <b>Lat/Long:</b> ${coord[1].toFixed(7)}, ${coord[0].toFixed(7)}
                    `;
                    document.getElementById('btnConfirmSelection').style.display = 'block';
                    enableSection('section3');
                });
            });
            alert(`‡∏û‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡∏ó‡∏≤‡∏á‡∏Ñ‡∏ì‡∏¥‡∏ï‡∏®‡∏≤‡∏™‡∏ï‡∏£‡πå ${uniquePoints.length} ‡∏à‡∏∏‡∏î`);
        };

        document.getElementById('btnConfirmSelection').onclick = () => enableSection('section4');

        // --- ‚úÇÔ∏è 4. Split 360¬∞ (Vertex Injection) ---
        document.getElementById('btnSplit360').onclick = () => {
            const centerPt = state.selectedPoint;
            const splitSegments = [];
            const toleranceKm = 0.001; // 1 ‡πÄ‡∏°‡∏ï‡∏£

            state.roadsFC.features.forEach(road => {
                const snapped = turf.nearestPointOnLine(road, turf.point(centerPt));
                
                if (snapped.properties.dist < toleranceKm) {
                    const split = turf.lineSplit(road, turf.point(centerPt));
                    const segments = split.features.length > 0 ? split.features : [road];
                    
                    segments.forEach(seg => {
                        let coords = [...seg.geometry.coordinates];
                        const dStart = turf.distance(centerPt, turf.point(coords[0]));
                        const dEnd = turf.distance(centerPt, turf.point(coords[coords.length - 1]));

                        if (dEnd < dStart) coords.reverse();
                        
                        if (turf.distance(centerPt, turf.point(coords[0])) < toleranceKm) {
                            coords[0] = centerPt; // ‡∏•‡πá‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡πâ‡∏ó‡∏±‡∏ö‡∏à‡∏∏‡∏î‡∏ï‡∏±‡∏î‡πÄ‡∏õ‡πä‡∏∞
                            splitSegments.push(turf.lineString(coords, seg.properties));
                        }
                    });
                }
            });

            layers.split.clearLayers().addData(turf.featureCollection(splitSegments));
            layers.original.setStyle({ opacity: 0.1 });
            
            layers.split.eachLayer(l => {
                l.on('click', (e) => {
                    L.DomEvent.stopPropagation(e);
                    state.targetSubLine = l.feature;
                    layers.split.setStyle({ color: '#1890ff', weight: 4 });
                    l.setStyle({ color: '#0050b3', weight: 8 });
                    enableSection('section5');
                });
            });
            alert(`‡πÅ‡∏ö‡πà‡∏á‡∏ñ‡∏ô‡∏ô‡∏≠‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏∏‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à (${splitSegments.length} ‡πÄ‡∏™‡πâ‡∏ô)`);
        };

        // --- üìê 5. Create Perpendicular ---
        document.getElementById('btnCreatePerp').onclick = () => {
            const dA = parseFloat(document.getElementById('distAlong').value) / 1000;
            const dP = parseFloat(document.getElementById('distPerp').value) / 1000;
            const rot = parseFloat(document.getElementById('direction').value);

            const pBase = turf.along(state.targetSubLine, dA);
            const pLook = turf.along(state.targetSubLine, dA + 0.000001);
            const bearing = turf.bearing(pBase, pLook);
            const pFinal = turf.destination(pBase, dP, bearing + rot);

            const line = turf.lineString([pBase.geometry.coordinates, pFinal.geometry.coordinates]);
            L.geoJson(line, { style: { color: '#e91e63', weight: 4 } }).addTo(layers.perp);
            L.circleMarker([pFinal.geometry.coordinates[1], pFinal.geometry.coordinates[0]], { 
                radius: 5, fillColor: '#e91e63', color: '#fff', weight: 1, fillOpacity: 1 
            }).addTo(layers.perp);
            enableSection('section6');
        };

        // --- üì§ 6. Export as GeoJSON ---
        document.getElementById('btnExportGeoJSON').onclick = () => {
            const data = layers.perp.toGeoJSON();
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `exported_roads_utm_${Date.now()}.geojson`;
            a.click();
            alert('‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å GeoJSON ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!');
        };

        // --- üì§ 7. Export as Shapefile ---
        document.getElementById('btnExportShapefile').onclick = async () => {
            try {
                // ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å layers.perp
                const geojson = layers.perp.toGeoJSON();
                
                if (!geojson.features || geojson.features.length === 0) {
                    alert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å‡∏Å‡πà‡∏≠‡∏ô');
                    return;
                }

                document.getElementById('loadingIndicator').classList.add('show');

                // ‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏â‡∏û‡∏≤‡∏∞ LineString features (‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å) ‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤ Point markers
                const perpLines = {
                    type: "FeatureCollection",
                    features: geojson.features.filter(f => 
                        f.geometry && 
                        (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString')
                    )
                };

                if (perpLines.features.length === 0) {
                    alert('‡πÑ‡∏°‡πà‡∏û‡∏ö‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
                    document.getElementById('loadingIndicator').classList.remove('show');
                    return;
                }

                // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô UTM ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å
                const utmZone = "EPSG:" + document.getElementById('utmZone').value;
                const utmGeoJSON = JSON.parse(JSON.stringify(perpLines)); // Deep copy
                
                utmGeoJSON.features.forEach(feature => {
                    turf.coordEach(feature, (coord) => {
                        const utm = proj4("WGS84", utmZone, coord);
                        coord[0] = utm[0];
                        coord[1] = utm[1];
                    });
                });

                // ‡πÄ‡∏û‡∏¥‡πà‡∏° attributes ‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏™‡πâ‡∏ô
                utmGeoJSON.features.forEach((feature, index) => {
                    if (!feature.properties) {
                        feature.properties = {};
                    }
                    feature.properties.ID = index + 1;
                    feature.properties.TYPE = 'Perpendicular';
                    
                    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡πÄ‡∏™‡πâ‡∏ô
                    const length = turf.length(feature, { units: 'meters' });
                    feature.properties.LENGTH_M = parseFloat(length.toFixed(3));
                });

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á Shapefile ‡∏î‡πâ‡∏ß‡∏¢ custom function
                await createShapefile(utmGeoJSON, `perpendicular_lines_${Date.now()}`);
                
                alert(`‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡πÄ‡∏™‡πâ‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏â‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ${perpLines.features.length} ‡πÄ‡∏™‡πâ‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!`);
                
            } catch (error) {
                alert('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile: ' + error.message);
                console.error(error);
            } finally {
                document.getElementById('loadingIndicator').classList.remove('show');
            }
        };

        // --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Shapefile (Custom) ---
        async function createShapefile(geojson, filename) {
            const zip = new JSZip();
            
            // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó geometry
            let shapeType = 0;
            const firstFeature = geojson.features[0];
            if (firstFeature) {
                const geomType = firstFeature.geometry.type;
                if (geomType === 'Point' || geomType === 'MultiPoint') shapeType = 1;
                else if (geomType === 'LineString' || geomType === 'MultiLineString') shapeType = 3;
                else if (geomType === 'Polygon' || geomType === 'MultiPolygon') shapeType = 5;
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .shp, .shx, .dbf
            const shpBuffer = createSHPFile(geojson, shapeType);
            const shxBuffer = createSHXFile(geojson, shapeType);
            const dbfBuffer = createDBFFile(geojson);
            const prjContent = createPRJFile();

            zip.file(`${filename}.shp`, shpBuffer);
            zip.file(`${filename}.shx`, shxBuffer);
            zip.file(`${filename}.dbf`, dbfBuffer);
            zip.file(`${filename}.prj`, prjContent);

            const blob = await zip.generateAsync({ type: 'blob' });
            saveAs(blob, `${filename}.zip`);
            alert('‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß!');
        }

        // --- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .shp ---
        function createSHPFile(geojson, shapeType) {
            const features = geojson.features;
            const records = [];
            let totalContentLength = 0;

            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞ record
            features.forEach((feature) => {
                const coords = feature.geometry.coordinates;
                let numPoints = 0;
                let points = [];
                let numParts = 1;
                let partIndices = [0];

                if (shapeType === 1) { // Point
                    numPoints = 1;
                    points = [coords];
                } else if (shapeType === 3) { // Polyline
                    if (Array.isArray(coords[0][0])) { // MultiLineString
                        numParts = coords.length;
                        partIndices = [];
                        let currentIndex = 0;
                        coords.forEach(line => {
                            partIndices.push(currentIndex);
                            numPoints += line.length;
                            points = points.concat(line);
                            currentIndex += line.length;
                        });
                    } else { // LineString
                        numParts = 1;
                        numPoints = coords.length;
                        points = coords;
                        partIndices = [0];
                    }
                }

                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î content (in bytes)
                let contentLength;
                if (shapeType === 1) {
                    contentLength = 20; // 4 + 8 + 8
                } else if (shapeType === 3) {
                    contentLength = 44 + (4 * numParts) + (16 * numPoints);
                }

                records.push({
                    numPoints: numPoints,
                    numParts: numParts,
                    partIndices: partIndices,
                    points: points,
                    contentLengthBytes: contentLength,
                    contentLengthWords: contentLength / 2
                });

                totalContentLength += 8 + contentLength;
            });

            const fileLength = 100 + totalContentLength;
            const buffer = new ArrayBuffer(fileLength);
            const view = new DataView(buffer);

            // ========== HEADER (100 bytes) ==========
            view.setInt32(0, 9994, false);              // File code
            for (let i = 4; i < 24; i += 4) {
                view.setInt32(i, 0, false);             // Unused
            }
            view.setInt32(24, fileLength / 2, false);   // File length in words
            view.setInt32(28, 1000, true);              // Version
            view.setInt32(32, shapeType, true);         // Shape type

            // Bounding box
            const bbox = calculateBoundingBox(geojson);
            view.setFloat64(36, bbox.xmin, true);
            view.setFloat64(44, bbox.ymin, true);
            view.setFloat64(52, bbox.xmax, true);
            view.setFloat64(60, bbox.ymax, true);
            view.setFloat64(68, 0.0, true);             // Zmin
            view.setFloat64(76, 0.0, true);             // Zmax
            view.setFloat64(84, 0.0, true);             // Mmin
            view.setFloat64(92, 0.0, true);             // Mmax

            // ========== RECORDS ==========
            let offset = 100;
            records.forEach((record, index) => {
                // Record header
                view.setInt32(offset, index + 1, false);
                view.setInt32(offset + 4, record.contentLengthWords, false);
                offset += 8;

                if (shapeType === 1) { // Point
                    view.setInt32(offset, shapeType, true);
                    view.setFloat64(offset + 4, record.points[0][0], true);
                    view.setFloat64(offset + 12, record.points[0][1], true);
                    offset += 20;
                } else if (shapeType === 3) { // Polyline
                    view.setInt32(offset, shapeType, true);
                    offset += 4;

                    // Bounding box
                    const recBbox = calculateGeometryBbox(record.points);
                    view.setFloat64(offset, recBbox.xmin, true);
                    view.setFloat64(offset + 8, recBbox.ymin, true);
                    view.setFloat64(offset + 16, recBbox.xmax, true);
                    view.setFloat64(offset + 24, recBbox.ymax, true);
                    offset += 32;

                    // NumParts and NumPoints
                    view.setInt32(offset, record.numParts, true);
                    view.setInt32(offset + 4, record.numPoints, true);
                    offset += 8;

                    // Part indices
                    record.partIndices.forEach(partIdx => {
                        view.setInt32(offset, partIdx, true);
                        offset += 4;
                    });

                    // Point coordinates
                    record.points.forEach(pt => {
                        view.setFloat64(offset, pt[0], true);
                        view.setFloat64(offset + 8, pt[1], true);
                        offset += 16;
                    });
                }
            });

            return buffer;
        }

        // --- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .shx ---
        function createSHXFile(geojson, shapeType) {
            const features = geojson.features;
            const headerSize = 100;
            const recordSize = 8;
            const fileLength = headerSize + features.length * recordSize;
            
            const buffer = new ArrayBuffer(fileLength);
            const view = new DataView(buffer);

            // ========== HEADER (100 bytes) ==========
            view.setInt32(0, 9994, false);
            for (let i = 4; i < 24; i += 4) {
                view.setInt32(i, 0, false);
            }
            view.setInt32(24, fileLength / 2, false);
            view.setInt32(28, 1000, true);
            view.setInt32(32, shapeType, true);

            const bbox = calculateBoundingBox(geojson);
            view.setFloat64(36, bbox.xmin, true);
            view.setFloat64(44, bbox.ymin, true);
            view.setFloat64(52, bbox.xmax, true);
            view.setFloat64(60, bbox.ymax, true);
            view.setFloat64(68, 0.0, true);
            view.setFloat64(76, 0.0, true);
            view.setFloat64(84, 0.0, true);
            view.setFloat64(92, 0.0, true);

            // ========== INDEX RECORDS ==========
            let indexOffset = 100;
            let contentOffset = 50; // Start after header (100 bytes / 2 = 50 words)
            
            features.forEach((feature) => {
                const coords = feature.geometry.coordinates;
                let numPoints = 0;
                let numParts = 1;

                if (shapeType === 1) {
                    numPoints = 1;
                } else if (shapeType === 3) {
                    if (Array.isArray(coords[0][0])) {
                        numParts = coords.length;
                        coords.forEach(line => {
                            numPoints += line.length;
                        });
                    } else {
                        numParts = 1;
                        numPoints = coords.length;
                    }
                }

                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î content
                let contentLength;
                if (shapeType === 1) {
                    contentLength = 10; // 20 bytes / 2 = 10 words
                } else if (shapeType === 3) {
                    const contentBytes = 44 + (4 * numParts) + (16 * numPoints);
                    contentLength = contentBytes / 2; // Convert to 16-bit words
                }

                // ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô offset ‡πÅ‡∏•‡∏∞ content length
                view.setInt32(indexOffset, contentOffset, false);
                view.setInt32(indexOffset + 4, contentLength, false);
                indexOffset += 8;

                // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó offset ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö record ‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
                contentOffset += 4 + contentLength; // 4 words for record header + content
            });

            return buffer;
        }

        // --- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .dbf ---
        function createDBFFile(geojson) {
            const features = geojson.features;
            const numRecords = features.length;
            
            // ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏° properties ‡πÅ‡∏•‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            const propertyInfo = new Map();
            features.forEach(f => {
                if (f.properties) {
                    Object.entries(f.properties).forEach(([key, value]) => {
                        if (!propertyInfo.has(key)) {
                            propertyInfo.set(key, {
                                name: key,
                                type: 'C',
                                maxLength: 0,
                                hasDecimals: false,
                                isNumeric: true
                            });
                        }
                        
                        const info = propertyInfo.get(key);
                        const strValue = String(value);
                        info.maxLength = Math.max(info.maxLength, strValue.length);
                        
                        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                        if (value !== null && value !== undefined) {
                            const numValue = Number(value);
                            if (isNaN(numValue)) {
                                info.isNumeric = false;
                            } else if (String(value).includes('.')) {
                                info.hasDecimals = true;
                            }
                        }
                    });
                }
            });

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á field definitions
            const fieldDefinitions = [{ name: 'FID', type: 'N', length: 10, decimal: 0 }];
            const propArray = [];
            
            let fieldCount = 0;
            for (const [key, info] of propertyInfo) {
                if (fieldCount >= 9) break; // ‡∏à‡∏≥‡∏Å‡∏±‡∏î 10 fields ‡∏£‡∏ß‡∏° FID
                
                let fieldDef = {
                    name: key.substring(0, 10).toUpperCase(),
                    type: 'C',
                    length: 50,
                    decimal: 0
                };

                // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏≤‡∏°‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞
                if (info.isNumeric) {
                    if (info.hasDecimals) {
                        fieldDef.type = 'N'; // Numeric with decimals
                        fieldDef.length = Math.min(18, Math.max(10, info.maxLength + 5));
                        fieldDef.decimal = 3;
                    } else {
                        fieldDef.type = 'N'; // Numeric integer
                        fieldDef.length = Math.min(10, Math.max(5, info.maxLength));
                        fieldDef.decimal = 0;
                    }
                } else {
                    fieldDef.type = 'C'; // Character
                    fieldDef.length = Math.min(254, Math.max(10, info.maxLength + 5));
                }
                
                fieldDefinitions.push(fieldDef);
                propArray.push(key);
                fieldCount++;
            }

            const numFields = fieldDefinitions.length;
            const headerSize = 32 + numFields * 32 + 1;
            const recordSize = 1 + fieldDefinitions.reduce((sum, f) => sum + f.length, 0);
            const totalSize = headerSize + numRecords * recordSize + 1;

            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);

            // Header
            view.setUint8(0, 0x03); // DBF version
            const now = new Date();
            view.setUint8(1, now.getFullYear() - 1900);
            view.setUint8(2, now.getMonth() + 1);
            view.setUint8(3, now.getDate());
            view.setUint32(4, numRecords, true);
            view.setUint16(8, headerSize, true);
            view.setUint16(10, recordSize, true);

            // Field descriptors
            let fieldOffset = 32;
            fieldDefinitions.forEach(field => {
                for (let i = 0; i < field.name.length && i < 10; i++) {
                    uint8View[fieldOffset + i] = field.name.charCodeAt(i);
                }
                for (let i = field.name.length; i < 11; i++) {
                    uint8View[fieldOffset + i] = 0x00;
                }
                uint8View[fieldOffset + 11] = field.type.charCodeAt(0);
                view.setUint32(fieldOffset + 12, 0, true); // Data address
                view.setUint8(fieldOffset + 16, field.length);
                view.setUint8(fieldOffset + 17, field.decimal);
                fieldOffset += 32;
            });
            uint8View[fieldOffset] = 0x0D; // Field descriptor terminator

            // Records
            let recordOffset = headerSize;
            features.forEach((feature, index) => {
                uint8View[recordOffset] = 0x20; // Not deleted
                recordOffset++;

                fieldDefinitions.forEach((field, fieldIndex) => {
                    let value = '';
                    
                    if (fieldIndex === 0) {
                        // FID field
                        value = (index + 1).toString();
                    } else {
                        const propName = propArray[fieldIndex - 1];
                        const propValue = feature.properties && feature.properties[propName];
                        
                        if (propValue !== undefined && propValue !== null) {
                            if (field.type === 'N') {
                                // Numeric field
                                const numValue = Number(propValue);
                                if (!isNaN(numValue)) {
                                    if (field.decimal > 0) {
                                        value = numValue.toFixed(field.decimal);
                                    } else {
                                        value = Math.round(numValue).toString();
                                    }
                                }
                            } else {
                                // Character field
                                value = String(propValue);
                            }
                        }
                    }
                    
                    // ‡∏à‡∏±‡∏î‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó field
                    if (field.type === 'N') {
                        // Numeric: ‡∏ä‡∏¥‡∏î‡∏Ç‡∏ß‡∏≤
                        value = value.substring(0, field.length).padStart(field.length, ' ');
                    } else {
                        // Character: ‡∏ä‡∏¥‡∏î‡∏ã‡πâ‡∏≤‡∏¢
                        value = value.substring(0, field.length).padEnd(field.length, ' ');
                    }
                    
                    // ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
                    for (let i = 0; i < field.length; i++) {
                        uint8View[recordOffset + i] = value.charCodeAt(i) || 0x20;
                    }
                    
                    recordOffset += field.length;
                });
            });

            // End of file marker
            uint8View[totalSize - 1] = 0x1A;
            return buffer;
        }

        // --- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .prj ---
        function createPRJFile() {
            const utmZone = document.getElementById('utmZone').value;
            const zone = utmZone === '32647' ? '47' : '48';
            
            return `PROJCS["WGS_1984_UTM_Zone_${zone}N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Transverse_Mercator"],PARAMETER["False_Easting",500000.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",${zone === '47' ? '99.0' : '105.0'}],PARAMETER["Scale_Factor",0.9996],PARAMETER["Latitude_Of_Origin",0.0],UNIT["Meter",1.0]]`;
        }

        // --- Helper Functions ---
        function calculateGeometryBbox(coords) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            const processCoord = (coord) => {
                if (Array.isArray(coord[0])) {
                    coord.forEach(processCoord);
                } else {
                    xmin = Math.min(xmin, coord[0]);
                    ymin = Math.min(ymin, coord[1]);
                    xmax = Math.max(xmax, coord[0]);
                    ymax = Math.max(ymax, coord[1]);
                }
            };
            
            coords.forEach(processCoord);
            return { xmin, ymin, xmax, ymax };
        }

        function calculateBoundingBox(geoJSON) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            geoJSON.features.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;
                const coords = feature.geometry.coordinates;
                const processCoord = (coord) => {
                    if (Array.isArray(coord[0])) {
                        coord.forEach(processCoord);
                    } else {
                        xmin = Math.min(xmin, coord[0]);
                        ymin = Math.min(ymin, coord[1]);
                        xmax = Math.max(xmax, coord[0]);
                        ymax = Math.max(ymax, coord[1]);
                    }
                };
                processCoord(coords);
            });
            
            return { xmin, ymin, xmax, ymax };
        }

        function enableSection(id) { 
            document.getElementById(id).classList.remove('disabled'); 
        }
    </script>
</body>
</html>
