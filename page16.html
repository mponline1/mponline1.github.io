<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Sarabun', sans-serif; background: #f5f5f5; }
        .container { display: flex; height: 100vh; }
        .sidebar { width: 400px; background: white; padding: 20px; overflow-y: auto; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        h1 { font-size: 20px; margin-bottom: 20px; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        .section { margin-bottom: 25px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; }
        .section-title { font-weight: bold; margin-bottom: 12px; color: #2c3e50; font-size: 16px; }
        .file-input-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; color: #555; font-weight: 500; }
        input[type="file"] { width: 100%; padding: 8px; border: 2px dashed #3498db; border-radius: 5px; background: white; cursor: pointer; }
        input[type="number"] { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: white; font-size: 14px; }
        input[type="number"]:focus { outline: none; border-color: #3498db; box-shadow: 0 0 5px rgba(52, 152, 219, 0.3); }
        select { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; background: white; margin-bottom: 10px; }
        button { width: 100%; padding: 12px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; font-size: 14px; transition: background 0.3s; }
        button:hover { background: #2980b9; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }
        .urban-config { background: white; padding: 12px; border-radius: 5px; margin-top: 10px; }
        .value-list { max-height: 150px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px; margin-bottom: 10px; background: #f9f9f9; }
        .value-item { display: flex; align-items: center; padding: 5px; margin-bottom: 5px; background: white; border-radius: 3px; }
        .value-item input[type="checkbox"] { margin-right: 8px; }
        #map { flex: 1; height: 100vh; }
        .status { padding: 10px; margin-top: 10px; border-radius: 5px; font-size: 13px; display: none; font-weight: 500; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        #processingProgress { background: linear-gradient(90deg, #e8f4f8 0%, #d1ecf1 100%); color: #0c5460; border-left: 4px solid #3498db; padding: 12px; font-weight: 500; border-radius: 5px; margin-top: 10px; animation: pulse 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.8; } }
        .legend { background: white; padding: 15px; border-radius: 5px; margin-top: 10px; max-height: 400px; overflow-y: auto; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
        .legend-color { width: 30px; height: 20px; border: 1px solid #333; margin-right: 10px; border-radius: 3px; }
        .layer-item { display: flex; align-items: center; padding: 8px; margin-bottom: 5px; background: #f8f9fa; border-radius: 4px; transition: background 0.2s; }
        .layer-item:hover { background: #e9ecef; }
        .layer-item input[type="checkbox"] { margin-right: 10px; cursor: pointer; }
        .layer-item label { cursor: pointer; user-select: none; flex: 1; }
        .summary { background: white; padding: 12px; border-radius: 5px; margin-top: 10px; }
        .summary-item { display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #eee; }
        .summary-item:last-child { border-bottom: none; }
        .loading { display: none; text-align: center; padding: 10px; color: #3498db; }
        .loading.active { display: block; }
        
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: white;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
            transition: background 0.2s;
        }
        .layer-item:hover {
            background: #f8f9fa;
        }
        .layer-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }
        .layer-item label {
            cursor: pointer;
            user-select: none;
            flex: 1;
        }
        
        #showAllLayers, #hideAllLayers {
            transition: all 0.2s;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 3px;
        }
        #showAllLayers:hover {
            background: #229954 !important;
            transform: translateY(-1px);
        }
        #hideAllLayers:hover {
            background: #c0392b !important;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h1>üó∫Ô∏è ‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥</h1>

            <div class="section">
                <div class="section-title">1. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô</div>
                <label>‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•:</label>
                <select id="epsgSelect">
                    <option value="EPSG:32647">WGS84 UTM Zone 47N (EPSG:32647)</option>
                    <option value="EPSG:32648">WGS84 UTM Zone 48N (EPSG:32648)</option>
                </select>
            </div>

            <div class="section">
                <div class="section-title">2. ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå Shapefile (ZIP)</div>
                <div class="file-input-group">
                    <label>üìÅ ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (.zip)</label>
                    <input type="file" id="buildingFiles" accept=".zip">
                </div>
                <div class="file-input-group">
                    <label>üìÅ ‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (.zip)</label>
                    <input type="file" id="parcelFiles" accept=".zip">
                </div>
                <div style="font-size: 12px; color: #555; margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px; border-left: 3px solid #3498db;">
                    üí° <strong>‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢:</strong> ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏≠‡πà‡∏≤‡∏ô encoding ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å .cpg ‡∏´‡∏£‡∏∑‡∏≠ DBF header<br>
                    üìå ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö: UTF-8, TIS-620, CP874, windows-874<br>
                    ‚úÖ ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ô‡∏ó‡∏∏‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏ß‡πá‡∏ö
                </div>
                <button id="loadFiles">‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå</button>
                <div class="loading" id="loading">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå...</div>
                <div id="loadStatus"></div>
            </div>

            <div class="section">
                <div class="section-title">3. ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field</div>
                <label>Field ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô:</label>
                <select id="landUseField" disabled>
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
                <label>Field ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏°‡∏∑‡∏≠‡∏á:</label>
                <select id="urbanField" disabled>
                    <option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>
                </select>
            </div>

            <div class="section" id="urbanConfigSection" style="display: none;">
                <div class="section-title">4. ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏°‡∏∑‡∏≠‡∏á</div>
                <div class="urban-config">
                    <label style="color: #2c3e50; font-weight: bold;">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô "‡πÄ‡∏°‡∏∑‡∏≠‡∏á":</label>
                    <div class="value-list" id="urbanValueList"></div>
                    <div class="summary" id="urbanSummary">
                        <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">‡∏™‡∏£‡∏∏‡∏õ:</div>
                        <div class="summary-item">
                            <span>‚úÖ ‡πÄ‡∏°‡∏∑‡∏≠‡∏á:</span>
                            <span id="urbanCount" style="color: #27ae60; font-weight: bold;">0 ‡∏Ñ‡πà‡∏≤</span>
                        </div>
                        <div class="summary-item">
                            <span>üè° ‡∏ä‡∏ô‡∏ö‡∏ó:</span>
                            <span id="ruralCount" style="color: #e67e22; font-weight: bold;">0 ‡∏Ñ‡πà‡∏≤</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <div class="section-title">5. ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</div>
                
                <label>‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏õ‡∏•‡∏á (%):</label>
                <input type="number" id="coverageThreshold" min="0" max="100" value="20" step="1" 
                       style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; margin-bottom: 10px;">
                <div style="font-size: 12px; color: #555; margin-bottom: 15px;">
                    üí° ‡∏ñ‡πâ‡∏≤<strong>‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô</strong> ‚â• ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á ‚Üí ‡πÉ‡∏ä‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏õ‡∏•‡∏á<br>
                    üí° ‡∏ñ‡πâ‡∏≤<strong>‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô</strong> < ‡∏Ñ‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á ‚Üí Buffer ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£<br>
                    <span style="color: #27ae60;">‚ö° ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏Ñ‡∏•‡πà‡∏≠‡∏á‡πÅ‡∏°‡πâ‡∏°‡∏µ RAM 8GB</span>
                </div>
                
                <button id="processBtn" disabled>üöÄ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡∏∞‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ</button>
                <div class="loading" id="processing">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</div>
                <div id="processingProgress" style="display: none; margin-top: 10px; padding: 10px; background: #e8f4f8; border-radius: 5px; font-size: 12px;"></div>
                <div id="processStatus"></div>
            </div>

            <div class="section" id="exportSection" style="display: none;">
                <div class="section-title">6. ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Shapefile (.zip)</div>
                <button id="exportResidential" style="background: #f39c12;">üíæ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢</button>
                <button id="exportCommercial" style="background: #e74c3c; margin-top: 8px;">üíæ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°</button>
                <button id="exportIndustrial" style="background: #9b59b6; margin-top: 8px;">üíæ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°</button>
                <button id="exportAll" style="background: #27ae60; margin-top: 8px;">üíæ ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                <div style="margin-top: 10px; padding: 8px; background: #fff3cd; border-radius: 5px; font-size: 12px; color: #856404;">
                    üìå ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î: <span id="exportEPSG" style="font-weight: bold;"></span><br>
                    üìå ‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô: <span id="exportThreshold" style="font-weight: bold;"></span>
                </div>
            </div>

            <div class="legend" id="legend" style="display: none;">
                <div style="font-weight: bold; margin-bottom: 10px;">‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå:</div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFFF00; border-color: #8B4513; border-width: 2px;"></div>
                    <span>‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢ (‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏°‡∏∑‡∏≠‡∏á ‚â• ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FFFF00; border-color: #FFA500;"></div>
                    <span>‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢ (Buffer ‡πÄ‡∏°‡∏∑‡∏≠‡∏á < ‡πÄ‡∏Å‡∏ì‡∏ë‡πå / ‡∏ä‡∏ô‡∏ö‡∏ó)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF0000; border-color: #8B4513; border-width: 2px;"></div>
                    <span>‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏° (‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏°‡∏∑‡∏≠‡∏á ‚â• ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF0000; border-color: #8B0000;"></div>
                    <span>‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏° (Buffer ‡πÄ‡∏°‡∏∑‡∏≠‡∏á < ‡πÄ‡∏Å‡∏ì‡∏ë‡πå / ‡∏ä‡∏ô‡∏ö‡∏ó)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9370DB; border-color: #8B4513; border-width: 2px;"></div>
                    <span>‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏° (‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏°‡∏∑‡∏≠‡∏á ‚â• ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #9370DB; border-color: #4B0082;"></div>
                    <span>‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏° (Buffer ‡πÄ‡∏°‡∏∑‡∏≠‡∏á < ‡πÄ‡∏Å‡∏ì‡∏ë‡πå / ‡∏ä‡∏ô‡∏ö‡∏ó)</span>
                </div>
                
                <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px; border-left: 4px solid #ffc107;">
                    <div style="font-weight: bold; margin-bottom: 5px; color: #856404;">üí° ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢:</div>
                    <div style="font-size: 12px; color: #856404; line-height: 1.6;">
                        <strong>‚â• ‡πÄ‡∏Å‡∏ì‡∏ë‡πå:</strong> ‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô ‚â• ‡πÄ‡∏Å‡∏ì‡∏ë‡πå% ‚Üí ‡πÉ‡∏ä‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏õ‡∏•‡∏á (‡∏Ç‡∏≠‡∏ö‡∏ô‡πâ‡∏≥‡∏ï‡∏≤‡∏•)<br>
                        <strong>< ‡πÄ‡∏Å‡∏ì‡∏ë‡πå:</strong> ‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô < ‡πÄ‡∏Å‡∏ì‡∏ë‡πå% ‚Üí Buffer ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏Ç‡∏≠‡∏ö‡∏™‡∏µ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó)<br>
                        <strong>‡∏ä‡∏ô‡∏ö‡∏ó:</strong> Buffer ‡∏ó‡∏∏‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
                    </div>
                </div>
            </div>

            <!-- Layer Control -->
            <div class="legend" id="layerControl" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px;">
                    <div style="font-weight: bold;">üóÇÔ∏è ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏ä‡∏±‡πâ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</div>
                    <div style="display: flex; gap: 5px;">
                        <button id="showAllLayers" style="padding: 4px 8px; font-size: 11px; background: #27ae60;">‡πÄ‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                        <button id="hideAllLayers" style="padding: 4px 8px; font-size: 11px; background: #e74c3c;">‡∏õ‡∏¥‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
                    </div>
                </div>
                
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #555; font-size: 14px;">üìÅ ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö</div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleBuildings" checked>
                        <label for="toggleBuildings" style="margin: 0; cursor: pointer;">
                            <span style="color: #FF69B4; font-weight: bold;">‚ñ†</span> ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
                        </label>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleParcels" checked>
                        <label for="toggleParcels" style="margin: 0; cursor: pointer;">
                            <span style="color: #8B4513; font-weight: bold;">‚ñ†</span> ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô
                        </label>
                    </div>
                </div>

                <div id="resultLayersSection" style="display: none;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #555; font-size: 14px;">üìä ‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå</div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleResidential" checked>
                        <label for="toggleResidential" style="margin: 0; cursor: pointer;">
                            <span style="color: #FFFF00; background: #333; padding: 2px 4px; border-radius: 2px;">‚ñ†</span> ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢
                        </label>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleCommercial" checked>
                        <label for="toggleCommercial" style="margin: 0; cursor: pointer;">
                            <span style="color: #FF0000; font-weight: bold;">‚ñ†</span> ‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°
                        </label>
                    </div>
                    <div class="layer-item">
                        <input type="checkbox" id="toggleIndustrial" checked>
                        <label for="toggleIndustrial" style="margin: 0; cursor: pointer;">
                            <span style="color: #9370DB; font-weight: bold;">‚ñ†</span> ‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/shpjs@5.0.1/dist/shp.min.js"></script>
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <script>
        proj4.defs("EPSG:32647", "+proj=utm +zone=47 +datum=WGS84 +units=m +no_defs");
        proj4.defs("EPSG:32648", "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs");

        let map, buildingData = null, parcelData = null, buildingLayer = null, parcelLayer = null;
        let residentialLayer = null, commercialLayer = null, industrialLayer = null;
        let urbanConfig = { urban: [], rural: [] };

        function initMap() {
            map = L.map('map').setView([13.7563, 100.5018], 6);
            L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
                attribution: '¬© Google',
                maxZoom: 20
            }).addTo(map);
        }

        function transformCoordinates(coords, sourceProj) {
            if (!sourceProj || sourceProj === 'EPSG:4326') return coords;
            const transform = (coord) => {
                if (Array.isArray(coord[0])) return coord.map(c => transform(c));
                const [lon, lat] = proj4(sourceProj, 'EPSG:4326', coord);
                return [lon, lat];
            };
            return transform(coords);
        }

        function transformBackToUTM(coords, targetEPSG) {
            if (!targetEPSG || targetEPSG === 'EPSG:4326') return coords;
            const transform = (coord) => {
                if (Array.isArray(coord[0])) return coord.map(c => transform(c));
                const [x, y] = proj4('EPSG:4326', targetEPSG, coord);
                return [x, y];
            };
            return transform(coords);
        }

        async function loadShapefile(zipFile, selectedEPSG) {
            const zip = await JSZip.loadAsync(zipFile);
            let shpBuffer, dbfBuffer, cpgEncoding = null;
            
            // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô ZIP
            for (let filename in zip.files) {
                const file = zip.files[filename];
                const lowerName = filename.toLowerCase();
                if (lowerName.endsWith('.shp')) {
                    shpBuffer = await file.async('arraybuffer');
                } else if (lowerName.endsWith('.dbf')) {
                    dbfBuffer = await file.async('arraybuffer');
                } else if (lowerName.endsWith('.cpg')) {
                    // ‡∏≠‡πà‡∏≤‡∏ô encoding ‡∏à‡∏≤‡∏Å .cpg file
                    const cpgText = await file.async('string');
                    cpgEncoding = cpgText.trim();
                }
            }
            
            if (!shpBuffer || !dbfBuffer) throw new Error('‡πÑ‡∏ü‡∏•‡πå zip ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ .shp ‡πÅ‡∏•‡∏∞ .dbf');
            
            // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ .cpg ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö encoding ‡∏à‡∏≤‡∏Å DBF header
            if (!cpgEncoding) {
                const dbfView = new DataView(dbfBuffer);
                const languageDriver = dbfView.getUint8(29);
                
                // Language driver byte (offset 29) ‡∏ö‡∏≠‡∏Å encoding
                if (languageDriver === 0x03 || languageDriver === 0x57) {
                    cpgEncoding = 'UTF-8';
                } else if (languageDriver === 0x7C) {
                    cpgEncoding = 'windows-874'; // Thai
                } else {
                    // Default ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á UTF-8 ‡∏Å‡πà‡∏≠‡∏ô
                    cpgEncoding = 'UTF-8';
                }
            }
            
            console.log(`üìñ ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå Shapefile ‡∏î‡πâ‡∏ß‡∏¢ encoding: ${cpgEncoding}`);
            
            // Parse shapefile ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ encoding ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
            const geojson = await parseShapefileWithEncoding(shpBuffer, dbfBuffer, cpgEncoding);

            // Transform coordinates ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
            if (selectedEPSG !== 'EPSG:4326') {
                geojson.features.forEach(feature => {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates, selectedEPSG);
                    } else if (feature.geometry.type === 'MultiPolygon') {
                        feature.geometry.coordinates = feature.geometry.coordinates.map(p => transformCoordinates(p, selectedEPSG));
                    }
                });
            }
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• encoding ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ
            geojson.encoding = cpgEncoding;
            
            return geojson;
        }

        async function parseShapefileWithEncoding(shpBuffer, dbfBuffer, encoding) {
            // Parse geometry ‡∏à‡∏≤‡∏Å SHP
            const geometries = shp.parseShp(shpBuffer);
            
            // Parse attributes ‡∏à‡∏≤‡∏Å DBF ‡∏î‡πâ‡∏ß‡∏¢ custom parser ‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö encoding
            const attributes = parseDbfWithEncoding(dbfBuffer, encoding);
            
            // Combine geometry ‡πÅ‡∏•‡∏∞ attributes ‡πÄ‡∏õ‡πá‡∏ô GeoJSON
            const features = [];
            for (let i = 0; i < Math.min(geometries.length, attributes.length); i++) {
                features.push({
                    type: 'Feature',
                    geometry: geometries[i],
                    properties: attributes[i]
                });
            }
            
            return {
                type: 'FeatureCollection',
                features: features
            };
        }

        function parseDbfWithEncoding(buffer, encoding) {
            const view = new DataView(buffer);
            
            // ‡∏≠‡πà‡∏≤‡∏ô DBF header
            const recordCount = view.getUint32(4, true);
            const headerLength = view.getUint16(8, true);
            const recordLength = view.getUint16(10, true);
            
            // ‡∏≠‡πà‡∏≤‡∏ô field descriptors
            const fields = [];
            let offset = 32;
            while (offset < headerLength - 1) {
                const fieldName = getStringFromBuffer(buffer, offset, 11, 'ASCII').replace(/\0/g, '');
                const fieldType = String.fromCharCode(view.getUint8(offset + 11));
                const fieldLength = view.getUint8(offset + 16);
                const decimalCount = view.getUint8(offset + 17);
                
                fields.push({
                    name: fieldName,
                    type: fieldType,
                    length: fieldLength,
                    decimal: decimalCount
                });
                offset += 32;
            }
            
            // ‡∏≠‡πà‡∏≤‡∏ô records
            const records = [];
            offset = headerLength;
            
            // ‡πÅ‡∏õ‡∏•‡∏á encoding ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢
            const actualEncoding = getActualEncoding(encoding);
            
            for (let i = 0; i < recordCount; i++) {
                const record = {};
                let fieldOffset = offset + 1; // Skip deletion flag
                
                for (const field of fields) {
                    const rawValue = buffer.slice(fieldOffset, fieldOffset + field.length);
                    let value;
                    
                    if (field.type === 'C') {
                        // Character field - ‡πÉ‡∏ä‡πâ encoding ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
                        value = getStringFromBuffer(rawValue, 0, field.length, actualEncoding).trim();
                    } else if (field.type === 'N' || field.type === 'F') {
                        // Numeric field
                        const str = getStringFromBuffer(rawValue, 0, field.length, 'ASCII').trim();
                        value = str === '' ? null : parseFloat(str);
                    } else if (field.type === 'L') {
                        // Logical field
                        const char = String.fromCharCode(view.getUint8(fieldOffset));
                        value = char === 'T' || char === 't' || char === 'Y' || char === 'y';
                    } else if (field.type === 'D') {
                        // Date field
                        value = getStringFromBuffer(rawValue, 0, field.length, 'ASCII').trim();
                    } else {
                        // Other types
                        value = getStringFromBuffer(rawValue, 0, field.length, actualEncoding).trim();
                    }
                    
                    record[field.name] = value;
                    fieldOffset += field.length;
                }
                
                records.push(record);
                offset += recordLength;
            }
            
            return records;
        }

        function getActualEncoding(encoding) {
            // ‡πÅ‡∏õ‡∏•‡∏á encoding name ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà TextDecoder ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö
            const encodingMap = {
                'UTF-8': 'utf-8',
                'UTF8': 'utf-8',
                'TIS-620': 'windows-874',  // TIS-620 = CP874 = windows-874
                'TIS620': 'windows-874',
                'CP874': 'windows-874',
                'WINDOWS-874': 'windows-874',
                'ISO-8859-11': 'windows-874',
                'THAI': 'windows-874'
            };
            
            const upper = encoding.toUpperCase().replace(/[^A-Z0-9]/g, '');
            return encodingMap[upper] || 'utf-8';
        }

        function getStringFromBuffer(buffer, start, length, encoding) {
            const bytes = new Uint8Array(buffer, start, length);
            
            try {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(bytes);
            } catch (e) {
                // Fallback to UTF-8 if encoding not supported
                console.warn(`Encoding ${encoding} not supported, using UTF-8`);
                const decoder = new TextDecoder('utf-8');
                return decoder.decode(bytes);
            }
        }

        function updateBuildingColors(landUseField) {
            if (!buildingLayer || !buildingData) return;
            map.removeLayer(buildingLayer);
            
            buildingLayer = L.geoJSON(buildingData, {
                style: (feature) => {
                    const landUse = String(feature.properties[landUseField] || '');
                    let color = '#FF69B4';
                    if (landUse === '10' || landUse === '10.0') color = '#FFD700';
                    else if (landUse === '20' || landUse === '20.0' || landUse === '41' || landUse === '41.0') color = '#FF0000';
                    else if (landUse === '30' || landUse === '30.0' || landUse === '33' || landUse === '33.0') color = '#9370DB';
                    return { color: color, weight: 2, fillOpacity: 0 };
                },
                onEachFeature: (feature, layer) => {
                    const props = feature.properties;
                    let popup = `<strong>‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£</strong><br>`;
                    for (let key in props) popup += `${key}: ${props[key]}<br>`;
                    layer.bindPopup(popup);
                }
            }).addTo(map);
            buildingLayer.bringToFront();
        }

        function updateParcelColors(urbanField) {
            if (!parcelLayer || !parcelData) return;
            map.removeLayer(parcelLayer);
            
            parcelLayer = L.geoJSON(parcelData, {
                style: (feature) => {
                    const urbanValue = String(feature.properties[urbanField] || '');
                    const isUrban = urbanConfig.urban.includes(urbanValue);
                    return { color: isUrban ? '#8B4513' : '#000000', weight: isUrban ? 2 : 1, fillOpacity: 0 };
                },
                onEachFeature: (feature, layer) => {
                    const props = feature.properties;
                    let popup = `<strong>‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô</strong><br>`;
                    for (let key in props) popup += `${key}: ${props[key]}<br>`;
                    layer.bindPopup(popup);
                }
            }).addTo(map);
            parcelLayer.bringToBack();
        }

        function showStatus(elementId, type, message) {
            const element = document.getElementById(elementId);
            element.className = `status ${type}`;
            element.textContent = message;
            element.style.display = 'block';
        }

        function updateUrbanSummary() {
            document.getElementById('urbanCount').textContent = `${urbanConfig.urban.length} ‡∏Ñ‡πà‡∏≤`;
            document.getElementById('ruralCount').textContent = `${urbanConfig.rural.length} ‡∏Ñ‡πà‡∏≤`;
        }

        function updateProgress(message) {
            const progressDiv = document.getElementById('processingProgress');
            progressDiv.style.display = 'block';
            progressDiv.textContent = message;
            console.log(message);
        }

        async function processAllLandUse() {
            const landUseField = document.getElementById('landUseField').value;
            const urbanField = document.getElementById('urbanField').value;

            if (!buildingData || !parcelData || !landUseField || !urbanField) {
                showStatus('processStatus', 'error', '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô');
                return;
            }

            // ‡∏•‡πâ‡∏≤‡∏á status ‡πÅ‡∏•‡∏∞ progress ‡πÄ‡∏Å‡πà‡∏≤
            document.getElementById('processStatus').style.display = 'none';
            document.getElementById('processingProgress').style.display = 'none';
            
            document.getElementById('processing').classList.add('active');
            document.getElementById('processBtn').disabled = true;

            setTimeout(async () => {
                try {
                    const coverageThreshold = parseFloat(document.getElementById('coverageThreshold').value) || 20;
                    updateProgress(`üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•... (‡πÄ‡∏Å‡∏ì‡∏ë‡πå ${coverageThreshold}%)`);
                    const startTime = performance.now();

                    const results = {
                        residential: { type: 'FeatureCollection', features: [] },
                        commercial: { type: 'FeatureCollection', features: [] },
                        industrial: { type: 'FeatureCollection', features: [] }
                    };

                    updateProgress('üèòÔ∏è ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢...');
                    await processLandUse(['10'], landUseField, urbanField, 3, results.residential);

                    updateProgress('üè™ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°...');
                    await processLandUse(['20', '41'], landUseField, urbanField, 3, results.commercial);

                    updateProgress('üè≠ ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°...');
                    await processIndustrial(landUseField, urbanField, results.industrial);

                    updateProgress('üîß ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô...');
                    await resolveOverlaps(results);

                    updateProgress('üó∫Ô∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà...');
                    
                    window.residentialResult = results.residential;
                    window.commercialResult = results.commercial;
                    window.industrialResult = results.industrial;

                    await displayResults(results.residential, results.commercial, results.industrial);

                    // ‡∏ã‡πà‡∏≠‡∏ô progress ‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á success ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
                    document.getElementById('processingProgress').style.display = 'none';
                    
                    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
                    showStatus('processStatus', 'success', 
                        `‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢: ${results.residential.features.length} | ‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå: ${results.commercial.features.length} | ‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°: ${results.industrial.features.length} (‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤ ${duration} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)`);

                } catch (error) {
                    console.error('Error:', error);
                    document.getElementById('processingProgress').style.display = 'none';
                    showStatus('processStatus', 'error', `‚ùå ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}`);
                } finally {
                    document.getElementById('processing').classList.remove('active');
                    document.getElementById('processBtn').disabled = false;
                }
            }, 100);
        }

        async function processLandUse(landUseCodes, landUseField, urbanField, bufferDist, resultData) {
            const coverageThreshold = parseFloat(document.getElementById('coverageThreshold').value) || 20;
            const BATCH_SIZE = 100; // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ó‡∏µ‡∏•‡∏∞ 100 ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
            
            const allCodes = [];
            landUseCodes.forEach(code => {
                allCodes.push(code);
                allCodes.push(code + '.0');
            });

            const filtered = buildingData.features.filter(f => {
                const landUse = String(f.properties[landUseField] || '');
                return allCodes.includes(landUse);
            });

            const urbanBldg = filtered.filter(f => urbanConfig.urban.includes(String(f.properties[urbanField])));
            const ruralBldg = filtered.filter(f => urbanConfig.rural.includes(String(f.properties[urbanField])));

            const parcelMap = new Map();

            // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏ö‡∏ö batch
            for (let i = 0; i < urbanBldg.length; i += BATCH_SIZE) {
                const batch = urbanBldg.slice(i, i + BATCH_SIZE);
                
                for (const building of batch) {
                    try {
                        const centroid = turf.centroid(building);
                        for (const parcel of parcelData.features) {
                            try {
                                const parcelPoly = turf.polygon(parcel.geometry.coordinates);
                                if (turf.booleanPointInPolygon(centroid, parcelPoly)) {
                                    const key = JSON.stringify(parcel.geometry.coordinates);
                                    if (!parcelMap.has(key)) {
                                        parcelMap.set(key, {
                                            parcel: parcel,
                                            buildings: [],
                                            totalBL: 0,
                                            area: turf.area(parcelPoly)
                                        });
                                    }
                                    const data = parcelMap.get(key);
                                    data.buildings.push(building);
                                    data.totalBL += parseFloat(building.properties.BL_AREA || 0);
                                    break;
                                }
                            } catch (e) {}
                        }
                    } catch (e) {}
                }
                
                // ‡πÉ‡∏´‡πâ browser ‡∏´‡∏≤‡∏¢‡πÉ‡∏à
                if (i % (BATCH_SIZE * 3) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á features ‡∏à‡∏≤‡∏Å parcel map
            for (const [key, data] of parcelMap) {
                const percent = (data.totalBL / data.area) * 100;
                
                if (percent >= coverageThreshold) {
                    resultData.features.push({
                        type: 'Feature',
                        geometry: data.parcel.geometry,
                        properties: {
                            land_use: getLandUseType(allCodes[0]),
                            area_type: 'urban',
                            source: 'parcel_overlay',
                            parcel_area: parseFloat(data.area.toFixed(2)),
                            bl_area_total: parseFloat(data.totalBL.toFixed(2)),
                            coverage_percent: parseFloat(percent.toFixed(2))
                        }
                    });
                } else {
                    for (const bldg of data.buildings) {
                        try {
                            const buffered = turf.buffer(bldg, bufferDist, { units: 'meters' });
                            if (buffered) {
                                resultData.features.push({
                                    type: 'Feature',
                                    geometry: buffered.geometry,
                                    properties: {
                                        land_use: getLandUseType(allCodes[0]),
                                        area_type: 'urban_low_coverage',
                                        source: 'building_buffer',
                                        parcel_area: parseFloat(data.area.toFixed(2)),
                                        bl_area_total: parseFloat(data.totalBL.toFixed(2)),
                                        coverage_percent: parseFloat(percent.toFixed(2)),
                                        bl_area: parseFloat(bldg.properties.BL_AREA || 0),
                                        buffer_distance: bufferDist
                                    }
                                });
                            }
                        } catch (e) {}
                    }
                }
            }

            // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ä‡∏ô‡∏ö‡∏ó‡πÅ‡∏ö‡∏ö batch
            for (let i = 0; i < ruralBldg.length; i += BATCH_SIZE) {
                const batch = ruralBldg.slice(i, i + BATCH_SIZE);
                
                for (const building of batch) {
                    try {
                        const buffered = turf.buffer(building, bufferDist, { units: 'meters' });
                        if (buffered) {
                            resultData.features.push({
                                type: 'Feature',
                                geometry: buffered.geometry,
                                properties: {
                                    land_use: getLandUseType(allCodes[0]),
                                    area_type: 'rural',
                                    source: 'building_buffer',
                                    bl_area: parseFloat(building.properties.BL_AREA || 0),
                                    buffer_distance: bufferDist
                                }
                            });
                        }
                    } catch (e) {}
                }
                
                // ‡πÉ‡∏´‡πâ browser ‡∏´‡∏≤‡∏¢‡πÉ‡∏à
                if (i % (BATCH_SIZE * 3) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
        }

        async function processIndustrial(landUseField, urbanField, resultData) {
            const coverageThreshold = parseFloat(document.getElementById('coverageThreshold').value) || 20;
            const BATCH_SIZE = 100;
            const codes = ['30', '30.0', '33', '33.0'];
            const filtered = buildingData.features.filter(f => codes.includes(String(f.properties[landUseField] || '')));
            const urbanBldg = filtered.filter(f => urbanConfig.urban.includes(String(f.properties[urbanField])));
            const ruralBldg = filtered.filter(f => urbanConfig.rural.includes(String(f.properties[urbanField])));

            const parcelMap = new Map();
            
            // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÄ‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏ö‡∏ö batch
            for (let i = 0; i < urbanBldg.length; i += BATCH_SIZE) {
                const batch = urbanBldg.slice(i, i + BATCH_SIZE);
                
                for (const building of batch) {
                    try {
                        const centroid = turf.centroid(building);
                        for (const parcel of parcelData.features) {
                            try {
                                const parcelPoly = turf.polygon(parcel.geometry.coordinates);
                                if (turf.booleanPointInPolygon(centroid, parcelPoly)) {
                                    const key = JSON.stringify(parcel.geometry.coordinates);
                                    if (!parcelMap.has(key)) {
                                        parcelMap.set(key, {
                                            parcel: parcel,
                                            buildings: [],
                                            totalBL: 0,
                                            area: turf.area(parcelPoly)
                                        });
                                    }
                                    const data = parcelMap.get(key);
                                    data.buildings.push(building);
                                    data.totalBL += parseFloat(building.properties.BL_AREA || 0);
                                    break;
                                }
                            } catch (e) {}
                        }
                    } catch (e) {}
                }
                
                // ‡πÉ‡∏´‡πâ browser ‡∏´‡∏≤‡∏¢‡πÉ‡∏à
                if (i % (BATCH_SIZE * 3) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            for (const [key, data] of parcelMap) {
                const percent = (data.totalBL / data.area) * 100;
                
                if (percent >= coverageThreshold) {
                    resultData.features.push({
                        type: 'Feature',
                        geometry: data.parcel.geometry,
                        properties: {
                            land_use: 'industrial',
                            area_type: 'urban',
                            source: 'parcel_overlay',
                            parcel_area: parseFloat(data.area.toFixed(2)),
                            bl_area_total: parseFloat(data.totalBL.toFixed(2)),
                            coverage_percent: parseFloat(percent.toFixed(2))
                        }
                    });
                } else {
                    for (const bldg of data.buildings) {
                        try {
                            const blArea = parseFloat(bldg.properties.BL_AREA || 0);
                            let bufferDist = 3;
                            if (blArea >= 200 && blArea <= 1000) bufferDist = 6;
                            else if (blArea > 1000) bufferDist = 10;
                            
                            const buffered = turf.buffer(bldg, bufferDist, { units: 'meters' });
                            if (buffered) {
                                resultData.features.push({
                                    type: 'Feature',
                                    geometry: buffered.geometry,
                                    properties: {
                                        land_use: 'industrial',
                                        area_type: 'urban_low_coverage',
                                        source: 'building_buffer',
                                        parcel_area: parseFloat(data.area.toFixed(2)),
                                        bl_area_total: parseFloat(data.totalBL.toFixed(2)),
                                        coverage_percent: parseFloat(percent.toFixed(2)),
                                        bl_area: blArea,
                                        buffer_distance: bufferDist
                                    }
                                });
                            }
                        } catch (e) {}
                    }
                }
            }

            // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ä‡∏ô‡∏ö‡∏ó‡πÅ‡∏ö‡∏ö batch
            for (let i = 0; i < ruralBldg.length; i += BATCH_SIZE) {
                const batch = ruralBldg.slice(i, i + BATCH_SIZE);
                
                for (const building of batch) {
                    try {
                        const blArea = parseFloat(building.properties.BL_AREA || 0);
                        let bufferDist = 3;
                        if (blArea >= 200 && blArea <= 1000) bufferDist = 6;
                        else if (blArea > 1000) bufferDist = 10;
                        
                        const buffered = turf.buffer(building, bufferDist, { units: 'meters' });
                        if (buffered) {
                            resultData.features.push({
                                type: 'Feature',
                                geometry: buffered.geometry,
                                properties: {
                                    land_use: 'industrial',
                                    area_type: 'rural',
                                    source: 'building_buffer',
                                    bl_area: blArea,
                                    buffer_distance: bufferDist
                                }
                            });
                        }
                    } catch (e) {}
                }
                
                // ‡πÉ‡∏´‡πâ browser ‡∏´‡∏≤‡∏¢‡πÉ‡∏à
                if (i % (BATCH_SIZE * 3) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
        }

        async function resolveOverlaps(results) {
            const BATCH_SIZE = 50;
            
            // ‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏° ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢
            const residentialToKeep = [];
            for (let i = 0; i < results.residential.features.length; i += BATCH_SIZE) {
                const batch = results.residential.features.slice(i, i + BATCH_SIZE);
                
                for (const res of batch) {
                    let shouldKeep = true;
                    for (const com of results.commercial.features) {
                        try {
                            if (turf.booleanIntersects(res, com)) {
                                shouldKeep = false;
                                break;
                            }
                        } catch (e) {}
                    }
                    if (shouldKeep) {
                        residentialToKeep.push(res);
                    }
                }
                
                // ‡πÉ‡∏´‡πâ browser ‡∏´‡∏≤‡∏¢‡πÉ‡∏à
                if (i % (BATCH_SIZE * 5) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                    updateProgress(`üîß ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô... (‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢ ${Math.min(i + BATCH_SIZE, results.residential.features.length)}/${results.residential.features.length})`);
                }
            }
            results.residential.features = residentialToKeep;

            // ‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏° ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢
            const residentialToKeep2 = [];
            for (let i = 0; i < results.residential.features.length; i += BATCH_SIZE) {
                const batch = results.residential.features.slice(i, i + BATCH_SIZE);
                
                for (const res of batch) {
                    let shouldKeep = true;
                    for (const ind of results.industrial.features) {
                        try {
                            if (turf.booleanIntersects(res, ind)) {
                                shouldKeep = false;
                                break;
                            }
                        } catch (e) {}
                    }
                    if (shouldKeep) {
                        residentialToKeep2.push(res);
                    }
                }
                
                if (i % (BATCH_SIZE * 5) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            results.residential.features = residentialToKeep2;

            // ‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏° ‡πÅ‡∏ó‡∏ô‡∏ó‡∏µ‡πà ‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°
            const commercialToKeep = [];
            for (let i = 0; i < results.commercial.features.length; i += BATCH_SIZE) {
                const batch = results.commercial.features.slice(i, i + BATCH_SIZE);
                
                for (const com of batch) {
                    let shouldKeep = true;
                    for (const ind of results.industrial.features) {
                        try {
                            if (turf.booleanIntersects(com, ind)) {
                                shouldKeep = false;
                                break;
                            }
                        } catch (e) {}
                    }
                    if (shouldKeep) {
                        commercialToKeep.push(com);
                    }
                }
                
                if (i % (BATCH_SIZE * 5) === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                    updateProgress(`üîß ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ó‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô... (‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏° ${Math.min(i + BATCH_SIZE, results.commercial.features.length)}/${results.commercial.features.length})`);
                }
            }
            results.commercial.features = commercialToKeep;
        }

        function getLandUseType(code) {
            if (code === '10' || code === '10.0') return 'residential';
            if (code === '20' || code === '20.0' || code === '41' || code === '41.0') return 'commercial';
            if (code === '30' || code === '30.0' || code === '33' || code === '33.0') return 'industrial';
            return 'unknown';
        }

        async function displayResults(residential, commercial, industrial) {
            // ‡∏•‡∏ö result layers ‡πÄ‡∏Å‡πà‡∏≤
            if (residentialLayer) map.removeLayer(residentialLayer);
            if (commercialLayer) map.removeLayer(commercialLayer);
            if (industrialLayer) map.removeLayer(industrialLayer);

            let allBounds = null;

            function createPopup(feature, type, color) {
                const props = feature.properties;
                let popup = `<div style="font-family: 'Sarabun', sans-serif; min-width: 250px;">`;
                popup += `<h3 style="margin: 0 0 10px 0; padding: 8px; background: ${color}; color: white; border-radius: 4px; text-align: center;">${type}</h3>`;
                popup += `<table style="width: 100%; border-collapse: collapse;">`;
                
                if (props.source === 'parcel_overlay') {
                    popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà:</td><td style="padding: 8px;">‡πÄ‡∏°‡∏∑‡∏≠‡∏á</td></tr>`;
                    popup += `<tr><td style="padding: 8px; font-weight: bold;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á:</td><td style="padding: 8px;">${props.parcel_area.toLocaleString('th-TH')} ‡∏ï‡∏£.‡∏°.</td></tr>`;
                    popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°:</td><td style="padding: 8px;">${props.bl_area_total.toLocaleString('th-TH')} ‡∏ï‡∏£.‡∏°.</td></tr>`;
                    const percentColor = props.coverage_percent >= 20 ? '#27ae60' : '#e67e22';
                    popup += `<tr><td style="padding: 8px; font-weight: bold;">‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô:</td><td style="padding: 8px; color: ${percentColor}; font-weight: bold;">${props.coverage_percent}%</td></tr>`;
                } else if (props.area_type === 'urban_low_coverage') {
                    popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà:</td><td style="padding: 8px;">‡πÄ‡∏°‡∏∑‡∏≠‡∏á (< ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)</td></tr>`;
                    popup += `<tr><td style="padding: 8px; font-weight: bold;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á:</td><td style="padding: 8px;">${props.parcel_area.toLocaleString('th-TH')} ‡∏ï‡∏£.‡∏°.</td></tr>`;
                    popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°:</td><td style="padding: 8px;">${props.bl_area_total.toLocaleString('th-TH')} ‡∏ï‡∏£.‡∏°.</td></tr>`;
                    popup += `<tr><td style="padding: 8px; font-weight: bold;">‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô:</td><td style="padding: 8px; color: #e67e22; font-weight: bold;">${props.coverage_percent}%</td></tr>`;
                    popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ô‡∏µ‡πâ:</td><td style="padding: 8px;">${props.bl_area.toLocaleString('th-TH')} ‡∏ï‡∏£.‡∏°.</td></tr>`;
                    popup += `<tr><td style="padding: 8px; font-weight: bold;">‡∏£‡∏∞‡∏¢‡∏∞ Buffer:</td><td style="padding: 8px;">${props.buffer_distance} ‡πÄ‡∏°‡∏ï‡∏£</td></tr>`;
                } else {
                    popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà:</td><td style="padding: 8px;">‡∏ä‡∏ô‡∏ö‡∏ó</td></tr>`;
                    if (props.bl_area) {
                        popup += `<tr><td style="padding: 8px; font-weight: bold;">‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£:</td><td style="padding: 8px;">${props.bl_area.toLocaleString('th-TH')} ‡∏ï‡∏£.‡∏°.</td></tr>`;
                    }
                    if (props.buffer_distance) {
                        popup += `<tr style="background: #f8f9fa;"><td style="padding: 8px; font-weight: bold;">‡∏£‡∏∞‡∏¢‡∏∞ Buffer:</td><td style="padding: 8px;">${props.buffer_distance} ‡πÄ‡∏°‡∏ï‡∏£</td></tr>`;
                    }
                }
                
                popup += `</table></div>`;
                return popup;
            }

            function getStyle(feature, fillColor, borderColor) {
                if (feature.properties.source === 'parcel_overlay' && feature.properties.area_type === 'urban') {
                    return { color: '#8B4513', weight: 2, fillColor: fillColor, fillOpacity: 0.6 };
                }
                return { color: borderColor, weight: 1, fillColor: fillColor, fillOpacity: 0.6 };
            }

            // ‡∏™‡∏£‡πâ‡∏≤‡∏á layers ‡∏ó‡∏µ‡∏•‡∏∞‡∏≠‡∏±‡∏ô ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ UI responsive
            if (residential.features.length > 0) {
                updateProgress('üèòÔ∏è ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢...');
                await new Promise(resolve => setTimeout(resolve, 50));
                
                residentialLayer = L.geoJSON(residential, {
                    style: (f) => getStyle(f, '#FFFF00', '#FFA500'),
                    onEachFeature: (f, l) => l.bindPopup(createPopup(f, '‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢', '#f39c12'))
                }).addTo(map);
                allBounds = residentialLayer.getBounds();
            }

            if (commercial.features.length > 0) {
                updateProgress('üè™ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°...');
                await new Promise(resolve => setTimeout(resolve, 50));
                
                commercialLayer = L.geoJSON(commercial, {
                    style: (f) => getStyle(f, '#FF0000', '#8B0000'),
                    onEachFeature: (f, l) => l.bindPopup(createPopup(f, '‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°', '#e74c3c'))
                }).addTo(map);
                if (allBounds) allBounds.extend(commercialLayer.getBounds());
                else allBounds = commercialLayer.getBounds();
            }

            if (industrial.features.length > 0) {
                updateProgress('üè≠ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°...');
                await new Promise(resolve => setTimeout(resolve, 50));
                
                industrialLayer = L.geoJSON(industrial, {
                    style: (f) => getStyle(f, '#9370DB', '#4B0082'),
                    onEachFeature: (f, l) => l.bindPopup(createPopup(f, '‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°', '#9b59b6'))
                }).addTo(map);
                if (allBounds) allBounds.extend(industrialLayer.getBounds());
                else allBounds = industrialLayer.getBounds();
            }

            if (parcelLayer) parcelLayer.bringToBack();
            if (buildingLayer) buildingLayer.bringToFront();
            if (allBounds && allBounds.isValid()) map.fitBounds(allBounds);
            
            const selectedEPSG = document.getElementById('epsgSelect').value;
            const coverageThreshold = parseFloat(document.getElementById('coverageThreshold').value) || 20;
            document.getElementById('exportEPSG').textContent = selectedEPSG;
            document.getElementById('exportThreshold').textContent = `${coverageThreshold}%`;
            
            // Reset checkboxes ‡πÄ‡∏õ‡πá‡∏ô checked
            document.getElementById('toggleResidential').checked = true;
            document.getElementById('toggleCommercial').checked = true;
            document.getElementById('toggleIndustrial').checked = true;
            
            document.getElementById('legend').style.display = 'block';
            document.getElementById('layerControl').style.display = 'block';
            document.getElementById('resultLayersSection').style.display = 'block';
            document.getElementById('exportSection').style.display = 'block';
            
            // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô layer toggles
            setupLayerToggles();
        }

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ layer toggle controls ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö base layers (‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÅ‡∏•‡∏∞‡πÅ‡∏õ‡∏•‡∏á)
        function setupBaseLayerToggles() {
            const buildingToggle = document.getElementById('toggleBuildings');
            const parcelToggle = document.getElementById('toggleParcels');
            
            // ‡∏•‡∏ö event listeners ‡πÄ‡∏Å‡πà‡∏≤ (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
            const newBuildingToggle = buildingToggle.cloneNode(true);
            buildingToggle.parentNode.replaceChild(newBuildingToggle, buildingToggle);
            
            const newParcelToggle = parcelToggle.cloneNode(true);
            parcelToggle.parentNode.replaceChild(newParcelToggle, parcelToggle);
            
            // ‡πÄ‡∏û‡∏¥‡πà‡∏° event listeners ‡πÉ‡∏´‡∏°‡πà
            document.getElementById('toggleBuildings').addEventListener('change', function(e) {
                if (buildingLayer) {
                    if (e.target.checked) {
                        map.addLayer(buildingLayer);
                        buildingLayer.bringToFront();
                    } else {
                        map.removeLayer(buildingLayer);
                    }
                }
            });

            document.getElementById('toggleParcels').addEventListener('change', function(e) {
                if (parcelLayer) {
                    if (e.target.checked) {
                        map.addLayer(parcelLayer);
                        parcelLayer.bringToBack();
                    } else {
                        map.removeLayer(parcelLayer);
                    }
                }
            });
        }

        // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ layer toggle controls ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö result layers
        function setupLayerToggles() {
            const residentialToggle = document.getElementById('toggleResidential');
            const commercialToggle = document.getElementById('toggleCommercial');
            const industrialToggle = document.getElementById('toggleIndustrial');
            
            // ‡∏•‡∏ö event listeners ‡πÄ‡∏Å‡πà‡∏≤ ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£ clone ‡πÅ‡∏•‡∏∞ replace
            const newResToggle = residentialToggle.cloneNode(true);
            residentialToggle.parentNode.replaceChild(newResToggle, residentialToggle);
            
            const newComToggle = commercialToggle.cloneNode(true);
            commercialToggle.parentNode.replaceChild(newComToggle, commercialToggle);
            
            const newIndToggle = industrialToggle.cloneNode(true);
            industrialToggle.parentNode.replaceChild(newIndToggle, industrialToggle);

            // ‡πÄ‡∏û‡∏¥‡πà‡∏° event listeners ‡πÉ‡∏´‡∏°‡πà
            document.getElementById('toggleResidential').addEventListener('change', function(e) {
                if (residentialLayer) {
                    if (e.target.checked) {
                        map.addLayer(residentialLayer);
                    } else {
                        map.removeLayer(residentialLayer);
                    }
                }
            });

            document.getElementById('toggleCommercial').addEventListener('change', function(e) {
                if (commercialLayer) {
                    if (e.target.checked) {
                        map.addLayer(commercialLayer);
                    } else {
                        map.removeLayer(commercialLayer);
                    }
                }
            });

            document.getElementById('toggleIndustrial').addEventListener('change', function(e) {
                if (industrialLayer) {
                    if (e.target.checked) {
                        map.addLayer(industrialLayer);
                    } else {
                        map.removeLayer(industrialLayer);
                    }
                }
            });
        }

        // ========== Shapefile Export Functions ==========
        
        async function exportShapefile(data, filename) {
            if (!data || data.features.length === 0) {
                alert('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å');
                return;
            }

            try {
                const selectedEPSG = document.getElementById('epsgSelect').value;
                showStatus('processStatus', 'info', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå Shapefile...');
                
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏õ‡πá‡∏ô UTM
                const utmData = {
                    type: 'FeatureCollection',
                    features: data.features.map(feature => {
                        let coords = feature.geometry.coordinates;
                        if (feature.geometry.type === 'Polygon') {
                            coords = transformBackToUTM(coords, selectedEPSG);
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            coords = coords.map(p => transformBackToUTM(p, selectedEPSG));
                        }
                        return {
                            type: 'Feature',
                            geometry: { type: feature.geometry.type, coordinates: coords },
                            properties: feature.properties
                        };
                    })
                };

                // ‡∏™‡∏£‡πâ‡∏≤‡∏á Shapefile
                const zip = new JSZip();
                const baseName = filename.replace(/\.(geojson|zip)$/i, '');
                
                // Get PRJ content
                const prjContent = getPRJContent(selectedEPSG);
                
                // Create shapefile files
                const shpFile = createSHPFile(utmData.features);
                const shxFile = createSHXFile(utmData.features);
                const dbfFile = createDBFFile(utmData.features);
                
                // Add files to ZIP
                zip.file(`${baseName}.shp`, shpFile);
                zip.file(`${baseName}.shx`, shxFile);
                zip.file(`${baseName}.dbf`, dbfFile);
                zip.file(`${baseName}.prj`, prjContent);
                zip.file(`${baseName}.cpg`, 'UTF-8');
                
                // Add original GeoJSON
                zip.file(`${baseName}.geojson`, JSON.stringify(utmData, null, 2));
                
                // Add Field Mapping
                const fieldMapping = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  Field Name Mapping (DBF ‚Üî Original)                        ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

DBF files have limitations on field names:
- Maximum 10 characters
- ASCII characters only

This file maps the shortened field names in the .dbf file
to the original field names.

Format: DBF_FIELD_NAME = Original Field Name
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

LAND_USE     = land_use           (‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô)
AREA_TYPE    = area_type          (‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà: urban/rural)
SOURCE       = source             (‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤: parcel_overlay/building_buffer)
PARCEL_A     = parcel_area        (‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á ‡∏ï‡∏£.‡∏°.)
BL_AREA_TO   = bl_area_total      (‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á ‡∏ï‡∏£.‡∏°.)
COVERAGE_P   = coverage_percent   (‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô)
BL_AREA      = bl_area            (‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß ‡∏ï‡∏£.‡∏°.)
BUFFER_DIS   = buffer_distance    (‡∏£‡∏∞‡∏¢‡∏∞ Buffer ‡πÄ‡∏°‡∏ï‡∏£)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Field Descriptions:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

LAND_USE (land_use):
  - residential  = ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢
  - commercial   = ‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡∏Å‡∏£‡∏£‡∏°
  - industrial   = ‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°

AREA_TYPE (area_type):
  - urban                = ‡πÄ‡∏°‡∏∑‡∏≠‡∏á (‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô >= ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
  - urban_low_coverage   = ‡πÄ‡∏°‡∏∑‡∏≠‡∏á (‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô < ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
  - rural                = ‡∏ä‡∏ô‡∏ö‡∏ó

SOURCE (source):
  - parcel_overlay  = ‡πÉ‡∏ä‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏õ‡∏•‡∏á (‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô >= ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)
  - building_buffer = Buffer ‡∏à‡∏≤‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô < ‡πÄ‡∏Å‡∏ì‡∏ë‡πå)

PARCEL_A (parcel_area):
  - ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏ï‡∏£
  - ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö urban ‡πÅ‡∏•‡∏∞ urban_low_coverage

BL_AREA_TO (bl_area_total):
  - ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏ï‡∏£
  - ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö urban ‡πÅ‡∏•‡∏∞ urban_low_coverage

COVERAGE_P (coverage_percent):
  - ‡πÄ‡∏õ‡∏≠‡∏£‡πå‡πÄ‡∏ã‡πá‡∏ô‡∏ï‡πå‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô = (BL_AREA_TO / PARCEL_A) √ó 100
  - ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö urban ‡πÅ‡∏•‡∏∞ urban_low_coverage

BL_AREA (bl_area):
  - ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ï‡∏±‡∏ß‡πÉ‡∏ô‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏ï‡∏£
  - ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö building_buffer ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô

BUFFER_DIS (buffer_distance):
  - ‡∏£‡∏∞‡∏¢‡∏∞ Buffer ‡∏£‡∏≠‡∏ö‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡πÉ‡∏ô‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏°‡∏ï‡∏£
  - ‡∏°‡∏µ‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö building_buffer ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Encoding: UTF-8
Compatible with: ArcGIS, QGIS, MapInfo
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`;
                zip.file(`${baseName}_fields.txt`, fieldMapping);
                
                // Add README
                const coverageThreshold = parseFloat(document.getElementById('coverageThreshold').value) || 20;
                const readme = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  Shapefile Export - ‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìã ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå:      ${baseName}
‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î:     ${selectedEPSG}
‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á:   ${new Date().toLocaleString('th-TH')}
‡∏à‡∏≥‡∏ô‡∏ß‡∏ô Features: ${utmData.features.length}
‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô: ${coverageThreshold}%

üìÅ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞ Shapefile
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úì .shp          = ‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏£‡∏Ç‡∏≤‡∏Ñ‡∏ì‡∏¥‡∏ï (geometry data)
‚úì .shx          = ‡πÑ‡∏ü‡∏•‡πå‡∏î‡∏±‡∏ä‡∏ô‡∏µ (spatial index)
‚úì .dbf          = ‡πÑ‡∏ü‡∏•‡πå‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (attribute table)
‚úì .prj          = ‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î (coordinate system)
‚úì .cpg          = ‡πÑ‡∏ü‡∏•‡πå‡∏Å‡∏≥‡∏´‡∏ô‡∏î encoding (UTF-8)
‚úì .geojson      = ‡πÑ‡∏ü‡∏•‡πå GeoJSON ‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á
‚úì _fields.txt   = ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ field names (‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢)

üîç ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (Attribute Fields)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏´‡∏•‡∏±‡∏Å:
  LAND_USE     = ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô (residential/commercial/industrial)
  AREA_TYPE    = ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà (urban/urban_low_coverage/rural)
  SOURCE       = ‡πÅ‡∏´‡∏•‡πà‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏≤ (parcel_overlay/building_buffer)

‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏õ‡∏•‡∏á (parcel_overlay & urban_low_coverage):
  PARCEL_A     = ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏õ‡∏•‡∏á (‡∏ï‡∏£.‡∏°.)
  BL_AREA_TO   = ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏° (‡∏ï‡∏£.‡∏°.)
  COVERAGE_P   = ‡∏£‡πâ‡∏≠‡∏¢‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏õ‡∏Å‡∏Ñ‡∏•‡∏∏‡∏°‡∏î‡∏¥‡∏ô (%)

‡∏ü‡∏¥‡∏•‡∏î‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Buffer (building_buffer):
  BL_AREA      = ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (‡∏ï‡∏£.‡∏°.)
  BUFFER_DIS   = ‡∏£‡∏∞‡∏¢‡∏∞ Buffer (‡πÄ‡∏°‡∏ï‡∏£)

üìä ‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏°‡∏∑‡∏≠‡∏á (urban):
  ‚úì ‡∏ñ‡πâ‡∏≤ COVERAGE_P >= ${coverageThreshold}% ‚Üí ‡πÉ‡∏ä‡πâ‡πÅ‡∏õ‡∏•‡∏á‡∏ó‡∏±‡πâ‡∏á‡πÅ‡∏õ‡∏•‡∏á (SOURCE = parcel_overlay)
  ‚úì ‡∏ñ‡πâ‡∏≤ COVERAGE_P < ${coverageThreshold}% ‚Üí Buffer ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (SOURCE = building_buffer)
    - AREA_TYPE = urban_low_coverage
    - ‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PARCEL_A, BL_AREA_TO, COVERAGE_P

‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ä‡∏ô‡∏ö‡∏ó (rural):
  ‚úì Buffer ‡∏ó‡∏∏‡∏Å‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£
  ‚úì ‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏≤‡∏®‡∏±‡∏¢/‡∏û‡∏≤‡∏ì‡∏¥‡∏ä‡∏¢‡πå: 3 ‡πÄ‡∏°‡∏ï‡∏£
  ‚úì ‡∏≠‡∏∏‡∏ï‡∏™‡∏≤‡∏´‡∏Å‡∏£‡∏£‡∏°: 3/6/10 ‡πÄ‡∏°‡∏ï‡∏£ (‡∏ï‡∏≤‡∏°‡∏Ç‡∏ô‡∏≤‡∏î BL_AREA)

üåè ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‡πÉ‡∏ô QGIS:
  1. ‡πÅ‡∏ï‡∏Å‡πÑ‡∏ü‡∏•‡πå .zip
  2. Drag & Drop ‡πÑ‡∏ü‡∏•‡πå .shp ‡πÄ‡∏Ç‡πâ‡∏≤ QGIS
  3. ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (${selectedEPSG})
  4. ‡πÄ‡∏õ‡∏¥‡∏î Attribute Table ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô
  5. ‡∏î‡∏π‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ field names ‡πÉ‡∏ô *_fields.txt

‡πÉ‡∏ô ArcGIS:
  1. Add Data ‚Üí ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå .shp
  2. ‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏¥‡∏Å‡∏±‡∏î‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏≠‡πà‡∏≤‡∏ô‡∏à‡∏≤‡∏Å .prj ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
  3. Open Attribute Table ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•

üí° ‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
- ‡∏ä‡∏∑‡πà‡∏≠ field ‡πÉ‡∏ô .dbf ‡∏ñ‡∏π‡∏Å‡∏¢‡πà‡∏≠‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 10 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ (‡∏Ç‡πâ‡∏≠‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏≠‡∏á DBF)
- ‡∏î‡∏π‡∏Ñ‡∏≥‡πÅ‡∏õ‡∏•‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡πÑ‡∏î‡πâ‡∏ó‡∏µ‡πà‡πÑ‡∏ü‡∏•‡πå *_fields.txt
- ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà: ‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÄ‡∏°‡∏ï‡∏£ (sqm)
- ‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏£‡∏∞‡∏¢‡∏∞ Buffer: ‡πÄ‡∏°‡∏ï‡∏£ (m)
- Encoding: UTF-8 (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢)
- ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏ö‡∏ö batch ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå RAM 8GB

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢: ‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡∏≤‡∏î‡∏£‡∏π‡∏õ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡∏î‡∏¥‡∏ô‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ (Optimized)
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
`;
                zip.file('README.txt', readme);
                
                // Generate and download
                const blob = await zip.generateAsync({ type: 'blob' });
                saveAs(blob, `${baseName}_shapefile.zip`);
                
                showStatus('processStatus', 'success', `‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å ${baseName}_shapefile.zip ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!`);
                
            } catch (error) {
                console.error('Export error:', error);
                showStatus('processStatus', 'error', `‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}`);
            }
        }

        function getPRJContent(epsg) {
            if (epsg === 'EPSG:32647') {
                return 'PROJCS["WGS_1984_UTM_Zone_47N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",99],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
            } else if (epsg === 'EPSG:32648') {
                return 'PROJCS["WGS_1984_UTM_Zone_48N",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",105],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],UNIT["Meter",1]]';
            }
            return 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137,298.257223563]],PRIMEM["Greenwich",0],UNIT["Degree",0.017453292519943295]]';
        }

        function createSHPFile(features) {
            const shapeType = 5; // Polygon
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            // Calculate bounds
            features.forEach(f => {
                const coords = f.geometry.type === 'Polygon' ? f.geometry.coordinates : f.geometry.coordinates[0];
                coords[0].forEach(([x, y]) => {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                });
            });

            const records = [];
            let fileLength = 100; // Header size

            features.forEach((feature, index) => {
                const recordHeader = new ArrayBuffer(8);
                const headerView = new DataView(recordHeader);
                headerView.setInt32(0, index + 1, false); // Record number (big-endian)
                
                const recordContent = createPolygonRecord(feature);
                if (recordContent) {
                    headerView.setInt32(4, recordContent.byteLength / 2, false);
                    records.push(recordHeader);
                    records.push(recordContent);
                    fileLength += 8 + recordContent.byteLength;
                }
            });

            // Create header
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            headerView.setInt32(0, 9994, false); // File code
            headerView.setInt32(24, fileLength / 2, false); // File length (words)
            headerView.setInt32(28, 1000, true); // Version
            headerView.setInt32(32, shapeType, true); // Shape type
            headerView.setFloat64(36, minX, true);
            headerView.setFloat64(44, minY, true);
            headerView.setFloat64(52, maxX, true);
            headerView.setFloat64(60, maxY, true);

            // Combine
            const result = new Uint8Array(fileLength);
            let offset = 0;
            result.set(new Uint8Array(header), offset);
            offset += 100;
            records.forEach(record => {
                result.set(new Uint8Array(record), offset);
                offset += record.byteLength;
            });

            return result;
        }

        function createPolygonRecord(feature) {
            const coords = feature.geometry.type === 'Polygon' 
                ? feature.geometry.coordinates 
                : feature.geometry.coordinates[0];
            
            const numParts = coords.length;
            const numPoints = coords.reduce((sum, ring) => sum + ring.length, 0);
            const contentLength = 44 + (4 * numParts) + (16 * numPoints);
            
            const buffer = new ArrayBuffer(contentLength);
            const view = new DataView(buffer);
            
            view.setInt32(0, 5, true); // Polygon type
            
            // Bounding box
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            coords.forEach(ring => {
                ring.forEach(([x, y]) => {
                    minX = Math.min(minX, x);
                    minY = Math.min(minY, y);
                    maxX = Math.max(maxX, x);
                    maxY = Math.max(maxY, y);
                });
            });
            
            view.setFloat64(4, minX, true);
            view.setFloat64(12, minY, true);
            view.setFloat64(20, maxX, true);
            view.setFloat64(28, maxY, true);
            view.setInt32(36, numParts, true);
            view.setInt32(40, numPoints, true);
            
            // Parts
            let offset = 44;
            let partStart = 0;
            coords.forEach((ring, i) => {
                view.setInt32(offset, partStart, true);
                offset += 4;
                partStart += ring.length;
            });
            
            // Points
            coords.forEach(ring => {
                ring.forEach(([x, y]) => {
                    view.setFloat64(offset, x, true);
                    view.setFloat64(offset + 8, y, true);
                    offset += 16;
                });
            });
            
            return buffer;
        }

        function createSHXFile(features) {
            const numRecords = features.length;
            const fileLength = 100 + (numRecords * 8);
            const buffer = new ArrayBuffer(fileLength);
            const view = new DataView(buffer);
            
            // Header (same as SHP)
            view.setInt32(0, 9994, false);
            view.setInt32(24, fileLength / 2, false);
            view.setInt32(28, 1000, true);
            view.setInt32(32, 5, true); // Polygon
            
            // Index records
            let offset = 50; // in words
            for (let i = 0; i < numRecords; i++) {
                const feature = features[i];
                const coords = feature.geometry.type === 'Polygon' 
                    ? feature.geometry.coordinates 
                    : feature.geometry.coordinates[0];
                const numParts = coords.length;
                const numPoints = coords.reduce((sum, ring) => sum + ring.length, 0);
                const recordLength = 22 + (2 * numParts) + (8 * numPoints);
                
                view.setInt32(100 + i * 8, offset, false);
                view.setInt32(104 + i * 8, recordLength, false);
                offset += recordLength + 4;
            }
            
            return new Uint8Array(buffer);
        }

        function createDBFFile(features) {
            // Get fields with proper naming
            const fieldMapping = {
                'land_use': { name: 'LAND_USE', type: 'C', length: 20, decimal: 0 },
                'area_type': { name: 'AREA_TYPE', type: 'C', length: 20, decimal: 0 },
                'source': { name: 'SOURCE', type: 'C', length: 20, decimal: 0 },
                'parcel_area': { name: 'PARCEL_A', type: 'F', length: 19, decimal: 2 },
                'bl_area_total': { name: 'BL_AREA_TO', type: 'F', length: 19, decimal: 2 },
                'coverage_percent': { name: 'COVERAGE_P', type: 'F', length: 19, decimal: 2 },
                'bl_area': { name: 'BL_AREA', type: 'F', length: 19, decimal: 2 },
                'buffer_distance': { name: 'BUFFER_DIS', type: 'F', length: 19, decimal: 2 }
            };

            const fields = [];
            const fieldKeys = new Set();
            
            // ‡∏£‡∏ß‡∏ö‡∏£‡∏ß‡∏° fields ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡πÉ‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
            features.forEach(f => {
                if (f.properties) {
                    Object.keys(f.properties).forEach(key => {
                        if (fieldMapping[key] && !fieldKeys.has(key)) {
                            fieldKeys.add(key);
                            fields.push({
                                ...fieldMapping[key],
                                originalName: key
                            });
                        }
                    });
                }
            });
            
            const headerLength = 32 + (fields.length * 32) + 1;
            const recordLength = fields.reduce((sum, f) => sum + f.length, 0) + 1;
            const fileLength = headerLength + (features.length * recordLength) + 1;
            
            const bytes = new Uint8Array(fileLength);
            const view = new DataView(bytes.buffer);
            
            // Header
            bytes[0] = 0x03; // dBASE III
            const now = new Date();
            bytes[1] = now.getFullYear() - 1900;
            bytes[2] = now.getMonth() + 1;
            bytes[3] = now.getDate();
            view.setUint32(4, features.length, true);
            view.setUint16(8, headerLength, true);
            view.setUint16(10, recordLength, true);
            bytes[29] = 0x03; // UTF-8 encoding flag
            
            // Field descriptors
            let offset = 32;
            fields.forEach(field => {
                for (let i = 0; i < 11; i++) {
                    bytes[offset + i] = i < field.name.length ? field.name.charCodeAt(i) : 0;
                }
                bytes[offset + 11] = field.type.charCodeAt(0);
                bytes[offset + 16] = field.length;
                bytes[offset + 17] = field.decimal;
                offset += 32;
            });
            bytes[offset++] = 0x0D; // Field descriptor terminator
            
            // Records
            features.forEach((feature, idx) => {
                bytes[offset++] = 0x20; // Not deleted
                fields.forEach(field => {
                    const value = feature.properties?.[field.originalName];
                    let str = '';
                    if (value !== null && value !== undefined) {
                        if (field.type === 'N' || field.type === 'F') {
                            str = String(value).padStart(field.length, ' ');
                        } else {
                            str = String(value).substring(0, field.length).padEnd(field.length, ' ');
                        }
                    } else {
                        str = ''.padEnd(field.length, ' ');
                    }
                    for (let i = 0; i < field.length; i++) {
                        bytes[offset++] = i < str.length ? str.charCodeAt(i) : 0x20;
                    }
                });
            });
            bytes[offset] = 0x1A; // EOF
            
            return bytes;
        }

        // ========== End of Shapefile Functions ==========

        document.getElementById('loadFiles').addEventListener('click', async () => {
            const buildingFiles = document.getElementById('buildingFiles').files;
            const parcelFiles = document.getElementById('parcelFiles').files;
            const selectedEPSG = document.getElementById('epsgSelect').value;

            if (buildingFiles.length === 0 || parcelFiles.length === 0) {
                showStatus('loadStatus', 'error', '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ä‡∏∏‡∏î');
                return;
            }

            document.getElementById('loading').classList.add('active');
            document.getElementById('loadFiles').disabled = true;

            try {
                buildingData = await loadShapefile(buildingFiles[0], selectedEPSG);
                const buildingEncoding = buildingData.encoding || 'UTF-8';
                
                if (buildingLayer) map.removeLayer(buildingLayer);
                buildingLayer = L.geoJSON(buildingData, {
                    style: { color: '#FF69B4', weight: 2, fillOpacity: 0 },
                    onEachFeature: (f, l) => {
                        let popup = '<strong>‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£</strong><br>';
                        for (let k in f.properties) popup += `${k}: ${f.properties[k]}<br>`;
                        l.bindPopup(popup);
                    }
                }).addTo(map);

                parcelData = await loadShapefile(parcelFiles[0], selectedEPSG);
                const parcelEncoding = parcelData.encoding || 'UTF-8';
                
                if (parcelLayer) map.removeLayer(parcelLayer);
                parcelLayer = L.geoJSON(parcelData, {
                    style: { color: '#000000', weight: 1, fillOpacity: 0 },
                    onEachFeature: (f, l) => {
                        let popup = '<strong>‡πÅ‡∏õ‡∏•‡∏á</strong><br>';
                        for (let k in f.properties) popup += `${k}: ${f.properties[k]}<br>`;
                        l.bindPopup(popup);
                    }
                }).addTo(map);

                map.fitBounds(buildingLayer.getBounds().extend(parcelLayer.getBounds()));

                const fields = Object.keys(buildingData.features[0].properties);
                const landUseSelect = document.getElementById('landUseField');
                const urbanSelect = document.getElementById('urbanField');

                landUseSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';
                urbanSelect.innerHTML = '<option value="">-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å Field --</option>';

                let classFound = false;
                fields.forEach(field => {
                    landUseSelect.add(new Option(field, field));
                    urbanSelect.add(new Option(field, field));
                    if (field.toLowerCase() === 'class' && !classFound) {
                        landUseSelect.value = field;
                        classFound = true;
                        updateBuildingColors(field);
                    }
                });

                landUseSelect.disabled = false;
                urbanSelect.disabled = false;

                showStatus('loadStatus', 'success', 
                    `‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£: ${buildingData.features.length}, ‡πÅ‡∏õ‡∏•‡∏á: ${parcelData.features.length} | Encoding: ${buildingEncoding}`);
                document.getElementById('legend').style.display = 'block';
                document.getElementById('layerControl').style.display = 'block';
                
                // Setup base layer toggles (‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß)
                setupBaseLayerToggles();

            } catch (error) {
                showStatus('loadStatus', 'error', `‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}`);
            } finally {
                document.getElementById('loading').classList.remove('active');
                document.getElementById('loadFiles').disabled = false;
            }
        });

        document.getElementById('landUseField').addEventListener('change', (e) => {
            if (e.target.value && buildingData) updateBuildingColors(e.target.value);
        });

        document.getElementById('urbanField').addEventListener('change', (e) => {
            const field = e.target.value;
            if (!field || !buildingData) return;

            const values = new Set();
            buildingData.features.forEach(f => {
                const v = f.properties[field];
                if (v !== null && v !== undefined && v !== '') values.add(String(v));
            });

            const allValues = Array.from(values).sort();
            const valueList = document.getElementById('urbanValueList');
            valueList.innerHTML = '';
            urbanConfig.urban = [];
            urbanConfig.rural = [];

            allValues.forEach(value => {
                const div = document.createElement('div');
                div.className = 'value-item';
                div.innerHTML = `<input type="checkbox" id="val_${value}" value="${value}"><label for="val_${value}" style="margin: 0; cursor: pointer; flex: 1;">${value}</label>`;
                valueList.appendChild(div);
                div.querySelector('input').addEventListener('change', () => {
                    urbanConfig.urban = [];
                    urbanConfig.rural = [];
                    document.querySelectorAll('#urbanValueList input:checked').forEach(cb => urbanConfig.urban.push(cb.value));
                    allValues.forEach(v => { if (!urbanConfig.urban.includes(v)) urbanConfig.rural.push(v); });
                    updateUrbanSummary();
                    if (parcelData) updateParcelColors(field);
                    document.getElementById('processBtn').disabled = !(urbanConfig.urban.length > 0 || urbanConfig.rural.length > 0);
                });
            });

            document.getElementById('urbanConfigSection').style.display = 'block';
            updateUrbanSummary();
        });

        document.getElementById('processBtn').addEventListener('click', processAllLandUse);
        
        // ‡∏õ‡∏∏‡πà‡∏°‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° Layer ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        document.getElementById('showAllLayers').addEventListener('click', () => {
            document.getElementById('toggleBuildings').checked = true;
            document.getElementById('toggleParcels').checked = true;
            document.getElementById('toggleResidential').checked = true;
            document.getElementById('toggleCommercial').checked = true;
            document.getElementById('toggleIndustrial').checked = true;
            
            // Trigger change events
            document.getElementById('toggleBuildings').dispatchEvent(new Event('change'));
            document.getElementById('toggleParcels').dispatchEvent(new Event('change'));
            document.getElementById('toggleResidential').dispatchEvent(new Event('change'));
            document.getElementById('toggleCommercial').dispatchEvent(new Event('change'));
            document.getElementById('toggleIndustrial').dispatchEvent(new Event('change'));
        });
        
        document.getElementById('hideAllLayers').addEventListener('click', () => {
            document.getElementById('toggleBuildings').checked = false;
            document.getElementById('toggleParcels').checked = false;
            document.getElementById('toggleResidential').checked = false;
            document.getElementById('toggleCommercial').checked = false;
            document.getElementById('toggleIndustrial').checked = false;
            
            // Trigger change events
            document.getElementById('toggleBuildings').dispatchEvent(new Event('change'));
            document.getElementById('toggleParcels').dispatchEvent(new Event('change'));
            document.getElementById('toggleResidential').dispatchEvent(new Event('change'));
            document.getElementById('toggleCommercial').dispatchEvent(new Event('change'));
            document.getElementById('toggleIndustrial').dispatchEvent(new Event('change'));
        });
        
        document.getElementById('exportResidential').addEventListener('click', () => exportShapefile(window.residentialResult, 'residential'));
        document.getElementById('exportCommercial').addEventListener('click', () => exportShapefile(window.commercialResult, 'commercial'));
        document.getElementById('exportIndustrial').addEventListener('click', () => exportShapefile(window.industrialResult, 'industrial'));
        document.getElementById('exportAll').addEventListener('click', () => {
            const combined = {
                type: 'FeatureCollection',
                features: [
                    ...(window.residentialResult?.features || []),
                    ...(window.commercialResult?.features || []),
                    ...(window.industrialResult?.features || [])
                ]
            };
            exportShapefile(combined, 'land_use_all');
        });

        initMap();
    </script>
<script data-goatcounter="https://mponline.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> 
</body>
</html>
