<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RECLASS BLDG</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
        <style>
    /* 1. IMPORT FONTS & VARIABLES */
    @import url('https://fonts.googleapis.com/css2?family=Prompt:wght@300;400;500;600;700&display=swap');

    :root {
        /* Color Palette (Blue Theme) */
        --primary-gradient: linear-gradient(135deg, #1e88e5 0%, #1565c0 50%, #0d47a1 100%);
        --primary-solid: #1565c0; /* ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‡∏´‡∏•‡∏±‡∏Å */
        --primary-dark: #0d47a1;  /* ‡∏™‡∏µ‡∏ô‡πâ‡∏≥‡πÄ‡∏á‡∏¥‡∏ô‡πÄ‡∏Ç‡πâ‡∏° */
        --primary-light: #e3f2fd; /* ‡∏™‡∏µ‡∏ü‡πâ‡∏≤‡∏≠‡πà‡∏≠‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á */
        --text-white: #ffffff;
        --text-yellow: #ffeb3b;
        
        /* Glass Effect */
        --bg-glass: rgba(255, 255, 255, 0.1);
        --bg-glass-hover: rgba(255, 255, 255, 0.25);
        --header-height: 70px;
    }
    
    body {
        margin: 0;
        padding-top: var(--header-height);
        font-family: 'Prompt', sans-serif; /* ‡πÉ‡∏ä‡πâ Font Prompt ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏ô‡πâ‡∏≤ */
        background: linear-gradient(180deg, #f0f7ff 0%, #ffffff 100%); /* ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ü‡πâ‡∏≤‡∏à‡∏≤‡∏á */
        color: #333;
    }

    /* 2. HEADER STRUCTURE */
    .mapraw-header {
        background: var(--primary-gradient);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1000;
        height: var(--header-height);
    }
    
    .mapraw-header-content {
        max-width: 100%;
        margin: 0 auto;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        height: 100%;
    }
    
    /* Logo */
    .mapraw-logo-section {
        display: flex;
        flex-direction: column;
        justify-content: center;
        flex-shrink: 0;
        padding-right: 15px;
    }
    
    .mapraw-logo-main {
        color: var(--text-white);
        font-size: 1.2rem;
        font-weight: 700;
        margin: 0;
        line-height: 1;
        white-space: nowrap;
    }
    
    .mapraw-logo-main span {
        color: var(--text-yellow);
        text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
    }
    
    .mapraw-page-title {
        color: #e3f2fd;
        font-size: 1rem;
        font-weight: 400;
        margin: 2px 0 0 0;
        white-space: nowrap;
    }
    
    /* Navigation Bar */
    .mapraw-nav {
        display: flex;
        gap: 8px;
        align-items: center;
        height: 100%;
    }
    
    .mapraw-nav-item {
        position: relative;
        height: 100%;
        display: flex;
        align-items: center;
    }
    
    /* Nav Buttons */
    .mapraw-nav-btn {
        background: var(--bg-glass);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 500;
        transition: all 0.2s ease;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 6px;
        font-family: 'Prompt', sans-serif;
        white-space: nowrap;
    }
    
    .mapraw-nav-btn:hover {
        background: var(--bg-glass-hover);
        transform: translateY(-1px);
    }
    
    .mapraw-nav-btn.home-btn {
        background: rgba(255, 235, 59, 0.15);
        border-color: #ffeb3b;
        color: #ffeb3b;
    }
    
    .mapraw-nav-btn.home-btn:hover {
        background: #ffeb3b;
        color: #1565c0;
    }

    /* Dropdown Menu */
    .mapraw-dropdown {
        position: absolute;
        top: calc(100% - 10px);
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        background: white;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        min-width: 200px;
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s ease;
        padding: 5px 0;
        z-index: 1001;
    }
    
    /* Desktop Hover Logic */
    @media (min-width: 1201px) {
        .mapraw-nav-item:hover .mapraw-dropdown {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }
    }
    
    .mapraw-dropdown-item {
        display: block;
        padding: 10px 20px;
        color: #333;
        text-decoration: none;
        font-size: 0.9rem;
        transition: background 0.2s;
        white-space: nowrap;
        font-family: 'Prompt', sans-serif;
    }
    
    .mapraw-dropdown-item:hover {
        background: #f1f8ff;
        color: var(--primary-solid);
    }

    /* Hamburger Menu Icon */
    .mobile-menu-toggle {
        display: none;
        background: none;
        border: none;
        cursor: pointer;
        padding: 10px;
        z-index: 1002;
    }
    
    .bar {
        display: block;
        width: 25px;
        height: 3px;
        margin: 5px auto;
        background-color: white;
        transition: all 0.3s ease-in-out;
        border-radius: 2px;
    }

    /* 3. RESPONSIVE MEDIA QUERIES (Mobile Logic) */
    @media (max-width: 1400px) {
        .mapraw-nav-btn {
            padding: 6px 8px;
            font-size: 0.8rem;
        }
        .mapraw-nav {
            gap: 4px;
        }
    }

    @media (max-width: 1200px) {
        .mobile-menu-toggle {
            display: block;
        }

        .mapraw-nav {
            position: fixed;
            top: var(--header-height);
            right: -100%;
            width: 280px;
            height: calc(100vh - var(--header-height));
            background: white;
            flex-direction: column;
            align-items: stretch;
            gap: 0;
            padding: 10px 0;
            transition: right 0.3s ease;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        .mapraw-nav.active {
            right: 0;
        }

        .mapraw-nav-item {
            height: auto;
            flex-direction: column;
            width: 100%;
            display: block;
            border-bottom: 1px solid #eee;
        }

        .mapraw-nav-btn {
            background: white;
            color: #333;
            border: none;
            border-radius: 0;
            padding: 15px 20px;
            font-size: 1rem;
            justify-content: space-between;
            width: 100%;
            box-sizing: border-box;
        }

        .mapraw-nav-btn:hover {
            background: #f5f5f5;
            color: var(--primary-solid);
            transform: none;
        }

        .mapraw-dropdown {
            position: static;
            transform: none;
            visibility: visible;
            opacity: 1;
            box-shadow: none;
            min-width: 100%;
            background: #f9f9f9;
            display: none;
            padding: 0;
        }
        
        .mapraw-nav-item.active .mapraw-dropdown {
            display: block;
        }

        .mapraw-dropdown-item {
            padding-left: 40px;
            font-size: 0.9rem;
            color: #666;
        }

        /* Hamburger Animation */
        .mobile-menu-toggle.active .bar:nth-child(2) {
            opacity: 0;
        }
        .mobile-menu-toggle.active .bar:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        .mobile-menu-toggle.active .bar:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
    }
    
    @media (max-width: 480px) {
        .mapraw-logo-main { font-size: 1rem; }
        .mapraw-page-title { font-size: 0.75rem; }
    }

    /* 4. MAIN CONTENT & CARDS (Updated to Blue Theme) */
    .main-container {
        padding: 2rem;
        margin: 0 auto;
        max-width: 1200px;
    }

    @media (max-width: 768px) {
        .main-container {
            padding: 1rem;
        }
    }

    .card {
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(30, 136, 229, 0.1);
        padding: 2rem;
        margin-bottom: 2rem;
        border-top: 4px solid var(--primary-solid);
    }

    .title-container {
        margin-bottom: 2rem;
        text-align: center;
    }

    .main-title {
        color: var(--primary-dark);
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
    }

    .subtitle {
        color: #546e7a;
        font-size: 1.1rem;
    }

    .controls-container {
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .section-title {
        color: var(--primary-solid);
        font-size: 1rem;
        margin-bottom: 0.5rem;
        font-weight: 600;
    }

    /* Input & Process Buttons */
    .file-button {
        width: 100%;
        padding: 0.75rem 1rem;
        border: 1px solid #bbdefb;
        color: #546e7a;
        border-radius: 6px;
        transition: all 0.3s;
        background: #ffffff;
        text-align: left;
        font-family: 'Prompt', sans-serif;
    }

    .file-button:hover {
        border-color: var(--primary-solid);
        color: var(--primary-solid);
        background-color: #f0f7ff;
    }

    .process-button {
        width: 100%;
        padding: 0.75rem 1rem;
        background: var(--primary-gradient);
        color: white;
        border-radius: 6px;
        transition: all 0.3s;
        border: none;
        text-align: center;
        font-weight: 600;
        font-family: 'Prompt', sans-serif;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    .process-button:hover {
        background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    /* Floating Buttons */
    .fixed-buttons {
        position: fixed;
        bottom: 2rem;
        right: 2rem;
        display: flex;
        gap: 1rem;
        z-index: 900;
    }

    .home-button, .landuse-button {
        background: var(--primary-solid);
        color: white;
        padding: 0.75rem;
        border-radius: 9999px;
        transition: all 0.3s;
        text-decoration: none;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 10px rgba(21, 101, 192, 0.3);
    }

    .landuse-button {
        padding: 0.75rem 1.5rem;
        white-space: nowrap;
        font-family: 'Prompt', sans-serif;
    }

    .home-button:hover, .landuse-button:hover {
        background-color: var(--primary-dark);
        color: white;
        transform: scale(1.05);
    }

    /* Progress Bar */
    .custom-progress {
        width: 100%;
        background-color: #e3f2fd;
        border-radius: 4px;
        padding: 2px;
        border: 1px solid #bbdefb;
    }

    .custom-progress-bar {
        background: var(--primary-gradient);
        height: 16px;
        border-radius: 2px;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 0.75rem;
        font-family: 'Prompt', sans-serif;
    }

    .manual-link {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--primary-solid);
        text-decoration: none;
        margin-top: 1rem;
        font-size: 0.9rem;
        font-weight: 500;
        transition: color 0.2s;
    }

    .manual-link:hover {
        color: var(--primary-dark);
        text-decoration: underline;
    }

    .file-name-display {
        font-size: 0.875rem;
        color: #546e7a;
        margin-top: 0.5rem;
        min-height: 1.25rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    .file-input-container {
        width: 100%;
    }

    /* 5. MODAL STYLES */
    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 2000;
        backdrop-filter: blur(2px);
    }

    .modal-content {
        background-color: white;
        margin: 5% auto;
        padding: 25px;
        border-radius: 12px;
        width: 90%;
        max-width: 600px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }

    @media (max-width: 768px) {
        .modal-content {
            width: 95%;
            margin: 10% auto;
        }
    }

    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e3f2fd;
    }
    
    .modal-header h3 {
        color: var(--primary-dark);
        margin: 0;
        font-family: 'Prompt', sans-serif;
    }

    .modal-close {
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #90a4ae;
        transition: color 0.2s;
    }
    
    .modal-close:hover {
        color: #cfd8dc;
    }

    .column-mapping {
        margin-bottom: 15px;
    }

    .column-mapping label {
        display: block;
        color: var(--primary-solid);
        margin-bottom: 5px;
        font-size: 0.9rem;
        font-weight: 500;
    }

    .column-mapping select {
        width: 100%;
        padding: 8px;
        border: 1px solid #bbdefb;
        border-radius: 4px;
        background-color: #f8fbff;
        font-family: 'Prompt', sans-serif;
    }
    
    .column-mapping select:focus {
        outline: none;
        border-color: var(--primary-solid);
        box-shadow: 0 0 0 2px rgba(21, 101, 192, 0.2);
    }

    .modal-buttons {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 20px;
    }

    .modal-button {
        padding: 8px 16px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        font-size: 14px;
        font-family: 'Prompt', sans-serif;
        font-weight: 500;
    }

    .modal-button-primary {
        background-color: var(--primary-solid);
        color: white;
    }
    
    .modal-button-primary:hover {
        background-color: var(--primary-dark);
    }

    .modal-button-secondary {
        background-color: #cfd8dc;
        color: #455a64;
    }
    
    .modal-button-secondary:hover {
        background-color: #b0bec5;
    }

    .error-message {
        color: #c62828;
        font-size: 0.875rem;
        margin-top: 10px;
        padding: 10px;
        background-color: #ffcdd2;
        border-radius: 4px;
        border: 1px solid #ef9a9a;
    }

    /* 6. STEPS SECTION */
    .steps-container {
        margin-top: 2rem;
        margin-bottom: 2rem;
        border-bottom: 1px solid #e3f2fd;
        padding-bottom: 1rem;
    }

    .step {
        display: flex;
        gap: 1rem;
        margin-bottom: 1.5rem;
        align-items: flex-start;
    }

    .step-number {
        background: var(--primary-gradient);
        color: white;
        width: 2rem;
        height: 2rem;
        border-radius: 9999px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        flex-shrink: 0;
        box-shadow: 0 2px 4px rgba(21, 101, 192, 0.3);
    }

    .step-content {
        flex: 1;
    }

    .step-title {
        font-weight: 600;
        color: var(--primary-solid);
        margin-bottom: 0.5rem;
    }

    .step-description {
        color: #546e7a;
        font-size: 0.9rem;
        line-height: 1.5;
    }
    </style>
</head>
<header class="mapraw-header">
    <div class="mapraw-header-content">
        <div class="mapraw-logo-section">
            <h1 class="mapraw-logo-main">TOOL FROM <span>MAPRAW</span></h1>
            <p class="mapraw-page-title">Reclass BLDG</p>
        </div>
        
        <button class="mobile-menu-toggle" id="mobileMenuBtn">
            <span class="bar"></span>
            <span class="bar"></span>
            <span class="bar"></span>
        </button>

        <nav class="mapraw-nav" id="mainNav">
            <div class="mapraw-nav-item">
                <a href="index.html" class="mapraw-nav-btn home-btn">
                    <span>üè† ‡∏´‡∏ô‡πâ‡∏≤‡∏´‡∏•‡∏±‡∏Å</span>
                </a>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üìã ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏™‡∏≥‡∏£‡∏ß‡∏à</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page1.html" class="mapraw-dropdown-item">NoteMAP</a>
                    <a href="#" class="mapraw-dropdown-item">SURVEY WORK</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üîß ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page2.html" class="mapraw-dropdown-item">Reclass BLDG</a>
                    <a href="page5.html" class="mapraw-dropdown-item">Prepare PLLU</a>
                    <a href="page8.html" class="mapraw-dropdown-item">SHAPEFILE TO EXCEL</a>
                    <a href="page10.html" class="mapraw-dropdown-item">CAPTURE MAP</a>
                    <a href="page16.html" class="mapraw-dropdown-item">CREATE LANDUSE</a>
                    <a href="page13.html" class="mapraw-dropdown-item">Perpendicular Line</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>‚öôÔ∏è ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page3.html" class="mapraw-dropdown-item">Calculate Landuse</a>
                    <a href="page6.html" class="mapraw-dropdown-item">Calculate Population</a>
                    <a href="page11.html" class="mapraw-dropdown-item">Calculate AREA</a>
                    <a href="page14.html" class="mapraw-dropdown-item">RECLASS FACTORY</a>
                    <a href="page12.html" class="mapraw-dropdown-item">COMPARISON LANDUSE</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>‚öñÔ∏è ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏Å‡∏é‡∏´‡∏°‡∏≤‡∏¢</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page4.html" class="mapraw-dropdown-item">Town Planning Laws</a>
                    <a href="page15.html" class="mapraw-dropdown-item">Building Laws</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üßÆ ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ö‡∏∑‡πâ‡∏≠‡∏á‡∏ï‡πâ‡∏ô</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page7.html" class="mapraw-dropdown-item">AREA Calculator</a>
                </div>
            </div>
            
            <div class="mapraw-nav-item" onclick="toggleMobileDropdown(this)">
                <div class="mapraw-nav-btn">
                    <span>üéØ ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏≠‡∏∑‡πà‡∏ô‡πÜ</span>
                    <span style="font-size: 0.8em">‚ñº</span>
                </div>
                <div class="mapraw-dropdown">
                    <a href="page9.html" class="mapraw-dropdown-item">CREATE QRCODE</a>
                </div>
            </div>
        </nav>
    </div>
</header>

<body class="gradient-bg">
    <div class="main-container">
        <div class="card">
            <div class="title-container">
                <h1 class="main-title">Reclass BLDG</h1>
                <h2 class="subtitle">‡∏à‡∏±‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£</h2>
            </div>

            <div class="steps-container">
                <div class="step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <div class="step-title">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Excel ‡∏´‡∏£‡∏∑‡∏≠ Shapefile)</div>
                        <div class="step-description">
                            ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Excel ‡∏´‡∏£‡∏∑‡∏≠ Shapefile) ‡πÇ‡∏î‡∏¢‡πÑ‡∏ü‡∏•‡πå‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå BL_TYPE, BL_USE, BL_AREA, BL_NSTOREY, BL_NUNIT, ACQYEAR, PL_BLOCK ‡πÅ‡∏•‡∏∞ PL_USE <br>
                            ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° RECLASS <br>
                            ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡πÑ‡∏ü‡∏•‡πå‡∏Ç‡∏≠‡∏á‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö ‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡πâ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
                        </div>
                    </div>
                </div>
                <div class="step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <div class="step-title">‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (RECLASS)</div>
                        <div class="step-description">
                            ‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° RECLASS ‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡πÑ‡∏î‡πâ‡πÅ‡∏Å‡πà ‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏° , RE_BL_USE , RE_BL_AREA ‡∏ï‡∏≤‡∏°‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ <br>
                            <a href="reclassbldg.pdf" class="manual-link">‡πÄ‡∏Å‡∏ì‡∏ë‡πå‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£</a> <br>
                            ‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏ó‡∏µ‡πà‡∏ú‡∏±‡∏á‡∏°‡∏µ‡∏ä‡∏∑‡πà‡∏≠‡∏ö‡∏£‡∏¥‡πÄ‡∏ß‡∏ì‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£ ‡∏£‡∏∞‡∏ö‡∏ö‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏•‡∏∏‡πà‡∏°‡∏ö‡∏£‡∏¥‡πÄ‡∏ß‡∏ì‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏¢‡πà‡∏≤‡∏ô (PL_BLOCK2) ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ 
                        </div>
                    </div>
                </div>
                <div class="step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <div class="step-title">‡∏ô‡∏≥‡∏≠‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Excel ‡∏´‡∏£‡∏∑‡∏≠ Shapefile)</div>
                        <div class="step-description">
                            ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÄ‡∏™‡∏£‡πá‡∏à ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡∏ô‡∏≥‡∏≠‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Excel)" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå Excel<br>
                            ‡∏´‡∏≤‡∏Å‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡∏à‡∏≤‡∏Å Shapefile ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° "‡∏ô‡∏≥‡∏≠‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Shapefile)" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå Shapefile
                        </div>
                    </div>
                </div>
            </div>

            <div class="controls-container">
                <a href="Reclass BLDG Handbook.pdf" class="manual-link">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                    </svg>
                    ‡∏Ñ‡∏π‡πà‡∏°‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
                </a>

                <div class="mt-4">
                    <div class="section-title">‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Excel ‡∏´‡∏£‡∏∑‡∏≠ Shapefile)</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                        <!-- Excel Input -->
                        <div>
                            <input type="file" id="excelFile" accept=".xlsx, .xls" class="hidden" onchange="updateFileName(this, 'excel')">
                            <button onclick="document.getElementById('excelFile').click()" class="file-button">
                                Choose Excel File
                            </button>
                            <div id="fileNameExcel" class="file-name-display"></div>
                        </div>
                        <!-- Shapefile Input -->
                        <div>
                            <input type="file" id="shapefileInput" accept=".zip,.shp,.dbf,.shx,.prj,.cpg" multiple class="hidden" onchange="updateFileName(this, 'shapefile')">
                            <button onclick="document.getElementById('shapefileInput').click()" class="file-button">
                                Choose Shapefile
                            </button>
                            <div id="fileNameShapefile" class="file-name-display"></div>
                            <div style="font-size: 0.7rem; color: #64748b; margin-top: 0.25rem;">
                            
                            </div>
                        </div>
                    </div>
                </div>

                <button id="processButton" class="process-button">
                    RECLASS
                </button>

                <div id="progressContainer" class="d-none w-full">
                    <div class="custom-progress">
                        <div id="progressBar" class="custom-progress-bar" role="progressbar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <button id="exportButton" class="process-button d-none">
                        ‡∏ô‡∏≥‡∏≠‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Excel)
                    </button>
                    <button id="exportShapefileButton" class="process-button d-none">
                        ‡∏ô‡∏≥‡∏≠‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£ (Shapefile)
                    </button>
                </div>

                <div id="errorMessage" class="error-message d-none"></div>
            </div>
        </div>
    </div>

    <!-- Column Mapping Modal -->
    <div id="columnModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå</h3>
                <button class="modal-close" onclick="closeColumnModal()">&times;</button>
            </div>
            <div id="columnMappingList">
                <!-- Column mappings will be inserted here -->
            </div>
            <div class="modal-buttons">
                <button class="modal-button modal-button-secondary" onclick="closeColumnModal()">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
                <button class="modal-button modal-button-primary" onclick="processWithMapping()">‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let fileData = null;
        let columnMapping = {};
        let processedData = [];
        let isShapefileInput = false;
        let originalShapefileData = null;
        let originalFileName = '';
        let originalProjection = null;
        let originalShapefileFiles = {}; // ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (.shp, .dbf, .shx, .prj, .cpg)
        const requiredColumns = ['BL_TYPE', 'BL_USE', 'BL_AREA', 'BL_NSTOREY', 'BL_NUNIT', 'ACQYEAR', 'PL_BLOCK', 'PL_USE'];

        // Valid BL_TYPE values
        const validBLTypes = ['1', '2', '3', '4', '5', '6', '7', '8', '98', '99'];

        // Object containing the mapping patterns
        const plBlockPatterns = {
            '‡∏≠‡∏¢.': '‡∏≠‡∏¢.',
            '‡∏¢.1': '‡∏¢.1',
            '‡∏¢.2': '‡∏¢.2',
            '‡∏¢.3': '‡∏¢.3',
            '‡∏¢.4': '‡∏¢.4',
            '‡∏¢.5': '‡∏¢.5',
            '‡∏¢.6': '‡∏¢.6',
            '‡∏¢.7': '‡∏¢.7',
            '‡∏¢.8': '‡∏¢.8',
            '‡∏û.1': '‡∏û.1',
            '‡∏û.2': '‡∏û.2',
            '‡∏û.3': '‡∏û.3',
            '‡∏û.4': '‡∏û.4',
            '‡∏Ç‡∏Å.': '‡∏Ç‡∏Å.',
            '‡∏≠.1': '‡∏≠.1',
            '‡∏≠.2': '‡∏≠.2',
            '‡∏≠.3': '‡∏≠.3',
            '‡∏≠.4': '‡∏≠.4',
            '‡∏Å.1': '‡∏Å.1',
            '‡∏Å.2': '‡∏Å.2',
            '‡∏Å.3': '‡∏Å.3',
            '‡∏Å.4': '‡∏Å.4',
            '‡∏Å.5': '‡∏Å.5',
            '‡∏≠‡∏Å.': '‡∏≠‡∏Å.',
            '‡∏õ‡∏Å.': '‡∏õ‡∏Å.',
            '‡∏≠‡∏ó.': '‡∏≠‡∏ó.',
            '‡∏•.': '‡∏•.',
            '‡∏•‡∏•.': '‡∏•‡∏•.',
            '‡∏™‡∏•.': '‡∏™‡∏•.',
            '‡∏≠‡∏õ.': '‡∏≠‡∏õ.',
            '‡∏®‡∏©.': '‡∏®‡∏©.',
            '‡∏•‡∏ä.': '‡∏•‡∏ä.',
            '‡∏•‡∏™.': '‡∏•‡∏™.',
            '‡∏≠‡∏®.': '‡∏≠‡∏®.',
            '‡∏®‡∏ô.': '‡∏®‡∏ô.',
            '‡∏™.': '‡∏™.'
        };

        const reuse2Data = {
            "1000": "10", "1100": "10", "1101": "10", "1102": "10", "1103": "10",
            "1121": "10", "1122": "10", "1123": "10", "1131": "10", "1132": "10",
            "1200": "10", "1300": "10", "1310": "10", "1320": "10", "1330": "10",
            "1340": "10", "1350": "10", "1800": "90", "2000": "20", "2100": "20",
            "2200": "20", "2210": "20", "2220": "20", "2230": "20", "2231": "20",
            "2232": "20", "2233": "20", "2234": "20", "2240": "20", "2241": "20",
            "2250": "20", "2251": "20", "2260": "20", "2270": "20", "2280": "20",
            "2300": "20", "2301": "20", "2302": "20", "2400": "20", "2410": "20",
            "2420": "20", "2480": "20", "2500": "20", "2800": "20", "3000": "30",
            "3100": "30", "3110": "30", "3120": "30", "3300": "33", "3310": "33",
            "3311": "33", "3321": "33", "3322": "33", "3800": "30", "4100": "41",
            "4110": "41", "4120": "41", "4121": "41", "4122": "41", "4123": "41",
            "4180": "41", "4200": "30", "4300": "30", "5000": "90", "5130": "90",
            "5140": "90", "5150": "90", "5160": "90", "5180": "90", "5200": "90",
            "5210": "90", "5220": "90", "5230": "90", "5300": "90", "5310": "90",
            "5320": "90", "5330": "90", "5400": "90", "5410": "90", "5420": "90",
            "5430": "90", "5440": "90", "5500": "90", "5510": "90", "5520": "90",
            "5800": "90", "6000": "90", "6100": "90", "6105": "90", "6110": "90",
            "6120": "90", "6130": "90", "6140": "90", "6141": "90", "6142": "90",
            "6143": "90", "6150": "90", "6160": "90", "6180": "90", "6200": "90",
            "6210": "90", "6220": "90", "6230": "90", "6240": "90", "6250": "90",
            "6260": "90", "6270": "90", "6280": "90", "6300": "90", "6310": "90",
            "6320": "90", "6330": "90", "6340": "90", "6350": "90", "6360": "90",
            "6370": "90", "6380": "90", "6381": "90", "6382": "90", "6383": "90",
            "6400": "90", "6500": "90", "6510": "90", "6530": "90", "6580": "90",
            "6600": "90", "6610": "90", "6620": "90", "6630": "90", "6640": "90",
            "6650": "90", "6660": "90", "6800": "90", "6830": "90", "6831": "90",
            "7000": "90", "7200": "90", "7210": "90", "7220": "90", "7300": "90",
            "7310": "90", "7320": "90", "7321": "90", "7322": "90", "7323": "90",
            "7324": "90", "7330": "90", "7380": "90", "8000": "80", "8170": "80",
            "8180": "80", "8190": "80", "8310": "80", "8500": "80", "9991": "90",
            "9993": "90", "9998": "90", "9999": "90"
        };

        // Function to format decimals according to the specified rules
        function formatDecimal(value) {
            if (value === null || value === undefined || isNaN(value)) {
                return 0.00;
            }
            
            const numValue = parseFloat(value);
            
            // Convert to string to analyze decimal places using fixed precision to avoid floating point issues
            const str = numValue.toFixed(10);
            
            // If no decimal point, add .00
            if (!str.includes('.')) {
                return parseFloat(numValue.toFixed(2));
            }
            
            const parts = str.split('.');
            const decimalPart = parts[1].replace(/0+$/, ''); // Remove trailing zeros
            
            // If no decimal places after removing trailing zeros, add .00
            if (decimalPart.length === 0) {
                return parseFloat(numValue.toFixed(2));
            }
            
            // If only one decimal place, add trailing zero
            if (decimalPart.length === 1) {
                return parseFloat(numValue.toFixed(2));
            }
            
            // If exactly two decimal places, use as is
            if (decimalPart.length === 2) {
                return parseFloat(parts[0] + '.' + decimalPart);
            }
            
            // If more than two decimal places, apply custom rounding
            if (decimalPart.length > 2) {
                const thirdDigit = parseInt(decimalPart[2]);
                const firstTwoDecimals = decimalPart.substring(0, 2);
                
                if (thirdDigit >= 5) {
                    // Round up the second decimal place
                    const baseValue = parseFloat(parts[0] + '.' + firstTwoDecimals);
                    return parseFloat((baseValue + 0.01).toFixed(2));
                } else {
                    // Keep the first two decimal places as is
                    return parseFloat(parts[0] + '.' + firstTwoDecimals);
                }
            }
            
            return parseFloat(numValue.toFixed(2));
        }

        // Data validation functions
        function validateRowData(row, rowIndex) {
            const remarks = [];
            
            // 1.1 & 1.2 BL_TYPE validation
            const blType = convertToText(row.BL_TYPE).trim();
            if (!blType || blType === '' || blType === 'null' || blType === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_TYPE');
            } else if (!validBLTypes.includes(blType)) {
                remarks.push('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_TYPE ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
            }

            // 1.3 & 1.4 BL_USE validation
            const blUse = convertToText(row.BL_USE).trim();
            if (!blUse || blUse === '' || blUse === 'null' || blUse === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_USE');
            } else if (!reuse2Data[blUse]) {
                remarks.push('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_USE ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
            }

            // 1.5 & 1.6 BL_AREA validation
            const blAreaStr = convertToText(row.BL_AREA).trim();
            if (!blAreaStr || blAreaStr === '' || blAreaStr === 'null' || blAreaStr === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_AREA');
            } else {
                const blArea = parseFloat(blAreaStr);
                if (isNaN(blArea) || blArea <= 0) {
                    remarks.push('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_AREA ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                }
            }

            // 1.7 & 1.8 BL_NSTOREY validation
            const blNstoreyStr = convertToText(row.BL_NSTOREY).trim();
            if (!blNstoreyStr || blNstoreyStr === '' || blNstoreyStr === 'null' || blNstoreyStr === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_NSTOREY');
            } else {
                const blNstorey = parseFloat(blNstoreyStr);
                if (isNaN(blNstorey) || blNstorey <= 0) {
                    remarks.push('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_NSTOREY ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                }
            }

            // 1.9 BL_NUNIT validation (only when BL_TYPE is 6)
            if (blType === '6') {
                const blNunitStr = convertToText(row.BL_NUNIT).trim();
                if (!blNunitStr || blNunitStr === '' || blNunitStr === 'null' || blNunitStr === 'undefined') {
                    remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_NUNIT');
                } else {
                    const blNunit = parseFloat(blNunitStr);
                    if (isNaN(blNunit) || blNunit <= 0) {
                        remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• BL_NUNIT');
                    }
                }
            }

            // 1.10 & 1.11 ACQYEAR validation
            const acqYearStr = convertToText(row.ACQYEAR).trim();
            if (!acqYearStr || acqYearStr === '' || acqYearStr === 'null' || acqYearStr === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ACQYEAR');
            } else {
                const acqYear = parseInt(acqYearStr);
                if (isNaN(acqYear) || acqYear < 2540 || acqYear > 2600) {
                    remarks.push('‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ACQYEAR ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á');
                }
            }

            // 1.12 PL_BLOCK validation
            const plBlockStr = convertToText(row.PL_BLOCK).trim();
            if (!plBlockStr || plBlockStr === '' || plBlockStr === 'null' || plBlockStr === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PL_BLOCK');
            }

            // 1.13 PL_USE validation
            const plUseStr = convertToText(row.PL_USE).trim();
            if (!plUseStr || plUseStr === '' || plUseStr === 'null' || plUseStr === 'undefined') {
                remarks.push('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• PL_USE');
            }

            return remarks.join(', ');
        }

        // PL_BLOCK2 functions
        function checkPLBlock(plBlockValue) {
            if (!plBlockValue) return '';
            
            plBlockValue = plBlockValue.toString();
            
            for (const [pattern, value] of Object.entries(plBlockPatterns)) {
                if (plBlockValue.includes(pattern)) {
                    return value;
                }
            }
            return '';
        }

        function checkPLBlockPattern(plBlock) {
            if (!plBlock) return false;
            const regex = /[‡∏Å-‡∏Øa-zA-Z]+\.\d+-\d+/;
            return regex.test(plBlock);
        }

        function extractTextUpToPeriod(plBlock) {
            if (!plBlock) return '';
            const periodIndex = plBlock.indexOf('.');
            if (periodIndex === -1) return plBlock;
            return plBlock.substring(0, periodIndex + 1);
        }

        // Utility functions
        function convertToText(value) {
            if (value === null || value === undefined) return "";
            return value.toString();
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            errorMessage.textContent = message;
            errorMessage.classList.remove('d-none');
            setTimeout(() => {
                errorMessage.classList.add('d-none');
            }, 5000);
        }

        function updateFileName(input, type) {
            if (type === 'excel') {
                const fileNameDisplay = document.getElementById('fileNameExcel');
                const shapefileDisplay = document.getElementById('fileNameShapefile');
                if (input.files && input.files[0]) {
                    fileNameDisplay.textContent = input.files[0].name;
                    shapefileDisplay.textContent = '';
                    originalFileName = input.files[0].name.replace(/\.[^/.]+$/, "");
                    isShapefileInput = false;
                } else {
                    fileNameDisplay.textContent = '';
                }
            } else if (type === 'shapefile') {
                const fileNameDisplay = document.getElementById('fileNameShapefile');
                const excelDisplay = document.getElementById('fileNameExcel');
                if (input.files && input.files.length > 0) {
                    if (input.files.length === 1 && input.files[0].name.endsWith('.zip')) {
                        fileNameDisplay.textContent = input.files[0].name;
                        originalFileName = input.files[0].name.replace(/\.[^/.]+$/, "");
                    } else {
                        const fileNames = Array.from(input.files).map(f => f.name).join(', ');
                        fileNameDisplay.textContent = `${input.files.length} ‡πÑ‡∏ü‡∏•‡πå: ${fileNames}`;
                        // ‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå .shp ‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏±‡∏Å
                        const shpFile = Array.from(input.files).find(f => f.name.endsWith('.shp'));
                        originalFileName = shpFile ? shpFile.name.replace(/\.[^/.]+$/, "") : 'shapefile';
                    }
                    excelDisplay.textContent = '';
                    isShapefileInput = true;
                } else {
                    fileNameDisplay.textContent = '';
                }
            }
        }

        // Column mapping functions
        function showColumnModal(columns) {
            const modal = document.getElementById('columnModal');
            const mappingList = document.getElementById('columnMappingList');
            mappingList.innerHTML = '';

            requiredColumns.forEach(reqCol => {
                const div = document.createElement('div');
                div.className = 'column-mapping';
                
                const label = document.createElement('label');
                label.textContent = reqCol;
                div.appendChild(label);

                const select = document.createElement('select');
                select.name = reqCol;
                
                // Add empty option
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = '-- ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå --';
                select.appendChild(emptyOption);

                // Add column options
                columns.forEach(col => {
                    const option = document.createElement('option');
                    option.value = col;
                    option.textContent = col;
                    // Auto-select if column names match
                    if (col.toUpperCase() === reqCol) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                div.appendChild(select);
                mappingList.appendChild(div);
            });

            modal.style.display = 'block';
        }

        function closeColumnModal() {
            document.getElementById('columnModal').style.display = 'none';
        }

        function getColumnMapping() {
            const mapping = {};
            const selects = document.querySelectorAll('#columnMappingList select');
            let isValid = true;

            selects.forEach(select => {
                if (select.value) {
                    mapping[select.name] = select.value;
                } else {
                    isValid = false;
                }
            });

            return { mapping, isValid };
        }

        // Main processing functions
        async function processExcel() {
            if (isShapefileInput) {
                // Process Shapefile
                const fileInput = document.getElementById('shapefileInput');
                const files = fileInput.files;
                if (!files || files.length === 0) {
                    showError('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Shapefile');
                    return;
                }
                await processShapefileData(files);
            } else {
                // Process Excel
                const fileInput = document.getElementById('excelFile');
                const file = fileInput.files[0];
                if (!file) {
                    showError('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå Excel');
                    return;
                }
                processExcelData(file);
            }
        }

        function processExcelData(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet);

                if (jsonData.length === 0) {
                    showError('‡πÑ‡∏ü‡∏•‡πå Excel ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
                    return;
                }

                fileData = jsonData;
                const availableColumns = Object.keys(jsonData[0]);
                
                // Check if all required columns exist
                const missingColumns = requiredColumns.filter(col => 
                    !availableColumns.some(avCol => avCol.toUpperCase() === col)
                );

                if (missingColumns.length === 0) {
                    // All columns found, process directly
                    processData(jsonData);
                } else {
                    // Show column mapping modal
                    showColumnModal(availableColumns);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async function processShapefileData(files) {
            try {
                let arrayBuffer;
                let zipContent;
                
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå .zip ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏•‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå
                if (files.length === 1 && files[0].name.endsWith('.zip')) {
                    // ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏ü‡∏•‡πå .zip
                    arrayBuffer = await files[0].arrayBuffer();
                    const zip = new JSZip();
                    zipContent = await zip.loadAsync(arrayBuffer);
                    
                    // ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
                    originalShapefileFiles = {};
                    for (const [filename, fileData] of Object.entries(zipContent.files)) {
                        if (!fileData.dir) {
                            const ext = filename.split('.').pop().toLowerCase();
                            if (['shp', 'dbf', 'shx', 'prj', 'cpg'].includes(ext)) {
                                originalShapefileFiles[ext] = await fileData.async('arraybuffer');
                            }
                        }
                    }
                } else {
                    // ‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏•‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå
                    originalShapefileFiles = {};
                    
                    // ‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÑ‡∏ü‡∏•‡πå
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        const ext = file.name.split('.').pop().toLowerCase();
                        if (['shp', 'dbf', 'shx', 'prj', 'cpg'].includes(ext)) {
                            originalShapefileFiles[ext] = await file.arrayBuffer();
                        }
                    }
                    
                    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
                    if (!originalShapefileFiles['shp'] || !originalShapefileFiles['dbf']) {
                        showError('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå .shp ‡πÅ‡∏•‡∏∞ .dbf ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢');
                        return;
                    }
                    
                    // ‡∏™‡∏£‡πâ‡∏≤‡∏á zip object ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö shpjs
                    const zip = new JSZip();
                    const baseName = originalFileName || 'shapefile';
                    
                    for (const [ext, buffer] of Object.entries(originalShapefileFiles)) {
                        zip.file(`${baseName}.${ext}`, buffer);
                    }
                    
                    arrayBuffer = await zip.generateAsync({type: 'arraybuffer'});
                }
                
                // ‡∏≠‡πà‡∏≤‡∏ô projection ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
                if (originalShapefileFiles['prj']) {
                    const prjText = new TextDecoder('utf-8').decode(originalShapefileFiles['prj']);
                    originalProjection = prjText;
                    console.log('Found projection:', prjText);
                }
                
                // Parse shapefile using shpjs
                const geojson = await shp(arrayBuffer);
                
                // Store original shapefile data with geometry
                originalShapefileData = geojson;
                
                // Extract properties from features
                const jsonData = geojson.features.map(feature => feature.properties);

                if (jsonData.length === 0) {
                    showError('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå Shapefile');
                    return;
                }

                fileData = jsonData;
                const availableColumns = Object.keys(jsonData[0]);
                
                // Check if all required columns exist
                const missingColumns = requiredColumns.filter(col => 
                    !availableColumns.some(avCol => avCol.toUpperCase() === col)
                );

                if (missingColumns.length === 0) {
                    // All columns found, process directly
                    processData(jsonData);
                } else {
                    // Show column mapping modal
                    showColumnModal(availableColumns);
                }
                
            } catch (error) {
                console.error('Error processing shapefile:', error);
                showError('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡πÑ‡∏ü‡∏•‡πå Shapefile: ' + error.message);
            }
        }

        function processWithMapping() {
            const { mapping, isValid } = getColumnMapping();
            
            if (!isValid) {
                showError('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ó‡∏∏‡∏Å‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£');
                return;
            }

            columnMapping = mapping;
            closeColumnModal();
            
            // Process data with mapped columns
            const mappedData = fileData.map(row => {
                const newRow = {};
                Object.keys(columnMapping).forEach(reqCol => {
                    newRow[reqCol] = row[columnMapping[reqCol]];
                });
                // Copy other columns as-is
                Object.keys(row).forEach(col => {
                    if (!Object.values(columnMapping).includes(col)) {
                        newRow[col] = row[col];
                    }
                });
                return newRow;
            });

            processData(mappedData);
        }

        function processData(data) {
            const progressBar = document.getElementById('progressBar');
            const progressContainer = document.getElementById('progressContainer');
            progressContainer.classList.remove('d-none');

            // First pass: process basic data and create PL_BLOCK2
            let initialData = data.map((row, index) => {
                const progress = Math.round((index + 1) / data.length * 50);
                progressBar.style.width = `${progress}%`;
                progressBar.setAttribute('aria-valuenow', progress);
                progressBar.textContent = `${progress}%`;

                const newRow = {...row};
                
                // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πá‡∏ô text ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
                newRow.BL_TYPE = convertToText(row.BL_TYPE);
                newRow.BL_USE = convertToText(row.BL_USE);
                newRow.ACQYEAR = convertToText(row.ACQYEAR);
                newRow.PL_BLOCK = convertToText(row.PL_BLOCK);
                newRow.PL_USE = convertToText(row.PL_USE);
                
                // ‡πÅ‡∏õ‡∏•‡∏á BL_NUNIT ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏°
                const nunitValue = row.BL_NUNIT;
                if (nunitValue !== null && nunitValue !== undefined) {
                    newRow.BL_NUNIT = Math.round(parseFloat(nunitValue));
                } else {
                    newRow.BL_NUNIT = 0;
                }
                
                // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö PL_BLOCK2
                newRow.PL_BLOCK2 = checkPLBlock(row.PL_BLOCK);
                
                // Validate data and generate remarks
                newRow.REMARKS = validateRowData(newRow, index);
                
                return newRow;
            });

            // Check if any records have non-empty PL_BLOCK2 values
            const hasAnyPLBlock2 = initialData.some(item => item.PL_BLOCK2 && item.PL_BLOCK2.trim() !== '');
            
            // Second pass: process PL_BLOCK2 logic if needed
            if (hasAnyPLBlock2) {
                processedData = initialData.map((row, index) => {
                    const progress = Math.round(50 + ((index + 1) / initialData.length * 50));
                    progressBar.style.width = `${progress}%`;
                    progressBar.setAttribute('aria-valuenow', progress);
                    progressBar.textContent = `${progress}%`;

                    // For rows where PL_BLOCK2 is empty, fill with text from PL_BLOCK up to period
                    if (!row.PL_BLOCK2 && row.PL_BLOCK) {
                        row.PL_BLOCK2 = extractTextUpToPeriod(row.PL_BLOCK);
                    }

                    // Store original PL_USE in PL_USE_O
                    row.PL_USE_O = row.PL_USE;

                    // If PL_BLOCK follows the pattern (e.g., ‡∏¢.1-1), update PL_USE
                    if (checkPLBlockPattern(row.PL_BLOCK)) {
                        row.PL_USE = `${row.PL_USE_O}-${row.PL_BLOCK2}`;
                    }

                    // Complete the rest of processing
                    const bl_area = parseFloat(row.BL_AREA) || 0;
                    const bl_nstorey = parseFloat(row.BL_NSTOREY) || 0;
                    const bl_nunit = parseInt(row.BL_NUNIT) || 0;
                    
                    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏° ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ formatDecimal
                    const totalUsableArea = bl_area * bl_nstorey;
                    row['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°'] = formatDecimal(totalUsableArea);

                    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ RE_BL_USE
                    row.RE_BL_USE = reuse2Data[row.BL_USE] || '';

                    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ RE_BL_AREA
                    row.RE_BL_AREA = determineCode({
                        ...row,
                        BL_AREA: formatDecimal(bl_area),
                        BL_NSTOREY: bl_nstorey,
                        BL_NUNIT: bl_nunit
                    });

                    // Format BL_AREA to decimal
                    row.BL_AREA = formatDecimal(bl_area);

                    return row;
                });
            } else {
                // Process without PL_BLOCK2 logic
                processedData = initialData.map((row, index) => {
                    const progress = Math.round(50 + ((index + 1) / initialData.length * 50));
                    progressBar.style.width = `${progress}%`;
                    progressBar.setAttribute('aria-valuenow', progress);
                    progressBar.textContent = `${progress}%`;

                    // Complete the rest of processing
                    const bl_area = parseFloat(row.BL_AREA) || 0;
                    const bl_nstorey = parseFloat(row.BL_NSTOREY) || 0;
                    const bl_nunit = parseInt(row.BL_NUNIT) || 0;
                    
                    // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏î‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏° ‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ formatDecimal
                    const totalUsableArea = bl_area * bl_nstorey;
                    row['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°'] = formatDecimal(totalUsableArea);

                    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ RE_BL_USE
                    row.RE_BL_USE = reuse2Data[row.BL_USE] || '';

                    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ RE_BL_AREA
                    row.RE_BL_AREA = determineCode({
                        ...row,
                        BL_AREA: formatDecimal(bl_area),
                        BL_NSTOREY: bl_nstorey,
                        BL_NUNIT: bl_nunit
                    });

                    // Format BL_AREA to decimal
                    row.BL_AREA = formatDecimal(bl_area);

                    return row;
                });
            }

            // Show export buttons
            document.getElementById('exportButton').classList.remove('d-none');
            
            // Show shapefile export button only if input was shapefile
            if (isShapefileInput) {
                document.getElementById('exportShapefileButton').classList.remove('d-none');
            } else {
                document.getElementById('exportShapefileButton').classList.add('d-none');
            }
        }

        function determineCode(row) {
            const { RE_BL_USE, BL_TYPE, BL_NSTOREY } = row;
            const BL_AREA = parseFloat(row.BL_AREA) || 0;
            const usableArea = row['‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏≠‡∏≤‡∏Ñ‡∏≤‡∏£‡∏£‡∏ß‡∏°'];

            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà 1-18
            if (usableArea >= 2000) {
                if (RE_BL_USE === "10" && BL_AREA >= 101 && BL_AREA <= 400) return 4;
                if (RE_BL_USE === "10" && BL_AREA >= 401) return 5;
                if (RE_BL_USE === "20" && BL_AREA >= 101 && BL_AREA <= 400) return 2;
                if (RE_BL_USE === "20" && BL_AREA >= 401) return 3;
                if (RE_BL_USE === "41" && BL_AREA >= 101 && BL_AREA <= 400) return 2;
                if (RE_BL_USE === "41" && BL_AREA >= 401) return 3;
            }

            if (usableArea >= 1000 && BL_NSTOREY >= 5) {
                if (RE_BL_USE === "10" && BL_AREA >= 101 && BL_AREA <= 400) return 4;
                if (RE_BL_USE === "10" && BL_AREA >= 401) return 5;
                if (RE_BL_USE === "20" && BL_AREA >= 101 && BL_AREA <= 400) return 2;
                if (RE_BL_USE === "20" && BL_AREA >= 401) return 3;
                if (RE_BL_USE === "41" && BL_AREA >= 101 && BL_AREA <= 400) return 2;
                if (RE_BL_USE === "41" && BL_AREA >= 401) return 3;
            }

            if (BL_NSTOREY >= 8) {
                if (RE_BL_USE === "10" && BL_AREA >= 101 && BL_AREA <= 400) return 4;
                if (RE_BL_USE === "10" && BL_AREA >= 401) return 5;
                if (RE_BL_USE === "20" && BL_AREA >= 101 && BL_AREA <= 400) return 2;
                if (RE_BL_USE === "20" && BL_AREA >= 401) return 3;
                if (RE_BL_USE === "41" && BL_AREA >= 101 && BL_AREA <= 400) return 2;
                if (RE_BL_USE === "41" && BL_AREA >= 401) return 3;
            }

            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà 19-26
            if (RE_BL_USE === "10") {
                if (BL_TYPE === "1" || BL_TYPE === "2") return 1;
                if (BL_TYPE === "3" || BL_TYPE === "4" || BL_TYPE === "5") return 2;
                if (BL_TYPE === "6"|| BL_TYPE === "7" || BL_TYPE === "8" || BL_TYPE === "98") return 3;
            }
            if (RE_BL_USE === "20" || RE_BL_USE === "41") return 1;

            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà 27-30
            if (RE_BL_USE === "30") {
                if (BL_AREA <= 200) return 1;
                if (BL_AREA > 200 && BL_AREA <= 500) return 2;
                if (BL_AREA > 500 && BL_AREA <= 1000) return 3;
                if (BL_AREA > 1000) return 4;
            }

            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà 31-33
            if (RE_BL_USE === "33") {
                if (BL_AREA <= 100) return 1;
                if (BL_AREA > 100 && BL_AREA <= 500) return 2;
                if (BL_AREA > 500) return 3;
            }

            // ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏ó‡∏µ‡πà 34-35
            if (RE_BL_USE === "80" || RE_BL_USE === "90") return 1;

            // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÉ‡∏î‡πÜ
            return 0;
        }

        function exportToExcel() {
            const ws = XLSX.utils.json_to_sheet(processedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "ProcessedData");
            
            const exportFileName = originalFileName ? `${originalFileName}_processed.xlsx` : 'bldg_reclass.xlsx';
            XLSX.writeFile(wb, exportFileName);
        }

        async function exportToShapefile() {
            if (!originalShapefileData || !processedData || !originalShapefileFiles) {
                showError('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile ‡πÑ‡∏î‡πâ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•');
                return;
            }

            try {
                // Join processed data with original properties
                // ‡∏™‡∏°‡∏°‡∏ï‡∏¥‡∏ß‡πà‡∏≤ processedData ‡∏°‡∏µ index ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö feature index
                const joinedData = originalShapefileData.features.map((feature, index) => {
                    // ‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏Å‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÅ‡∏•‡πâ‡∏ß
                    return {
                        ...feature.properties,  // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏î‡∏¥‡∏°
                        ...processedData[index]  // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡∏°‡πà (‡∏à‡∏∞ overwrite ‡∏ñ‡πâ‡∏≤‡∏ä‡∏∑‡πà‡∏≠ field ‡∏ã‡πâ‡∏≥)
                    };
                });

                // Create zip file
                const zip = new JSZip();
                const baseName = originalFileName ? `${originalFileName}_processed` : 'bldg_reclass';
                
                // 1. ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô DBF ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà)
                if (originalShapefileFiles['shp']) {
                    zip.file(`${baseName}.shp`, originalShapefileFiles['shp'], {binary: true});
                }
                if (originalShapefileFiles['shx']) {
                    zip.file(`${baseName}.shx`, originalShapefileFiles['shx'], {binary: true});
                }
                if (originalShapefileFiles['prj']) {
                    zip.file(`${baseName}.prj`, originalShapefileFiles['prj'], {binary: true});
                }
                
                // 2. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå DBF ‡πÉ‡∏´‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà Join ‡πÅ‡∏•‡πâ‡∏ß (TIS-620 encoding)
                const dbfBuffer = createDBFFile(joinedData);
                zip.file(`${baseName}.dbf`, dbfBuffer, {binary: true});
                
                // 3. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå .cpg ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏∏ encoding ‡πÄ‡∏õ‡πá‡∏ô TIS-620
                const cpgContent = 'TIS-620';
                zip.file(`${baseName}.cpg`, cpgContent);
                
                // Generate and download zip file
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Shapefile exported successfully with joined data');
                
            } catch (error) {
                console.error('Error exporting shapefile:', error);
                showError('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πà‡∏á‡∏≠‡∏≠‡∏Å Shapefile: ' + error.message);
            }
        }

        // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏£‡πâ‡∏≤‡∏á DBF ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà Join ‡πÅ‡∏•‡πâ‡∏ß (‡πÑ‡∏°‡πà‡∏°‡∏µ geometry)
        function createDBFFile(records) {
            if (!records || records.length === 0) {
                throw new Error('No records to create DBF');
            }
            
            const numRecords = records.length;
            
            // Get all unique property names from records
            const allProperties = new Set();
            records.forEach(record => {
                Object.keys(record).forEach(key => allProperties.add(key));
            });
            const properties = Array.from(allProperties);
            
            // Define field structures
            const fieldDefinitions = [];
            
            properties.forEach(prop => {
                let fieldType = 'C';  // Character (string)
                let fieldLength = 254;
                let fieldDecimal = 0;
                
                // Find first non-null value to determine type
                let sampleValue = null;
                for (let record of records) {
                    if (record[prop] !== null && record[prop] !== undefined) {
                        sampleValue = record[prop];
                        break;
                    }
                }
                
                if (sampleValue !== null) {
                    if (typeof sampleValue === 'number') {
                        // Check if it has decimals
                        const hasDecimals = !Number.isInteger(sampleValue);
                        if (hasDecimals) {
                            fieldType = 'F';
                            fieldLength = 20;
                            fieldDecimal = 8;
                        } else {
                            fieldType = 'N';
                            fieldLength = 18;
                            fieldDecimal = 0;
                        }
                    } else if (sampleValue instanceof Date) {
                        fieldType = 'D';
                        fieldLength = 8;
                        fieldDecimal = 0;
                    } else {
                        // String type - calculate max length needed
                        let maxLen = 0;
                        records.forEach(record => {
                            const val = record[prop];
                            if (val !== null && val !== undefined) {
                                const strLen = val.toString().length;
                                if (strLen > maxLen) maxLen = strLen;
                            }
                        });
                        fieldLength = Math.min(Math.max(maxLen, 10), 254);
                    }
                }
                
                // Limit field name to 10 characters
                const fieldName = prop.substring(0, 10);
                
                fieldDefinitions.push({
                    name: fieldName,
                    originalName: prop,
                    type: fieldType,
                    length: fieldLength,
                    decimal: fieldDecimal
                });
            });
            
            // Calculate record length
            const recordLength = fieldDefinitions.reduce((sum, field) => sum + field.length, 1); // +1 for deletion flag
            
            // Calculate header size
            const numFields = fieldDefinitions.length;
            const headerSize = 32 + (numFields * 32) + 1; // Header + field descriptors + terminator
            
            // Calculate total file size
            const totalSize = headerSize + (numRecords * recordLength) + 1; // +1 for EOF marker
            
            // Create buffer
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);
            
            // Write Header
            view.setUint8(0, 0x03); // dBASE Level 5
            
            // Last update date
            const now = new Date();
            view.setUint8(1, now.getFullYear() - 1900);
            view.setUint8(2, now.getMonth() + 1);
            view.setUint8(3, now.getDate());
            
            // Number of records
            view.setUint32(4, numRecords, true);
            
            // Header size
            view.setUint16(8, headerSize, true);
            
            // Record size
            view.setUint16(10, recordLength, true);
            
            // Write Field Descriptors
            let fieldOffset = 32;
            fieldDefinitions.forEach(field => {
                // Field name (11 bytes, null-padded)
                for (let i = 0; i < field.name.length && i < 10; i++) {
                    uint8View[fieldOffset + i] = field.name.charCodeAt(i);
                }
                for (let i = field.name.length; i < 11; i++) {
                    uint8View[fieldOffset + i] = 0x00;
                }
                
                // Field type
                uint8View[fieldOffset + 11] = field.type.charCodeAt(0);
                
                // Field data address (not used)
                view.setUint32(fieldOffset + 12, 0, true);
                
                // Field length
                view.setUint8(fieldOffset + 16, field.length);
                
                // Decimal count
                view.setUint8(fieldOffset + 17, field.decimal);
                
                fieldOffset += 32;
            });
            
            // Field descriptor terminator
            uint8View[fieldOffset] = 0x0D;
            
            // Write Records
            let recordOffset = headerSize;
            
            records.forEach((record, recordIndex) => {
                // Deletion flag (not deleted)
                uint8View[recordOffset] = 0x20;
                recordOffset++;
                
                // Write each field value
                fieldDefinitions.forEach(field => {
                    let value = '';
                    const propValue = record[field.originalName];
                    
                    if (propValue !== undefined && propValue !== null) {
                        if (field.type === 'D' && propValue instanceof Date) {
                            const year = propValue.getFullYear().toString().padStart(4, '0');
                            const month = (propValue.getMonth() + 1).toString().padStart(2, '0');
                            const day = propValue.getDate().toString().padStart(2, '0');
                            value = year + month + day;
                        } else if (field.type === 'N' || field.type === 'F') {
                            const numValue = typeof propValue === 'number' ? propValue : parseFloat(propValue);
                            if (!isNaN(numValue)) {
                                if (field.decimal > 0) {
                                    value = numValue.toFixed(field.decimal);
                                } else {
                                    value = Math.round(numValue).toString();
                                }
                            } else {
                                value = '';
                            }
                        } else {
                            value = propValue.toString();
                        }
                    }
                    
                    // Pad or trim value
                    if (field.type === 'N' || field.type === 'F') {
                        value = value.substring(0, field.length).padStart(field.length, ' ');
                    } else {
                        value = value.substring(0, field.length).padEnd(field.length, ' ');
                    }
                    
                    // Encode to TIS-620
                    const encodedBytes = encodeToTIS620(value, field.length);
                    for (let i = 0; i < field.length; i++) {
                        uint8View[recordOffset + i] = encodedBytes[i];
                    }
                    
                    recordOffset += field.length;
                });
            });
            
            // End of file marker
            uint8View[totalSize - 1] = 0x1A;
            
            return buffer;
        }

        // Helper function to get first coordinate from geometry
        function getFirstCoordinate(geometry) {
            if (!geometry || !geometry.coordinates) return null;
            
            const coords = geometry.coordinates;
            
            if (geometry.type === 'Point') {
                return coords;
            } else if (geometry.type === 'MultiPoint') {
                return coords[0];
            } else if (geometry.type === 'LineString') {
                return coords[0];
            } else if (geometry.type === 'MultiLineString') {
                return coords[0][0];
            } else if (geometry.type === 'Polygon') {
                return coords[0][0];
            } else if (geometry.type === 'MultiPolygon') {
                return coords[0][0][0];
            }
            
            return null;
        }

        // Helper functions for creating shapefile (from page11D)
        async function createShapefileFromGeoJSON(geoJSON, type, zip, prjContent) {
            try {
                const typeSuffix = type === 'point' ? 'point' : (type === 'line' ? 'line' : 'poly');
                const baseName = originalFileName ? `${originalFileName}_processed_${typeSuffix}` : `output_${typeSuffix}`;
                
                // Collect all features and properties
                const features = geoJSON.features;
                const properties = features.length > 0 ? Object.keys(features[0].properties || {}) : [];
                
                // Calculate bounding box
                const bbox = calculateBoundingBox(geoJSON);
                
                // Determine shape type
                let shapeType = 0;
                if (type === 'point') shapeType = 1;      // Point
                else if (type === 'line') shapeType = 3;   // Polyline
                else if (type === 'polygon') shapeType = 5; // Polygon
                
                // Create SHP file
                const shpData = createCompleteShpFile(features, shapeType, bbox);
                zip.file(`${baseName}.shp`, shpData, {binary: true});
                
                // Create SHX file (index)
                const shxData = createCompleteShxFile(features, shapeType);
                zip.file(`${baseName}.shx`, shxData, {binary: true});
                
                // Create DBF file (attributes) with TIS-620 encoding
                const dbfData = createCompleteDbfFile(features, properties);
                zip.file(`${baseName}.dbf`, dbfData, {binary: true});
                
                // Add PRJ file
                if (prjContent) {
                    zip.file(`${baseName}.prj`, prjContent);
                }
                
                // Add CPG file for TIS-620 encoding (for Thai language support)
                zip.file(`${baseName}.cpg`, 'TIS-620');
                
                return true;
            } catch (error) {
                console.error('Error in shapefile creation:', error);
                throw error;
            }
        }

        // Create complete SHP file with proper structure
        function createCompleteShpFile(features, shapeType, bbox) {
            const records = [];
            let offset = 50; // Header is 100 bytes = 50 16-bit words
            
            features.forEach((feature, index) => {
                const recordHeader = new ArrayBuffer(8);
                const recordHeaderView = new DataView(recordHeader);
                
                // Record number (1-based, big-endian)
                recordHeaderView.setInt32(0, index + 1, false);
                
                // Content length will be calculated based on geometry
                let contentLength = 0;
                let shapeData;
                
                if (shapeType === 1) { // Point
                    contentLength = 10; // 20 bytes = 10 words (4 for type + 16 for coordinates)
                    shapeData = createPointRecord(feature.geometry);
                } else if (shapeType === 3) { // Polyline
                    const result = createPolylineRecord(feature.geometry);
                    contentLength = result.length;
                    shapeData = result.data;
                } else if (shapeType === 5) { // Polygon
                    const result = createPolygonRecord(feature.geometry);
                    contentLength = result.length;
                    shapeData = result.data;
                }
                
                recordHeaderView.setInt32(4, contentLength, false);
                
                records.push({
                    header: recordHeader,
                    data: shapeData,
                    offset: offset,
                    length: contentLength
                });
                
                offset += 4 + contentLength; // 4 words for record header + content length
            });
            
            // Calculate total file length in 16-bit words
            const fileLengthWords = offset;
            
            // Create main header (100 bytes)
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            
            // File code (9994) - big endian
            headerView.setInt32(0, 9994, false);
            
            // Unused positions (5 int32)
            for (let i = 4; i < 24; i += 4) {
                headerView.setInt32(i, 0, false);
            }
            
            // File length in 16-bit words - big endian
            headerView.setInt32(24, fileLengthWords, false);
            
            // Version (1000) - little endian
            headerView.setInt32(28, 1000, true);
            
            // Shape type - little endian
            headerView.setInt32(32, shapeType, true);
            
            // Bounding box - little endian
            headerView.setFloat64(36, bbox.xmin, true);
            headerView.setFloat64(44, bbox.ymin, true);
            headerView.setFloat64(52, bbox.xmax, true);
            headerView.setFloat64(60, bbox.ymax, true);
            
            // Z range (unused, set to 0)
            headerView.setFloat64(68, 0, true);
            headerView.setFloat64(76, 0, true);
            
            // M range (unused, set to 0)
            headerView.setFloat64(84, 0, true);
            headerView.setFloat64(92, 0, true);
            
            // Combine header and all records
            const totalSize = 100 + records.reduce((sum, rec) => sum + 8 + rec.data.byteLength, 0);
            const result = new Uint8Array(totalSize);
            
            // Copy header
            result.set(new Uint8Array(header), 0);
            
            // Copy records
            let position = 100;
            records.forEach(record => {
                result.set(new Uint8Array(record.header), position);
                position += 8;
                result.set(new Uint8Array(record.data), position);
                position += record.data.byteLength;
            });
            
            return result.buffer;
        }

        // Create point record
        function createPointRecord(geometry) {
            const coords = geometry.coordinates;
            const buffer = new ArrayBuffer(20);
            const view = new DataView(buffer);
            
            // Shape type (1 = Point) - little endian
            view.setInt32(0, 1, true);
            
            // X coordinate
            view.setFloat64(4, coords[0], true);
            
            // Y coordinate
            view.setFloat64(12, coords[1], true);
            
            return buffer;
        }

        // Create polyline record
        function createPolylineRecord(geometry) {
            let allCoords = [];
            
            if (geometry.type === 'LineString') {
                allCoords = [geometry.coordinates];
            } else if (geometry.type === 'MultiLineString') {
                allCoords = geometry.coordinates;
            }
            
            const numParts = allCoords.length;
            const numPoints = allCoords.reduce((sum, part) => sum + part.length, 0);
            
            // Calculate bounding box
            const bbox = calculateGeometryBbox(allCoords);
            
            // Calculate record size
            const recordSize = 44 + (4 * numParts) + (16 * numPoints);
            const buffer = new ArrayBuffer(recordSize);
            const view = new DataView(buffer);
            let offset = 0;
            
            // Shape type (3 = Polyline)
            view.setInt32(offset, 3, true);
            offset += 4;
            
            // Bounding box
            view.setFloat64(offset, bbox.xmin, true); offset += 8;
            view.setFloat64(offset, bbox.ymin, true); offset += 8;
            view.setFloat64(offset, bbox.xmax, true); offset += 8;
            view.setFloat64(offset, bbox.ymax, true); offset += 8;
            
            // Number of parts
            view.setInt32(offset, numParts, true); offset += 4;
            
            // Number of points
            view.setInt32(offset, numPoints, true); offset += 4;
            
            // Parts array (starting indices)
            let pointIndex = 0;
            for (let i = 0; i < numParts; i++) {
                view.setInt32(offset, pointIndex, true);
                offset += 4;
                pointIndex += allCoords[i].length;
            }
            
            // Points array
            allCoords.forEach(part => {
                part.forEach(coord => {
                    view.setFloat64(offset, coord[0], true); offset += 8;
                    view.setFloat64(offset, coord[1], true); offset += 8;
                });
            });
            
            return {
                data: buffer,
                length: recordSize / 2 // Convert to 16-bit words
            };
        }

        // Create polygon record
        function createPolygonRecord(geometry) {
            let allRings = [];
            
            if (geometry.type === 'Polygon') {
                allRings = geometry.coordinates;
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates.forEach(polygon => {
                    allRings = allRings.concat(polygon);
                });
            }
            
            const numParts = allRings.length;
            const numPoints = allRings.reduce((sum, ring) => sum + ring.length, 0);
            
            // Calculate bounding box
            const bbox = calculateGeometryBbox(allRings);
            
            // Calculate record size
            const recordSize = 44 + (4 * numParts) + (16 * numPoints);
            const buffer = new ArrayBuffer(recordSize);
            const view = new DataView(buffer);
            let offset = 0;
            
            // Shape type (5 = Polygon)
            view.setInt32(offset, 5, true);
            offset += 4;
            
            // Bounding box
            view.setFloat64(offset, bbox.xmin, true); offset += 8;
            view.setFloat64(offset, bbox.ymin, true); offset += 8;
            view.setFloat64(offset, bbox.xmax, true); offset += 8;
            view.setFloat64(offset, bbox.ymax, true); offset += 8;
            
            // Number of parts
            view.setInt32(offset, numParts, true); offset += 4;
            
            // Number of points
            view.setInt32(offset, numPoints, true); offset += 4;
            
            // Parts array (starting indices)
            let pointIndex = 0;
            for (let i = 0; i < numParts; i++) {
                view.setInt32(offset, pointIndex, true);
                offset += 4;
                pointIndex += allRings[i].length;
            }
            
            // Points array
            allRings.forEach(ring => {
                ring.forEach(coord => {
                    view.setFloat64(offset, coord[0], true); offset += 8;
                    view.setFloat64(offset, coord[1], true); offset += 8;
                });
            });
            
            return {
                data: buffer,
                length: recordSize / 2 // Convert to 16-bit words
            };
        }

        // Create SHX file (index)
        function createCompleteShxFile(features, shapeType) {
            const numRecords = features.length;
            
            // Calculate bounding box
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            features.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;
                
                const coords = feature.geometry.coordinates;
                const processCoord = (coord) => {
                    if (Array.isArray(coord[0])) {
                        coord.forEach(processCoord);
                    } else {
                        xmin = Math.min(xmin, coord[0]);
                        ymin = Math.min(ymin, coord[1]);
                        xmax = Math.max(xmax, coord[0]);
                        ymax = Math.max(ymax, coord[1]);
                    }
                };
                processCoord(coords);
            });
            
            const bbox = { xmin, ymin, xmax, ymax };
            
            // Calculate offsets and lengths for each record
            let offset = 50; // Start after 100-byte header (in 16-bit words)
            const indexRecords = [];
            
            features.forEach((feature) => {
                let contentLength = 0;
                
                if (shapeType === 1) {
                    contentLength = 10;
                } else if (shapeType === 3) {
                    const result = calculatePolylineSize(feature.geometry);
                    contentLength = result / 2;
                } else if (shapeType === 5) {
                    const result = calculatePolygonSize(feature.geometry);
                    contentLength = result / 2;
                }
                
                indexRecords.push({
                    offset: offset,
                    length: contentLength
                });
                
                offset += 4 + contentLength;
            });
            
            // Total file length in 16-bit words
            const fileLengthWords = 50 + (numRecords * 4); // Header + index records
            
            // Create header
            const header = new ArrayBuffer(100);
            const headerView = new DataView(header);
            
            // File code (9994) - big endian
            headerView.setInt32(0, 9994, false);
            
            // Unused
            for (let i = 4; i < 24; i += 4) {
                headerView.setInt32(i, 0, false);
            }
            
            // File length - big endian
            headerView.setInt32(24, fileLengthWords, false);
            
            // Version (1000) - little endian
            headerView.setInt32(28, 1000, true);
            
            // Shape type - little endian
            headerView.setInt32(32, shapeType, true);
            
            // Bounding box - little endian
            headerView.setFloat64(36, bbox.xmin, true);
            headerView.setFloat64(44, bbox.ymin, true);
            headerView.setFloat64(52, bbox.xmax, true);
            headerView.setFloat64(60, bbox.ymax, true);
            headerView.setFloat64(68, 0, true);
            headerView.setFloat64(76, 0, true);
            headerView.setFloat64(84, 0, true);
            headerView.setFloat64(92, 0, true);
            
            // Create index records
            const indexBuffer = new ArrayBuffer(numRecords * 8);
            const indexView = new DataView(indexBuffer);
            
            indexRecords.forEach((record, i) => {
                const pos = i * 8;
                indexView.setInt32(pos, record.offset, false);      // Offset - big endian
                indexView.setInt32(pos + 4, record.length, false);  // Length - big endian
            });
            
            // Combine header and index
            const result = new Uint8Array(100 + indexBuffer.byteLength);
            result.set(new Uint8Array(header), 0);
            result.set(new Uint8Array(indexBuffer), 100);
            
            return result.buffer;
        }

        // Helper function to calculate polyline size
        function calculatePolylineSize(geometry) {
            let numParts = 0;
            let numPoints = 0;
            
            if (geometry.type === 'LineString') {
                numParts = 1;
                numPoints = geometry.coordinates.length;
            } else if (geometry.type === 'MultiLineString') {
                numParts = geometry.coordinates.length;
                numPoints = geometry.coordinates.reduce((sum, part) => sum + part.length, 0);
            }
            
            return 44 + (4 * numParts) + (16 * numPoints);
        }

        // Helper function to calculate polygon size
        function calculatePolygonSize(geometry) {
            let numParts = 0;
            let numPoints = 0;
            
            if (geometry.type === 'Polygon') {
                numParts = geometry.coordinates.length;
                numPoints = geometry.coordinates.reduce((sum, ring) => sum + ring.length, 0);
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates.forEach(polygon => {
                    numParts += polygon.length;
                    polygon.forEach(ring => {
                        numPoints += ring.length;
                    });
                });
            }
            
            return 44 + (4 * numParts) + (16 * numPoints);
        }

        // Create DBF file
        function createCompleteDbfFile(features, properties) {
            const numRecords = features.length;
            
            // Define field structures with proper lengths
            const fieldDefinitions = [
                { name: 'FID', type: 'N', length: 10, decimal: 0 }
            ];
            
            // Add property fields
            properties.forEach(prop => {
                let fieldType = 'C';  // Character (string)
                let fieldLength = 254;
                let fieldDecimal = 0;
                
                // Analyze the property values to determine type
                const sampleValue = features[0].properties[prop];
                
                if (typeof sampleValue === 'number') {
                    if (Number.isInteger(sampleValue)) {
                        fieldType = 'N';
                        fieldLength = 18;
                        fieldDecimal = 0;
                    } else {
                        fieldType = 'F';
                        fieldLength = 20;
                        fieldDecimal = 8;
                    }
                } else if (sampleValue instanceof Date) {
                    fieldType = 'D';
                    fieldLength = 8;
                    fieldDecimal = 0;
                }
                
                // Limit field name to 10 characters
                const fieldName = prop.substring(0, 10);
                
                fieldDefinitions.push({
                    name: fieldName,
                    type: fieldType,
                    length: fieldLength,
                    decimal: fieldDecimal
                });
            });
            
            // Calculate record length
            const recordLength = fieldDefinitions.reduce((sum, field) => sum + field.length, 1); // +1 for deletion flag
            
            // Calculate header size
            const numFields = fieldDefinitions.length;
            const headerSize = 32 + (numFields * 32) + 1; // Header + field descriptors + terminator
            
            // Calculate total file size
            const totalSize = headerSize + (numRecords * recordLength) + 1; // +1 for EOF marker
            
            // Create buffer
            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const uint8View = new Uint8Array(buffer);
            
            // Write Header
            // Version (0x03 = dBASE Level 5)
            view.setUint8(0, 0x03);
            
            // Last update date (YY MM DD)
            const now = new Date();
            view.setUint8(1, now.getFullYear() - 1900);
            view.setUint8(2, now.getMonth() + 1);
            view.setUint8(3, now.getDate());
            
            // Number of records
            view.setUint32(4, numRecords, true);
            
            // Header size
            view.setUint16(8, headerSize, true);
            
            // Record size
            view.setUint16(10, recordLength, true);
            
            // Reserved bytes (12-31) are already 0
            
            // Write Field Descriptors
            let fieldOffset = 32;
            fieldDefinitions.forEach(field => {
                // Field name (11 bytes, null-padded)
                for (let i = 0; i < field.name.length && i < 10; i++) {
                    uint8View[fieldOffset + i] = field.name.charCodeAt(i);
                }
                for (let i = field.name.length; i < 11; i++) {
                    uint8View[fieldOffset + i] = 0x00;
                }
                
                // Field type
                uint8View[fieldOffset + 11] = field.type.charCodeAt(0);
                
                // Field data address (not used, set to 0)
                view.setUint32(fieldOffset + 12, 0, true);
                
                // Field length
                view.setUint8(fieldOffset + 16, field.length);
                
                // Decimal count
                view.setUint8(fieldOffset + 17, field.decimal);
                
                fieldOffset += 32;
            });
            
            // Field descriptor terminator
            uint8View[fieldOffset] = 0x0D;
            
            // Write Records
            let recordOffset = headerSize;
            
            features.forEach((feature, index) => {
                // Deletion flag (0x20 = not deleted)
                uint8View[recordOffset] = 0x20;
                recordOffset++;
                
                // Write each field value
                fieldDefinitions.forEach((field, fieldIndex) => {
                    let value = '';
                    
                    if (fieldIndex === 0) {
                        // FID field
                        value = (index + 1).toString();
                    } else {
                        // Property field
                        const propName = properties[fieldIndex - 1];
                        const propValue = feature.properties && feature.properties[propName];
                        
                        if (propValue !== undefined && propValue !== null) {
                            if (field.type === 'D' && propValue instanceof Date) {
                                const year = propValue.getFullYear().toString().padStart(4, '0');
                                const month = (propValue.getMonth() + 1).toString().padStart(2, '0');
                                const day = propValue.getDate().toString().padStart(2, '0');
                                value = year + month + day;
                            } else if (field.type === 'N' || field.type === 'F') {
                                const numValue = typeof propValue === 'number' ? propValue : parseFloat(propValue);
                                if (!isNaN(numValue)) {
                                    if (field.decimal > 0) {
                                        value = numValue.toFixed(field.decimal);
                                    } else {
                                        value = Math.round(numValue).toString();
                                    }
                                } else {
                                    value = '';
                                }
                            } else {
                                value = propValue.toString();
                            }
                        }
                    }
                    
                    // Trim or pad value to field length
                    if (field.type === 'N' || field.type === 'F') {
                        value = value.substring(0, field.length).padStart(field.length, ' ');
                    } else {
                        value = value.substring(0, field.length).padEnd(field.length, ' ');
                    }
                    
                    // Write field value with TIS-620 encoding for Thai characters
                    const encodedBytes = encodeToTIS620(value, field.length);
                    for (let i = 0; i < field.length; i++) {
                        uint8View[recordOffset + i] = encodedBytes[i];
                    }
                    
                    recordOffset += field.length;
                });
            });
            
            // End of file marker
            uint8View[totalSize - 1] = 0x1A;
            
            return buffer;
        }

        // Function to encode string to TIS-620 bytes
        function encodeToTIS620(str, length) {
            const bytes = new Uint8Array(length);
            bytes.fill(0x20); // Fill with spaces
            
            let byteIndex = 0;
            for (let i = 0; i < str.length && byteIndex < length; i++) {
                const char = str.charAt(i);
                const code = char.charCodeAt(0);
                
                // ASCII characters (0x00-0x7F) - same in TIS-620
                if (code <= 0x7F) {
                    bytes[byteIndex] = code;
                    byteIndex++;
                }
                // Thai characters (Unicode 0x0E01-0x0E5B maps to TIS-620 0xA1-0xFB)
                else if (code >= 0x0E01 && code <= 0x0E5B) {
                    bytes[byteIndex] = code - 0x0E01 + 0xA1;
                    byteIndex++;
                }
                // Special Thai characters mapping
                else if (code === 0x0E3F) { // ‡∏ø (Baht sign)
                    bytes[byteIndex] = 0xDF;
                    byteIndex++;
                }
                // Non-breaking space
                else if (code === 0x00A0) {
                    bytes[byteIndex] = 0xA0;
                    byteIndex++;
                }
                // Other characters - use space or try to preserve ASCII-compatible
                else if (code < 0x100) {
                    bytes[byteIndex] = code;
                    byteIndex++;
                } else {
                    bytes[byteIndex] = 0x3F; // Question mark for unsupported characters
                    byteIndex++;
                }
            }
            
            return bytes;
        }

        // Calculate bounding box from GeoJSON features
        function calculateBoundingBox(geoJSON) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            geoJSON.features.forEach(feature => {
                if (!feature.geometry || !feature.geometry.coordinates) return;
                
                const coords = feature.geometry.coordinates;
                const processCoord = (coord) => {
                    if (Array.isArray(coord[0])) {
                        coord.forEach(processCoord);
                    } else {
                        xmin = Math.min(xmin, coord[0]);
                        ymin = Math.min(ymin, coord[1]);
                        xmax = Math.max(xmax, coord[0]);
                        ymax = Math.max(ymax, coord[1]);
                    }
                };
                processCoord(coords);
            });
            
            return { xmin, ymin, xmax, ymax };
        }

        // Calculate geometry bounding box
        function calculateGeometryBbox(coords) {
            let xmin = Infinity, ymin = Infinity;
            let xmax = -Infinity, ymax = -Infinity;
            
            const processCoord = (coord) => {
                if (Array.isArray(coord[0])) {
                    coord.forEach(processCoord);
                } else {
                    xmin = Math.min(xmin, coord[0]);
                    ymin = Math.min(ymin, coord[1]);
                    xmax = Math.max(xmax, coord[0]);
                    ymax = Math.max(ymax, coord[1]);
                }
            };
            
            coords.forEach(processCoord);
            
            return { xmin, ymin, xmax, ymax };
        }

        // ‡πÄ‡∏û‡∏¥‡πà‡∏° Event Listeners
        document.getElementById('processButton').addEventListener('click', processExcel);
        document.getElementById('exportButton').addEventListener('click', exportToExcel);
        document.getElementById('exportShapefileButton').addEventListener('click', exportToShapefile);
    </script>
    <script>
    const menuBtn = document.getElementById('mobileMenuBtn');
    const nav = document.getElementById('mainNav');

    menuBtn.addEventListener('click', () => {
        menuBtn.classList.toggle('active');
        nav.classList.toggle('active');
    });

    function toggleMobileDropdown(element) {
        if (window.innerWidth <= 1200) {
            element.classList.toggle('active');
        }
    }
    
    // ‡∏õ‡∏¥‡∏î‡πÄ‡∏°‡∏ô‡∏π‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ß‡πà‡∏≤‡∏á
    document.addEventListener('click', (e) => {
        if (!nav.contains(e.target) && !menuBtn.contains(e.target) && nav.classList.contains('active')) {
            nav.classList.remove('active');
            menuBtn.classList.remove('active');
        }
    });
</script>
<script data-goatcounter="https://mponline.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script> 
</body>
</html>