<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>แผนที่ขอบเขตผังและถนน</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <style>
        html, body, #mapDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        /* Search Container */
        #searchContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 300px;
        }

        /* Grid Process Container */
        #gridProcessContainer {
            position: absolute;
            top: 20px;
            left: 340px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 250px;
            display: none;
        }

        .status-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        /* Draw Tools */
        #drawTools {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 180px;
        }

        /* Widgets */
        .esri-layer-list {
            position: absolute;
            top: 20px;
            right: 220px;
            max-height: calc(100vh - 240px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            max-height: 200px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-sketch {
            position: absolute;
            top: 100px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Form Elements */
        .search-input, .search-select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .search-input:focus, .search-select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        /* Buttons */
        .button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #previewButton {
            background-color: #2196F3;
            color: white;
        }

        #previewButton:hover {
            background-color: #1976D2;
        }

        #exportButton {
            background-color: #4CAF50;
            color: white;
        }

        #exportButton:hover {
            background-color: #45a049;
        }

        #gridProcessButton {
            background-color: #FF9800;
            color: white;
            display: none;
        }

        #gridProcessButton:hover {
            background-color: #F57C00;
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Tool Buttons */
        .tool-button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
        }

        .tool-button.active {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .tool-button:hover {
            background-color: #f0f0f0;
        }

        .tool-button.active:hover {
            background-color: #1976D2;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Status Messages */
        #loadingMessage, #gridStatus {
            color: #666;
            margin-top: 5px;
            font-size: 0.9em;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: none;
        }

        /* Layer Type Info */
        #layerTypeInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 2;
            min-width: 200px;
        }

        .type-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .type-polygon {
            background-color: #4CAF50;
        }

        .type-polyline {
            background-color: #2196F3;
        }

        .type-unknown {
            background-color: #FF5722;
        }

        /* Responsive Adjustments */
        @media screen and (max-height: 800px) {
            .esri-layer-list {
                max-height: calc(100vh - 400px);
            }
            .esri-legend {
                max-height: 150px;
            }
        }
    </style>
</head>
<body>
    <div id="searchContainer">
        <input type="text" id="searchInput" class="search-input" placeholder="ค้นหาขอบเขตผัง...">
        <select id="boundarySelect" class="search-select">
            <option value="">เลือกขอบเขตผัง</option>
        </select>
        <button id="previewButton" class="button" disabled>แสดงตัวอย่างถนนที่จะส่งออก</button>
        <button id="gridProcessButton" class="button">ประมวลผลใหม่ด้วยกริด</button>
        <button id="exportButton" class="button" disabled>ส่งออก GeoJSON</button>
        <div id="loadingMessage">กำลังโหลดข้อมูล...</div>
    </div>

    <div id="gridProcessContainer">
        <h3 style="margin: 0 0 10px 0; font-size: 14px;">การประมวลผลด้วยกริด</h3>
        <div id="gridStatus" class="status-text"></div>
        <div class="progress-bar">
            <div class="progress-bar-fill"></div>
        </div>
        <div id="gridDetails" class="status-text"></div>
    </div>

    <div id="drawTools">
        <button id="drawPolygonButton" class="tool-button">วาดพื้นที่เลือก</button>
        <button id="clearSelectionButton" class="tool-button">ล้างการเลือก</button>
    </div>

    <div id="mapDiv"></div>

    <script src="https://js.arcgis.com/4.28/"></script>
    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/layers/GraphicsLayer",
            "esri/geometry/geometryEngine",
            "esri/rest/support/Query",
            "esri/geometry/Polygon",
            "esri/widgets/LayerList",
            "esri/widgets/Legend",
            "esri/widgets/Sketch",
            "esri/Graphic",
            "esri/geometry/support/webMercatorUtils",
            "esri/geometry/SpatialReference",
            "esri/geometry/projection"
        ], function(
            Map, MapView, FeatureLayer, GraphicsLayer, geometryEngine, 
            Query, Polygon, LayerList, Legend, Sketch, Graphic, 
            webMercatorUtils, SpatialReference, projection
        ) {
            // Load the projection engine
            projection.load().then(() => {
                initializeApp();
            });

            function initializeApp() {
                const loadingMessage = document.getElementById("loadingMessage");
                const gridStatus = document.getElementById("gridStatus");
                const gridDetails = document.getElementById("gridDetails");
                const exportButton = document.getElementById("exportButton");
                const previewButton = document.getElementById("previewButton");
                const gridProcessButton = document.getElementById("gridProcessButton");
                const progressBar = document.querySelector(".progress-bar");
                const progressBarFill = document.querySelector(".progress-bar-fill");
                let selectedRoads = null;
                let currentBoundaryGeometry = null;
                // ตัวแปรเก็บประเภทของ geometry
                let roadGeometryType = "polyline"; // ค่าเริ่มต้นเป็น polyline

                const map = new Map({
                    basemap: "streets"
                });

                const view = new MapView({
                    container: "mapDiv",
                    map: map,
                    center: [100.5234, 13.7563],
                    zoom: 6
                });

                // Layers
                const selectionLayer = new GraphicsLayer({
                    title: "พื้นที่ที่เลือก"
                });

                const gridLayer = new GraphicsLayer({
                    title: "กริดการประมวลผล"
                });

                const roadsLayer = new FeatureLayer({
                    url: "https://tcpebps.dpt.go.th/arcgis/rest/services/service/BLGD/MapServer/0",
                    outFields: ["*"],
                    title: "ถนน",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-line",
                            color: [0, 0, 0],
                            width: "1.5px"
                        }
                    }
                });

                const exportPreviewLayer = new GraphicsLayer({
                    title: "ถนนที่จะส่งออก",
                    visible: false
                });

                const boundariesLayer = new FeatureLayer({
                    url: "https://dptgis.dpt.go.th/arcgis/rest/services/Compbnd/MapServer/0",
                    outFields: ["*"],
                    title: "ขอบเขตผัง",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-fill",
                            color: [0, 0, 0, 0],
                            outline: {
                                color: [255, 0, 0],
                                width: 2
                            }
                        }
                    }
                });

                map.addMany([roadsLayer, exportPreviewLayer, boundariesLayer, selectionLayer, gridLayer]);

                // เพิ่มฟังก์ชันตรวจสอบประเภทของชั้นข้อมูลถนน
                function checkRoadLayerGeometryType() {
                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังตรวจสอบประเภทชั้นข้อมูลถนน...";
                    
                    roadsLayer.queryFeatures({
                        where: "1=1",
                        returnGeometry: true,
                        outFields: ["*"],
                        num: 1
                    }).then(function(result) {
                        if (result.features.length > 0) {
                            const geometry = result.features[0].geometry;
                            
                            if (geometry.type === "polygon") {
                                roadGeometryType = "polygon";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Polygon";
                            } else if (geometry.type === "polyline") {
                                roadGeometryType = "polyline";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Line";
                            } else {
                                roadGeometryType = "unknown";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: " + geometry.type;
                            }
                            
                            // แสดงข้อความแจ้งเตือนผู้ใช้
                            const geometryInfoDiv = document.createElement("div");
                            geometryInfoDiv.id = "geometryInfoDiv";
                            geometryInfoDiv.style.position = "absolute";
                            geometryInfoDiv.style.bottom = "20px";
                            geometryInfoDiv.style.left = "20px";
                            geometryInfoDiv.style.backgroundColor = "#f8f9fa";
                            geometryInfoDiv.style.border = "1px solid #ddd";
                            geometryInfoDiv.style.borderRadius = "8px";
                            geometryInfoDiv.style.padding = "10px";
                            geometryInfoDiv.style.zIndex = "10";
                            geometryInfoDiv.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
                            geometryInfoDiv.style.maxWidth = "300px";
                            
                            if (roadGeometryType === "polygon") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Polygon</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะรักษารูปแบบ Polygon และโครงสร้างข้อมูลต้นฉบับ</p>
                                `;
                            } else if (roadGeometryType === "polyline") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Line</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะอยู่ในรูปแบบ LineString</p>
                                `;
                            } else {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #FF5722;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: <strong>${geometry.type}</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">อาจเกิดข้อผิดพลาดในการส่งออกข้อมูล</p>
                                `;
                            }
                            
                            // ลบข้อความเดิมถ้ามี
                            const existingInfo = document.getElementById("geometryInfoDiv");
                            if (existingInfo) {
                                existingInfo.remove();
                            }
                            
                            document.body.appendChild(geometryInfoDiv);
                        }
                        
                        loadingMessage.style.display = "none";
                    }).catch(function(error) {
                        console.error("Error checking road layer geometry type:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการตรวจสอบประเภทชั้นข้อมูล";
                        roadGeometryType = "unknown";
                        loadingMessage.style.display = "none";
                    });
                }

                // Grid Processing Functions
                function createGridCells(extent, gridSize = 500) {  // เปลี่ยนขนาดกริดเริ่มต้นเป็น 500 เมตร
                    const grids = [];
                    
                    // Convert extent to UTM Zone 47N for accurate measurements
                    const utmExtent = projection.project(extent, new SpatialReference({ wkid: 32647 }));
                    
                    const xmin = Math.floor(utmExtent.xmin / gridSize) * gridSize;
                    const ymin = Math.floor(utmExtent.ymin / gridSize) * gridSize;
                    const xmax = Math.ceil(utmExtent.xmax / gridSize) * gridSize;
                    const ymax = Math.ceil(utmExtent.ymax / gridSize) * gridSize;
                    
                    // สร้างกริดขนาดตามที่กำหนด
                    for (let x = xmin; x < xmax; x += gridSize) {
                        for (let y = ymin; y < ymax; y += gridSize) {
                            const gridPolygon = new Polygon({
                                rings: [[[x, y], [x + gridSize, y], [x + gridSize, y + gridSize], [x, y + gridSize], [x, y]]],
                                spatialReference: { wkid: 32647 }
                            });
                            
                            // Project back to web mercator for display
                            const displayPolygon = projection.project(gridPolygon, view.spatialReference);
                            grids.push(displayPolygon);
                        }
                    }
                    
                    // ในกรณีที่กริดมีจำนวนมาก ให้แสดงคำเตือน
                    if (grids.length > 2000) {
                        console.warn(`จำนวนกริดมากเกินไป (${grids.length}). อาจทำให้ประสิทธิภาพลดลง`);
                    }
                    
                    return grids;
                }

                async function processRoadsByGrid(geometry, type = 'boundary') {
                    gridLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    selectedRoads = [];
                    
                    // Show grid process container
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'block';
                    
                    try {
                        // ขนาดกริดสำหรับการแสดงผลและประมวลผล
                        // ใช้กริดที่ใหญ่สำหรับการแสดงผล (เพื่อประสิทธิภาพ) แต่ใช้กริด 500x500 สำหรับการประมวลผลจริง
                        const displayGridSize = roadGeometryType === "polygon" ? 1000 : 500; // กริดใหญ่สำหรับแสดงผล
                        const processingGridSize = 500; // กริดเล็กสำหรับประมวลผลข้อมูล
                        
                        // สร้างกริดสำหรับการแสดงผล (ใหญ่)
                        const displayGrids = createGridCells(geometry.extent, displayGridSize);
                        
                        // สร้างกริดสำหรับประมวลผล (เล็ก)
                        const processingGrids = createGridCells(geometry.extent, processingGridSize);
                        
                        const totalGrids = processingGrids.length;
                        let processedCount = 0;
                        let totalRoads = 0;
                        
                        gridStatus.textContent = `เริ่มประมวลผลกริด`;
                        gridDetails.textContent = `0/${totalGrids} กริด`;
                        progressBarFill.style.width = '0%';
                        
                        // แสดงกริดสำหรับการแสดงผล
                        displayGrids.forEach(grid => {
                            const gridGraphic = new Graphic({
                                geometry: grid,
                                symbol: {
                                    type: "simple-fill",
                                    color: [255, 165, 0, 0.1], // ลดความทึบให้เห็นแผนที่ด้านล่างได้
                                    outline: {
                                        color: [255, 165, 0, 0.5],
                                        width: 0.5
                                    }
                                }
                            });
                            gridLayer.add(gridGraphic);
                        });
                        
                        // ปรับปรุงการประมวลผลแบบ concurrent สำหรับ grid ขนาดเล็ก
                        // เพิ่มจำนวน grids ที่ประมวลผลพร้อมกันเนื่องจากขนาดกริดเล็กลง
                        const maxConcurrentGrids = roadGeometryType === "polygon" ? 10 : 20;
                        
                        // แบ่งกริดเป็นกลุ่มๆ
                        const gridGroups = [];
                        for (let i = 0; i < processingGrids.length; i += maxConcurrentGrids) {
                            gridGroups.push(processingGrids.slice(i, i + maxConcurrentGrids));
                        }
                        
                        // สร้าง Object สำหรับเก็บถนนที่ไม่ซ้ำกัน ใช้ OBJECTID หรือ FID เป็นคีย์
                        const uniqueRoadsObj = {}; // ใช้ Object แทน Map
                        
                        // ประมวลผลทีละกลุ่มกริด
                        for (const [groupIndex, currentGrids] of gridGroups.entries()) {
                            // ประมวลผลกริดพร้อมกันหลายกริด
                            const results = await Promise.all(currentGrids.map(async (grid, localIndex) => {
                                const globalIndex = groupIndex * maxConcurrentGrids + localIndex;
                                
                                try {
                                    // สร้าง query สำหรับดึงข้อมูลถนนในกริด
                                    const query = roadsLayer.createQuery();
                                    query.geometry = grid;
                                    query.spatialRelationship = "intersects";
                                    query.returnGeometry = true;
                                    query.outFields = ["*"];
                                    
                                    // เพิ่มประสิทธิภาพด้วยการกำหนด where เงื่อนไขเพิ่มเติม (ถ้ามี)
                                    if (roadGeometryType === "polygon") {
                                        // อาจเพิ่มเงื่อนไขสำหรับ polygon ที่นี่ถ้าจำเป็น
                                    }
                                    
                                    const result = await roadsLayer.queryFeatures(query);
                                    let validRoads = result.features;
                                    
                                    if (type === 'draw') {
                                        // สำหรับการวาดพื้นที่ กรองเฉพาะถนนที่อยู่ในพื้นที่ที่วาด
                                        validRoads = result.features.filter(road => 
                                            geometryEngine.intersects(road.geometry, geometry)
                                        );
                                    }
                                    
                                    // อัพเดทความคืบหน้า
                                    processedCount = globalIndex + 1;
                                    const progress = (processedCount / totalGrids) * 100;
                                    progressBarFill.style.width = `${progress}%`;
                                    
                                    // อัพเดทข้อความสถานะ
                                    if (processedCount % Math.max(1, Math.floor(totalGrids / 100)) === 0 || 
                                        processedCount === totalGrids) {
                                        gridStatus.textContent = `กำลังประมวลผล...`;
                                        gridDetails.textContent = `${processedCount}/${totalGrids} กริด (พบถนน ${totalRoads + validRoads.length} เส้น)`;
                                    }
                                    
                                    // ไม่ต้องเปลี่ยนสีกริดแสดงผล เพื่อลดการใช้ทรัพยากร
                                    
                                    return validRoads;
                                } catch (error) {
                                    console.error(`Error processing grid ${globalIndex}:`, error);
                                    return [];
                                }
                            }));
                            
                            // รวมผลลัพธ์จากทุกกริดในกลุ่มนี้และกำจัดรายการที่ซ้ำกัน
                            const flatResults = results.flat();
                            
                            // เพิ่มลงใน Object เพื่อกรองรายการที่ซ้ำกัน
                            flatResults.forEach(road => {
                                // ใช้ OBJECTID หรือ FID เป็นคีย์หลักในการระบุความซ้ำซ้อน
                                const id = road.attributes.OBJECTID || road.attributes.FID || 
                                          road.attributes.objectid || road.attributes.fid;
                                if (id) {
                                    uniqueRoadsObj[id] = road;
                                }
                            });
                            
                            // อัพเดทจำนวนถนนทั้งหมด
                            totalRoads = Object.keys(uniqueRoadsObj).length;
                            
                            // อัพเดทความคืบหน้า
                            const progress = ((groupIndex + 1) / gridGroups.length) * 100;
                            progressBarFill.style.width = `${progress}%`;
                            
                            gridStatus.textContent = `กำลังประมวลผล... ${Math.round(progress)}%`;
                            gridDetails.textContent = `${processedCount}/${totalGrids} กริด (พบถนนที่ไม่ซ้ำกัน ${totalRoads} เส้น)`;
                            
                            // ถ้าจำนวนถนนมากเกินไป ให้หยุดการประมวลผลเพื่อป้องกันปัญหาหน่วยความจำ
                            if (totalRoads > 200000) {
                                console.warn(`จำนวนถนนมากเกินไป (${totalRoads}). หยุดการประมวลผลเพื่อป้องกันปัญหาหน่วยความจำ`);
                                gridStatus.textContent = `คำเตือน: จำนวนถนนมากเกินไป`;
                                await new Promise(resolve => setTimeout(resolve, 1000));
                                break;
                            }
                            
                            // ให้ UI ได้มีโอกาส update ก่อนเริ่มประมวลผลชุดถัดไป
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                        // แปลง Object เป็น array เพื่อใช้งานต่อไป
                        selectedRoads = Object.values(uniqueRoadsObj);
                        
                        // แสดงสรุปผลการประมวลผล
                        gridStatus.textContent = "ประมวลผลเสร็จสิ้น";
                        gridDetails.textContent = `พบถนนที่ไม่ซ้ำกันทั้งหมด ${selectedRoads.length.toLocaleString()} เส้น`;
                        
                        previewButton.disabled = false;
                        
                        // แสดงตัวอย่างการส่งออก (อาจปิดใช้งานหากจำนวนถนนมากเกินไป)
                        if (selectedRoads.length <= 100000) {
                            await previewExportRoads();
                        } else {
                            exportButton.disabled = false;
                            loadingMessage.style.display = "block";
                            loadingMessage.textContent = `เนื่องจากมีข้อมูลถนนจำนวนมาก (${selectedRoads.length.toLocaleString()} เส้น) จึงไม่แสดงตัวอย่าง สามารถกดปุ่มส่งออกได้ทันที`;
                            setTimeout(() => {
                                loadingMessage.style.display = "none";
                            }, 5000);
                        }
                        
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                        }, 3000);
                        
                    } catch (error) {
                        console.error("Error in grid processing:", error);
                        gridStatus.textContent = "เกิดข้อผิดพลาดในการประมวลผล";
                        gridDetails.textContent = error.message || "";
                    }
                }

                // Sketch Widget
                const sketch = new Sketch({
                    view: view,
                    layer: selectionLayer,
                    creationMode: "single",
                    availableCreateTools: ["polygon"],
                    visibleElements: {
                        createTools: {
                            point: false,
                            polyline: false,
                            rectangle: false,
                            circle: false
                        },
                        selectionTools: {
                            "lasso-selection": false,
                            "rectangle-selection": false
                        },
                        settingsMenu: false,
                        undoRedoMenu: false
                    }
                });

                const layerList = new LayerList({
                    view: view
                });

                const legend = new Legend({
                    view: view
                });

                view.ui.add(layerList, "top-right");
                view.ui.add(legend, "bottom-right");

                const drawPolygonButton = document.getElementById("drawPolygonButton");
                const clearSelectionButton = document.getElementById("clearSelectionButton");
                let isDrawing = false;

                // ปรับฟังก์ชัน previewExportRoads สำหรับการแสดงผลตามประเภทข้อมูล
                async function previewExportRoads() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังวิเคราะห์ข้อมูล...";
                    previewButton.disabled = true;

                    try {
                        exportPreviewLayer.removeAll();
                        
                        const totalRoads = selectedRoads.length;
                        loadingMessage.textContent = `พบเส้นทาง/พื้นที่ทั้งหมด ${totalRoads.toLocaleString()} รายการ`;

                        // ถ้ามีข้อมูลมากเกินไป ให้แสดงเฉพาะบางส่วน
                        const maxPreviewRoads = roadGeometryType === "polygon" ? 15000 : 30000;
                        
                        if (totalRoads > maxPreviewRoads) {
                            loadingMessage.textContent = `มีข้อมูลจำนวนมาก (${totalRoads.toLocaleString()} รายการ) จะแสดงตัวอย่างเพียงบางส่วน`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }

                        const processVisibleRoads = async () => {
                            const viewExtent = view.extent;
                            
                            // ปรับขนาด batch ให้เหมาะสมกับประเภทข้อมูล
                            const batchSize = roadGeometryType === "polygon" ? 5000 : 10000;
                            
                            // จำกัดจำนวนข้อมูลที่จะแสดงตัวอย่าง
                            const roadsToProcess = totalRoads > maxPreviewRoads ? 
                                selectedRoads.slice(0, maxPreviewRoads) : selectedRoads;
                            
                            const chunks = [];
                            for (let i = 0; i < roadsToProcess.length; i += batchSize) {
                                chunks.push(roadsToProcess.slice(i, i + batchSize));
                            }

                            // ฟังก์ชันสำหรับจัดเตรียมข้อมูลเพื่อแสดงผล
                            const processChunk = async (roads) => {
                                // กรองเฉพาะถนนที่อยู่ในพื้นที่มุมมองปัจจุบัน
                                const visibleRoads = roads.filter(road => 
                                    geometryEngine.intersects(road.geometry, viewExtent)
                                );
                                
                                // ในกรณีที่มีข้อมูลมากเกินไป ให้สุ่มเลือกบางส่วน
                                let processRoads = visibleRoads;
                                if (visibleRoads.length > 5000 && roadGeometryType === "polygon") {
                                    // สุ่มเลือก 5000 รายการ
                                    const shuffled = [...visibleRoads].sort(() => 0.5 - Math.random());
                                    processRoads = shuffled.slice(0, 5000);
                                }
                                
                                return processRoads.map(road => {
                                    let priority = 0;
                                    
                                    if (roadGeometryType === "polygon") {
                                        // คำนวณพื้นที่เพียงครั้งเดียว
                                        const area = geometryEngine.geodesicArea(road.geometry, "square-meters");
                                        priority = area > 0 ? area : 0;
                                    } else {
                                        priority = road.geometry.length || 0;
                                    }
                                    
                                    const width = road.attributes.WIDTH || road.attributes.width || 0;
                                    
                                    return {
                                        road,
                                        priority,
                                        width
                                    };
                                });
                            };

                            // ประมวลผล chunk แบบขนาน
                            const maxConcurrentProcessing = navigator.hardwareConcurrency ? 
                                Math.min(navigator.hardwareConcurrency, 4) : 2;
                            
                            let processedRoads = [];
                            
                            for (let i = 0; i < chunks.length; i += maxConcurrentProcessing) {
                                const currentChunks = chunks.slice(i, i + maxConcurrentProcessing);
                                const results = await Promise.all(
                                    currentChunks.map(async (chunk, index) => {
                                        const result = await processChunk(chunk);
                                        const progress = Math.round(((i + index + 1) / chunks.length) * 100);
                                        loadingMessage.textContent = `กำลังวิเคราะห์ข้อมูล... ${progress}%`;
                                        return result;
                                    })
                                );
                                processedRoads = processedRoads.concat(results.flat());
                                
                                // ถ้ามีข้อมูลมากเกินไป ให้หยุดการประมวลผล
                                if (processedRoads.length > 20000) {
                                    break;
                                }
                            }

                            // เรียงลำดับความสำคัญ
                            processedRoads.sort((a, b) => {
                                if (roadGeometryType === "polygon") {
                                    return b.priority - a.priority;
                                } else {
                                    const aPriority = (a.priority * 0.7) + (a.width * 0.3);
                                    const bPriority = (b.priority * 0.7) + (b.width * 0.3);
                                    return bPriority - aPriority;
                                }
                            });

                            // กำหนดจำนวนสูงสุดของแต่ละระดับความสำคัญ
                            const maxHighPriority = roadGeometryType === "polygon" ? 3000 : 10000;
                            const maxMediumPriority = roadGeometryType === "polygon" ? 5000 : 15000;
                            
                            const highPriority = processedRoads.slice(0, maxHighPriority);
                            const mediumPriority = processedRoads.slice(maxHighPriority, maxHighPriority + maxMediumPriority);
                            const lowPriority = processedRoads.slice(maxHighPriority + maxMediumPriority);

                            // ฟังก์ชันสร้างกราฟิกแบบแบทช์
                            const createGraphicsBatch = async (roads, symbolWidth, delay = 0) => {
                                const graphicsBatchSize = roadGeometryType === "polygon" ? 500 : 1000;
                                let graphics = [];

                                for (let i = 0; i < roads.length; i += graphicsBatchSize) {
                                    const batch = roads.slice(i, i + graphicsBatchSize);
                                    
                                    const batchGraphics = batch.map(item => {
                                        let symbol;
                                        
                                        if (roadGeometryType === "polygon") {
                                            symbol = {
                                                type: "simple-fill",
                                                color: [255, 0, 0, 0.2], // ลดความทึบให้เห็นชัดขึ้น
                                                outline: {
                                                    color: [255, 0, 0],
                                                    width: symbolWidth
                                                }
                                            };
                                        } else {
                                            symbol = {
                                                type: "simple-line",
                                                color: [255, 0, 0],
                                                width: symbolWidth
                                            };
                                        }
                                        
                                        return new Graphic({
                                            geometry: item.road.geometry,
                                            attributes: item.road.attributes,
                                            symbol: symbol
                                        });
                                    });

                                    graphics = graphics.concat(batchGraphics);
                                    
                                    if (graphics.length >= (roadGeometryType === "polygon" ? 2500 : 5000) || 
                                        i + graphicsBatchSize >= roads.length) {
                                        exportPreviewLayer.addMany(graphics);
                                        graphics = [];
                                        
                                        if (delay > 0) {
                                            const adjustedDelay = roadGeometryType === "polygon" ? 
                                                Math.max(1, delay / 3) : delay;
                                            await new Promise(resolve => setTimeout(resolve, adjustedDelay));
                                        }
                                    }
                                }
                            };

                            const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                            
                            // แสดงข้อมูลหลัก (ความสำคัญสูง)
                            loadingMessage.textContent = `กำลังแสดง${itemTypeName}หลัก...`;
                            await createGraphicsBatch(highPriority, 
                                roadGeometryType === "polygon" ? "1px" : "2px", 
                                roadGeometryType === "polygon" ? 0 : 1);
                            
                            // แสดงข้อมูลรอง (ความสำคัญปานกลาง)
                            if (mediumPriority.length > 0) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}รอง...`;
                                await createGraphicsBatch(mediumPriority, 
                                    roadGeometryType === "polygon" ? "0.5px" : "1px", 
                                    roadGeometryType === "polygon" ? 0 : 1);
                            }
                            
                            // แสดงข้อมูลย่อย (ความสำคัญต่ำ) เฉพาะเมื่อไม่มีข้อมูลมากเกินไป
                            if (lowPriority.length > 0 && 
                                (roadGeometryType !== "polygon" || lowPriority.length < 1000)) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}ย่อย...`;
                                await createGraphicsBatch(lowPriority, 
                                    roadGeometryType === "polygon" ? "0.3px" : "0.5px", 
                                    roadGeometryType === "polygon" ? 0 : 1);
                            }
                        };

                        // ใช้ debounce เพื่อลดการเรียกซ้ำบ่อยๆ
                        let updateTimeout;
                        const debouncedUpdate = () => {
                            clearTimeout(updateTimeout);
                            const debounceTime = roadGeometryType === "polygon" ? 1500 : 1000;
                            updateTimeout = setTimeout(async () => {
                                exportPreviewLayer.removeAll();
                                await processVisibleRoads();
                            }, debounceTime);
                        };

                        // ประมวลผลข้อมูลที่อยู่ในมุมมองปัจจุบัน
                        await processVisibleRoads();
                        
                        // ติดตามการเปลี่ยนแปลงขอบเขตและการหมุนแผนที่
                        view.watch("extent", debouncedUpdate);
                        view.watch("rotation", debouncedUpdate);

                        // แสดงเลเยอร์ผลลัพธ์และเปิดใช้งานปุ่มส่งออก
                        exportPreviewLayer.visible = true;
                        exportButton.disabled = false;

                        // แสดงข้อความสรุป
                        const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                        loadingMessage.textContent = `พร้อมส่งออกข้อมูล${itemTypeName} ${totalRoads.toLocaleString()} รายการ`;
                        
                        // ซ่อนข้อความสถานะหลังจากเวลาผ่านไป
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);

                    } catch (error) {
                        console.error("Error previewing roads:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการสร้างตัวอย่าง";
                    } finally {
                        previewButton.disabled = false;
                    }
                }

                // ปรับปรุงฟังก์ชัน exportRoadsToGeoJSON ให้มีประสิทธิภาพและโหลดข้อมูลครบถ้วน
                async function exportRoadsToGeoJSON() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังเตรียมข้อมูลเพื่อส่งออก...";

                    try {
                        const name = document.getElementById("boundarySelect").value || "selected_area";
                        
                        const utmSR = new SpatialReference({
                            wkid: 32647
                        });

                        // แสดงความคืบหน้า
                        const progressBar = document.querySelector(".progress-bar-fill");
                        const gridProcessContainer = document.getElementById('gridProcessContainer');
                        const gridStatus = document.getElementById("gridStatus");
                        const gridDetails = document.getElementById("gridDetails");
                        
                        gridProcessContainer.style.display = 'block';
                        gridStatus.textContent = "กำลังเตรียมข้อมูลเพื่อส่งออก...";
                        gridDetails.textContent = `0/${selectedRoads.length} รายการ`;
                        progressBar.style.width = '0%';
                        
                        // เพิ่มรายละเอียดลงใน GeoJSON
                        const geojson = {
                            type: "FeatureCollection",
                            name: `roads_${name}`,
                            crs: {
                                type: "name",
                                properties: {
                                    name: "EPSG:32647"
                                }
                            },
                            metadata: {
                                exportDate: new Date().toISOString(),
                                totalFeatures: selectedRoads.length,
                                geometryType: roadGeometryType,
                                gridSize: "500x500m",
                                source: "Department of Public Works and Town & Country Planning"
                            },
                            features: []
                        };

                        // ปรับขนาด batch ให้เล็กลงเพื่อป้องกันปัญหาหน่วยความจำเต็ม
                        const batchSize = roadGeometryType === "polygon" ? 200 : 500;
                        const totalBatches = Math.ceil(selectedRoads.length / batchSize);
                        
                        // แสดงการประมาณการเวลาทั้งหมด
                        const startTime = Date.now();
                        let lastProcessed = 0;
                        let estimatedTotalTime = 0;
                        
                        // ประมวลผลทีละ batch
                        for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                            const start = batchIndex * batchSize;
                            const end = Math.min(start + batchSize, selectedRoads.length);
                            const currentBatch = selectedRoads.slice(start, end);
                            
                            // ประมวลผลแต่ละรายการใน batch
                            const batchFeatures = await Promise.all(currentBatch.map(async (feature) => {
                                try {
                                    const utmGeometry = projection.project(
                                        feature.geometry,
                                        utmSR
                                    );
                                    
                                    let geometryObject;
                                    let lengthField = 0;
                                    let areaField = null;
                                    
                                    if (roadGeometryType === "polygon") {
                                        geometryObject = {
                                            type: "Polygon",
                                            coordinates: utmGeometry.rings
                                        };
                                        
                                        // คำนวณพื้นที่
                                        if (feature.geometry.rings) {
                                            areaField = geometryEngine.geodesicArea(feature.geometry, "square-meters");
                                            lengthField = areaField; // ใช้พื้นที่เป็นความยาว (สำหรับ polygon)
                                        }
                                    } else {
                                        geometryObject = {
                                            type: "LineString",
                                            coordinates: utmGeometry.paths ? utmGeometry.paths[0] : []
                                        };
                                        
                                        // คำนวณความยาว
                                        lengthField = feature.geometry.length || 0;
                                    }
                                    
                                    // กำหนดคุณสมบัติเพิ่มเติม
                                    const properties = {
                                        ...feature.attributes,
                                        length_m: lengthField,
                                        area_sqm: areaField,
                                        road_id: feature.attributes.OBJECTID || feature.attributes.FID || null,
                                        geometry_type: roadGeometryType,
                                        style: {
                                            color: "#FF0000",
                                            weight: 2,
                                            opacity: roadGeometryType === "polygon" ? 0.5 : 1
                                        }
                                    };
                                    
                                    // สร้าง Feature object
                                    return {
                                        type: "Feature",
                                        geometry: geometryObject,
                                        properties: properties
                                    };
                                } catch (error) {
                                    console.error("Error processing feature:", error);
                                    return null;
                                }
                            }));
                            
                            // กรองข้อมูลที่เป็น null ออก
                            const validFeatures = batchFeatures.filter(feature => feature !== null);
                            
                            // เพิ่มข้อมูลลงใน GeoJSON
                            geojson.features = geojson.features.concat(validFeatures);
                            
                            // คำนวณเวลาที่ใช้และประมาณการเวลาที่เหลือ
                            const currentTime = Date.now();
                            const elapsedTime = (currentTime - startTime) / 1000; // เวลาที่ผ่านไปเป็นวินาที
                            const processedItems = end;
                            
                            if (batchIndex > 0) {
                                const itemsPerSecond = processedItems / elapsedTime;
                                const remainingItems = selectedRoads.length - processedItems;
                                const estimatedRemainingTime = remainingItems / itemsPerSecond;
                                estimatedTotalTime = elapsedTime + estimatedRemainingTime;
                                
                                // แสดงเวลาในรูปแบบที่อ่านง่าย
                                const formatTime = (seconds) => {
                                    if (seconds < 60) return `${Math.round(seconds)} วินาที`;
                                    if (seconds < 3600) return `${Math.floor(seconds / 60)} นาที ${Math.round(seconds % 60)} วินาที`;
                                    return `${Math.floor(seconds / 3600)} ชั่วโมง ${Math.floor((seconds % 3600) / 60)} นาที`;
                                };
                                
                                const timeInfo = `ประมาณอีก ${formatTime(estimatedRemainingTime)} (ทั้งหมด ${formatTime(estimatedTotalTime)})`;
                                gridDetails.textContent = `${processedItems}/${selectedRoads.length} รายการ - ${timeInfo}`;
                            }
                            
                            // อัพเดทความคืบหน้า
                            const progress = ((batchIndex + 1) / totalBatches) * 100;
                            progressBar.style.width = `${progress}%`;
                            gridStatus.textContent = `กำลังส่งออกข้อมูล... ${Math.round(progress)}%`;
                            
                            // เพิ่มการหน่วงเวลาเล็กน้อยเพื่อให้ UI อัพเดท
                            await new Promise(resolve => setTimeout(resolve, 5));
                            
                            // ในกรณีที่ข้อมูลมีขนาดใหญ่มาก ให้ทำการบันทึกเป็นไฟล์ทุกๆ 50,000 รายการ
                            if (geojson.features.length >= 50000 && (batchIndex < totalBatches - 1)) {
                                // สร้างไฟล์ชั่วคราว
                                const partFileName = `roads_${name}_part${Math.ceil((batchIndex + 1) / (50000 / batchSize))}_utm47n`;
                                const partGeojson = {
                                    ...geojson,
                                    name: partFileName,
                                    metadata: {
                                        ...geojson.metadata,
                                        partNumber: Math.ceil((batchIndex + 1) / (50000 / batchSize)),
                                        totalParts: Math.ceil(selectedRoads.length / 50000),
                                        features: geojson.features.length
                                    }
                                };
                                
                                // สร้างและบันทึกไฟล์ส่วนย่อย
                                const partBlob = new Blob([JSON.stringify(partGeojson, null, 2)], { 
                                    type: "application/json" 
                                });
                                const partUrl = URL.createObjectURL(partBlob);
                                const partLink = document.createElement("a");
                                partLink.href = partUrl;
                                partLink.download = `${partFileName}_${new Date().getTime()}.geojson`;
                                document.body.appendChild(partLink);
                                partLink.click();
                                document.body.removeChild(partLink);
                                URL.revokeObjectURL(partUrl);
                                
                                // ล้างข้อมูลที่ส่งออกไปแล้วเพื่อประหยัดหน่วยความจำ
                                geojson.features = [];
                                
                                // แสดงข้อความแจ้งเตือน
                                gridStatus.textContent = `บันทึกส่วนที่ ${Math.ceil((batchIndex + 1) / (50000 / batchSize))} จาก ${Math.ceil(selectedRoads.length / 50000)} ส่วน`;
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }

                        // รวมจำนวนไฟล์ทั้งหมดที่ส่งออก
                        const totalParts = Math.ceil(selectedRoads.length / 50000);
                        
                        // ถ้ามีข้อมูลที่ยังไม่ได้ส่งออก หรือเป็นกรณีที่ข้อมูลไม่เกิน 50,000 รายการ
                        if (geojson.features.length > 0 || totalParts === 0) {
                            gridStatus.textContent = "กำลังบันทึกไฟล์...";
                            
                            // สร้างชื่อไฟล์
                            let fileName = `roads_${name}_utm47n_${new Date().getTime()}`;
                            if (totalParts > 1) {
                                fileName = `roads_${name}_part${totalParts}_utm47n_${new Date().getTime()}`;
                                
                                // อัพเดทข้อมูล metadata
                                geojson.metadata.partNumber = totalParts;
                                geojson.metadata.totalParts = totalParts;
                                geojson.metadata.features = geojson.features.length;
                            }
                            
                            // สร้างและบันทึกไฟล์
                            const blob = new Blob([JSON.stringify(geojson, null, 2)], { 
                                type: "application/json" 
                            });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement("a");
                            a.href = url;
                            a.download = `${fileName}.geojson`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }

                        // แสดงสรุปผลการส่งออก
                        const endTime = Date.now();
                        const totalTime = ((endTime - startTime) / 1000).toFixed(1);
                        
                        gridStatus.textContent = "ส่งออกข้อมูลเสร็จสิ้น";
                        
                        if (totalParts > 1) {
                            gridDetails.textContent = `ส่งออกทั้งหมด ${selectedRoads.length} รายการ แบ่งเป็น ${totalParts} ไฟล์ (${totalTime} วินาที)`;
                        } else {
                            gridDetails.textContent = `ส่งออกทั้งหมด ${selectedRoads.length} รายการ (${totalTime} วินาที)`;
                        }
                        
                        // ซ่อนการแสดงสถานะหลังจากเวลาผ่านไป
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                            loadingMessage.style.display = "none";
                        }, 5000);
                    } catch (error) {
                        console.error("Error exporting data:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการส่งออกข้อมูล";
                        
                        // แสดงข้อผิดพลาดในกรณีเกิดปัญหา
                        gridStatus.textContent = "เกิดข้อผิดพลาด";
                        gridDetails.textContent = error.message || "ไม่สามารถส่งออกข้อมูลได้";
                        
                        // แสดงข้อความแนะนำเพิ่มเติม
                        setTimeout(() => {
                            gridDetails.textContent += " - ลองลดขนาดพื้นที่เลือกและลองอีกครั้ง";
                        }, 2000);
                    }
                }

                function toggleDrawingMode() {
                    isDrawing = !isDrawing;
                    drawPolygonButton.classList.toggle("active");
                    if (isDrawing) {
                        sketch.create("polygon");
                    } else {
                        sketch.cancel();
                    }
                }

                function clearSelection() {
                    selectionLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    gridLayer.removeAll();
                    selectedRoads = null;
                    exportButton.disabled = true;
                    previewButton.disabled = true;
                    gridProcessButton.style.display = 'none';
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                }

                // Event Handlers
                drawPolygonButton.addEventListener("click", toggleDrawingMode);
                clearSelectionButton.addEventListener("click", clearSelection);

                sketch.on("create", async (event) => {
                    if (event.state === "complete") {
                        const polygon = event.graphic.geometry;
                        await processRoadsByGrid(polygon, 'draw');
                        isDrawing = false;
                        drawPolygonButton.classList.remove("active");
                    }
                });

                function updateSelectOptions(boundaries) {
                    const select = document.getElementById("boundarySelect");
                    select.innerHTML = '<option value="">เลือกขอบเขตผัง</option>';
                    
                    boundaries.forEach(name => {
                        const option = document.createElement("option");
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });
                }

                function loadBoundaries() {
                    const query = new Query({
                        where: "1=1",
                        outFields: ["NAME"],
                        returnDistinctValues: true,
                        returnGeometry: false
                    });

                    boundariesLayer.queryFeatures(query)
                        .then(function(results) {
                            const select = document.getElementById("boundarySelect");
                            const boundaries = results.features
                                .map(feature => feature.attributes.NAME)
                                .filter(name => name)
                                .sort();
                            
                            select.dataset.allBoundaries = JSON.stringify(boundaries);
                            updateSelectOptions(boundaries);
                            loadingMessage.style.display = "none";
                        })
                        .catch(function(error) {
                            console.error("Error loading boundaries:", error);
                            loadingMessage.textContent = "เกิดข้อผิดพลาดในการโหลดข้อมูล";
                        });
                }

                function filterBoundaries() {
                    const input = document.getElementById("searchInput");
                    const select = document.getElementById("boundarySelect");
                    const searchTerm = input.value.toLowerCase();
                    
                    const allBoundaries = JSON.parse(select.dataset.allBoundaries || '[]');
                    const filteredBoundaries = allBoundaries.filter(name => 
                        name.toLowerCase().includes(searchTerm)
                    );
                    
                    updateSelectOptions(filteredBoundaries);
                }

                async function handleBoundarySelect(name) {
                    exportPreviewLayer.removeAll();
                    selectionLayer.removeAll();
                    gridLayer.removeAll();
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                    
                    if (!name) {
                        exportButton.disabled = true;
                        previewButton.disabled = true;
                        roadsLayer.definitionExpression = "1=1";
                        boundariesLayer.definitionExpression = "1=1";
                        return;
                    }

                    exportButton.disabled = true;
                    previewButton.disabled = false;
                    boundariesLayer.definitionExpression = `NAME = '${name}'`;

                    const query = boundariesLayer.createQuery();
                    query.where = `NAME = '${name}'`;
                    query.returnGeometry = true;
                    
                    try {
                        const results = await boundariesLayer.queryFeatures(query);
                        if (results.features.length > 0) {
                            currentBoundaryGeometry = results.features[0].geometry;
                            view.goTo(currentBoundaryGeometry.extent.expand(1.2));
                            await processRoadsByGrid(currentBoundaryGeometry, 'boundary');
                        }
                    } catch (error) {
                        console.error("Error querying features:", error);
                    }
                }

                // Event listeners
                document.getElementById("searchInput").addEventListener("input", filterBoundaries);
                document.getElementById("boundarySelect").addEventListener("change", function(e) {
                    handleBoundarySelect(e.target.value);
                });
                document.getElementById("previewButton").addEventListener("click", previewExportRoads);
                document.getElementById("exportButton").addEventListener("click", exportRoadsToGeoJSON);
                
                // Initialize
                view.when(() => {
                    loadBoundaries();
                    view.ui.add(sketch, {
                        position: "manual"
                    });
                    
                    // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อแผนที่โหลดเสร็จ
                    checkRoadLayerGeometryType();
                });
                
                // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อมีการเปลี่ยนแปลงเลเยอร์
                roadsLayer.when(() => {
                    checkRoadLayerGeometryType();
                });
            }
        });
    </script>
</body>
</html>