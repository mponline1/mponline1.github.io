<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>แผนที่ขอบเขตผังและถนน</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <style>
        html, body, #mapDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        /* Search Container */
        #searchContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 300px;
        }

        /* Grid Process Container */
        #gridProcessContainer {
            position: absolute;
            top: 20px;
            left: 340px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 280px;
            display: none;
        }

        .status-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        /* Draw Tools */
        #drawTools {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 180px;
        }

        /* Widgets */
        .esri-layer-list {
            position: absolute;
            top: 20px;
            right: 220px;
            max-height: calc(100vh - 240px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            max-height: 200px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-sketch {
            position: absolute;
            top: 100px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Form Elements */
        .search-input, .search-select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .search-input:focus, .search-select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        /* Buttons */
        .button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #previewButton {
            background-color: #2196F3;
            color: white;
        }

        #previewButton:hover {
            background-color: #1976D2;
        }

        #exportButton {
            background-color: #4CAF50;
            color: white;
        }

        #exportButton:hover {
            background-color: #45a049;
        }

        #gridProcessButton {
            background-color: #FF5722;
            color: white;
        }

        #gridProcessButton:hover {
            background-color: #E64A19;
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Tool Buttons */
        .tool-button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
        }

        .tool-button.active {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .tool-button:hover {
            background-color: #f0f0f0;
        }

        .tool-button.active:hover {
            background-color: #1976D2;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Status Messages */
        #loadingMessage, #gridStatus {
            color: #666;
            margin-top: 5px;
            font-size: 0.9em;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: none;
        }

        /* Processing Stats Box */
        #processingStats {
            margin: 10px 0;
            padding: 8px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: none;
            border-left: 3px solid #FF5722;
        }

        /* Layer Type Info */
        #layerTypeInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 2;
            min-width: 200px;
        }

        .type-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .type-polygon {
            background-color: #4CAF50;
        }

        .type-polyline {
            background-color: #2196F3;
        }

        .type-unknown {
            background-color: #FF5722;
        }

        /* Advanced settings panel */
        #advancedSettingsPanel {
            display: none;
            margin-top: 10px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #2196F3;
        }

        .settings-heading {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #1976D2;
        }

        .settings-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .settings-row label {
            flex: 2;
        }

        .settings-row input {
            flex: 1;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        #toggleAdvancedSettings {
            font-size: 12px;
            color: #2196F3;
            background: none;
            border: none;
            text-decoration: underline;
            cursor: pointer;
            margin-top: 5px;
            padding: 0;
        }

        /* Responsive Adjustments */
        @media screen and (max-height: 800px) {
            .esri-layer-list {
                max-height: calc(100vh - 400px);
            }
            .esri-legend {
                max-height: 150px;
            }
        }
    </style>
</head>
<body>
    <div id="searchContainer">
        <input type="text" id="searchInput" class="search-input" placeholder="ค้นหาขอบเขตผัง...">
        <select id="boundarySelect" class="search-select">
            <option value="">เลือกขอบเขตผัง</option>
        </select>
        <button id="previewButton" class="button" disabled>แสดงตัวอย่างถนนที่จะส่งออก</button>
        <button id="gridProcessButton" class="button">ประมวลผลซ้ำเพื่อดึงข้อมูลเพิ่มเติม</button>
        <button id="exportButton" class="button" disabled>ส่งออก GeoJSON</button>
        <div id="loadingMessage">กำลังโหลดข้อมูล...</div>
        <div id="processingStats">
            <div style="font-weight: bold; margin-bottom: 5px;">สถิติการประมวลผล</div>
            <div id="processCount">จำนวนครั้งที่ประมวลผล: 1</div>
            <div id="totalFeaturesCount">จำนวนข้อมูลทั้งหมด: 0</div>
            <div id="newFeaturesCount">จำนวนข้อมูลใหม่: 0</div>
        </div>
        <button id="toggleAdvancedSettings">แสดงการตั้งค่าขั้นสูง</button>
        <div id="advancedSettingsPanel">
            <div class="settings-heading">การตั้งค่าขั้นสูง</div>
            <div class="settings-row">
                <label for="gridSizeInput">ขนาดกริด (เมตร):</label>
                <input type="number" id="gridSizeInput" value="300" min="100" max="1000">
            </div>
            <div class="settings-row">
                <label for="maxFeaturesInput">จำนวนข้อมูลสูงสุด:</label>
                <input type="number" id="maxFeaturesInput" value="500000" min="10000" max="1000000">
            </div>
            <div class="settings-row">
                <label for="concurrentGridsInput">จำนวนกริดที่ประมวลผลพร้อมกัน:</label>
                <input type="number" id="concurrentGridsInput" value="15" min="5" max="30">
            </div>
        </div>
    </div>

    <div id="gridProcessContainer">
        <h3 style="margin: 0 0 10px 0; font-size: 14px;">การประมวลผลด้วยกริด</h3>
        <div id="gridStatus" class="status-text"></div>
        <div class="progress-bar">
            <div class="progress-bar-fill"></div>
        </div>
        <div id="gridDetails" class="status-text"></div>
    </div>

    <div id="drawTools">
        <button id="drawPolygonButton" class="tool-button">วาดพื้นที่เลือก</button>
        <button id="clearSelectionButton" class="tool-button">ล้างการเลือก</button>
    </div>

    <div id="mapDiv"></div>

    <script src="https://js.arcgis.com/4.28/"></script>
    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/layers/GraphicsLayer",
            "esri/geometry/geometryEngine",
            "esri/rest/support/Query",
            "esri/geometry/Polygon",
            "esri/widgets/LayerList",
            "esri/widgets/Legend",
            "esri/widgets/Sketch",
            "esri/Graphic",
            "esri/geometry/support/webMercatorUtils",
            "esri/geometry/SpatialReference",
            "esri/geometry/projection"
        ], function(
            Map, MapView, FeatureLayer, GraphicsLayer, geometryEngine, 
            Query, Polygon, LayerList, Legend, Sketch, Graphic, 
            webMercatorUtils, SpatialReference, projection
        ) {
            // Load the projection engine
            projection.load().then(() => {
                initializeApp();
            });

            function initializeApp() {
                const loadingMessage = document.getElementById("loadingMessage");
                const gridStatus = document.getElementById("gridStatus");
                const gridDetails = document.getElementById("gridDetails");
                const exportButton = document.getElementById("exportButton");
                const previewButton = document.getElementById("previewButton");
                const gridProcessButton = document.getElementById("gridProcessButton");
                const toggleAdvSettingsBtn = document.getElementById("toggleAdvancedSettings");
                const advancedSettingsPanel = document.getElementById("advancedSettingsPanel");
                const progressBar = document.querySelector(".progress-bar");
                const progressBarFill = document.querySelector(".progress-bar-fill");
                
                let selectedRoads = null;
                let currentBoundaryGeometry = null;
                // ตัวแปรเก็บประเภทของ geometry
                let roadGeometryType = "polyline"; // ค่าเริ่มต้นเป็น polyline
                
                // ตัวแปรสำหรับติดตามการประมวลผลซ้ำ
                let processCount = 0; // จำนวนครั้งที่ประมวลผล
                let processedIds = {}; // เก็บ ID ที่เคยประมวลผลแล้ว
                let previousSelectionCount = 0; // จำนวนข้อมูลก่อนการประมวลผลล่าสุด
                
                // ตัวแปรเก็บผลลัพธ์จากการสร้างกริด
                let processingGridResult = null;

                // แสดง/ซ่อนพาแนลการตั้งค่าขั้นสูง
                toggleAdvSettingsBtn.addEventListener("click", function() {
                    if (advancedSettingsPanel.style.display === "none" || !advancedSettingsPanel.style.display) {
                        advancedSettingsPanel.style.display = "block";
                        toggleAdvSettingsBtn.textContent = "ซ่อนการตั้งค่าขั้นสูง";
                    } else {
                        advancedSettingsPanel.style.display = "none";
                        toggleAdvSettingsBtn.textContent = "แสดงการตั้งค่าขั้นสูง";
                    }
                });

                const map = new Map({
                    basemap: "streets"
                });

                const view = new MapView({
                    container: "mapDiv",
                    map: map,
                    center: [100.5234, 13.7563],
                    zoom: 6
                });

                // Layers
                const selectionLayer = new GraphicsLayer({
                    title: "พื้นที่ที่เลือก"
                });

                const gridLayer = new GraphicsLayer({
                    title: "กริดการประมวลผล"
                });

                const roadsLayer = new FeatureLayer({
                    url: "https://tcpebps.dpt.go.th/arcgis/rest/services/service/BLGD/MapServer/0",
                    outFields: ["*"],
                    title: "ถนน",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-line",
                            color: [0, 0, 0],
                            width: "1.5px"
                        }
                    }
                });

                const exportPreviewLayer = new GraphicsLayer({
                    title: "ถนนที่จะส่งออก",
                    visible: false
                });

                const boundariesLayer = new FeatureLayer({
                    url: "https://dptgis.dpt.go.th/arcgis/rest/services/Compbnd/MapServer/0",
                    outFields: ["*"],
                    title: "ขอบเขตผัง",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-fill",
                            color: [0, 0, 0, 0],
                            outline: {
                                color: [255, 0, 0],
                                width: 2
                            }
                        }
                    }
                });

                map.addMany([roadsLayer, exportPreviewLayer, boundariesLayer, selectionLayer, gridLayer]);

                // เพิ่มฟังก์ชันตรวจสอบประเภทของชั้นข้อมูลถนน
                function checkRoadLayerGeometryType() {
                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังตรวจสอบประเภทชั้นข้อมูลถนน...";
                    
                    roadsLayer.queryFeatures({
                        where: "1=1",
                        returnGeometry: true,
                        outFields: ["*"],
                        num: 1
                    }).then(function(result) {
                        if (result.features.length > 0) {
                            const geometry = result.features[0].geometry;
                            
                            if (geometry.type === "polygon") {
                                roadGeometryType = "polygon";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Polygon";
                            } else if (geometry.type === "polyline") {
                                roadGeometryType = "polyline";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Line";
                            } else {
                                roadGeometryType = "unknown";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: " + geometry.type;
                            }
                            
                            // แสดงข้อความแจ้งเตือนผู้ใช้
                            const geometryInfoDiv = document.createElement("div");
                            geometryInfoDiv.id = "geometryInfoDiv";
                            geometryInfoDiv.style.position = "absolute";
                            geometryInfoDiv.style.bottom = "20px";
                            geometryInfoDiv.style.left = "20px";
                            geometryInfoDiv.style.backgroundColor = "#f8f9fa";
                            geometryInfoDiv.style.border = "1px solid #ddd";
                            geometryInfoDiv.style.borderRadius = "8px";
                            geometryInfoDiv.style.padding = "10px";
                            geometryInfoDiv.style.zIndex = "10";
                            geometryInfoDiv.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
                            geometryInfoDiv.style.maxWidth = "300px";
                            
                            if (roadGeometryType === "polygon") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Polygon</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะรักษารูปแบบ Polygon และโครงสร้างข้อมูลต้นฉบับ</p>
                                `;
                            } else if (roadGeometryType === "polyline") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Line</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะอยู่ในรูปแบบ LineString</p>
                                `;
                            } else {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #FF5722;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: <strong>${geometry.type}</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">อาจเกิดข้อผิดพลาดในการส่งออกข้อมูล</p>
                                `;
                            }
                            
                            // ลบข้อความเดิมถ้ามี
                            const existingInfo = document.getElementById("geometryInfoDiv");
                            if (existingInfo) {
                                existingInfo.remove();
                            }
                            
                            document.body.appendChild(geometryInfoDiv);
                            
                            // ปรับค่าเริ่มต้นสำหรับการตั้งค่าขั้นสูงตามประเภทข้อมูล
                            if (roadGeometryType === "polygon") {
                                document.getElementById("gridSizeInput").value = "400";
                                document.getElementById("concurrentGridsInput").value = "8";
                            } else {
                                document.getElementById("gridSizeInput").value = "300";
                                document.getElementById("concurrentGridsInput").value = "15";
                            }
                        }
                        
                        loadingMessage.style.display = "none";
                    }).catch(function(error) {
                        console.error("Error checking road layer geometry type:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการตรวจสอบประเภทชั้นข้อมูล";
                        roadGeometryType = "unknown";
                        loadingMessage.style.display = "none";
                    });
                }

                // Grid Processing Functions
                function createGridCells(extent, gridSize = 300) {  // ลดขนาดกริดเริ่มต้นเป็น 300 เมตร 
                    const grids = [];
                    
                    // Convert extent to UTM Zone 47N for accurate measurements
                    const utmExtent = projection.project(extent, new SpatialReference({ wkid: 32647 }));
                    
                    const xmin = Math.floor(utmExtent.xmin / gridSize) * gridSize;
                    const ymin = Math.floor(utmExtent.ymin / gridSize) * gridSize;
                    const xmax = Math.ceil(utmExtent.xmax / gridSize) * gridSize;
                    const ymax = Math.ceil(utmExtent.ymax / gridSize) * gridSize;
                    
                    // คำนวณจำนวนกริดก่อนเพื่อแจ้งเตือนผู้ใช้หากมีจำนวนมากเกินไป
                    const gridCountX = Math.ceil((xmax - xmin) / gridSize);
                    const gridCountY = Math.ceil((ymax - ymin) / gridSize);
                    const totalGrids = gridCountX * gridCountY;
                    
                    // เพิ่มการดำเนินการเพื่อลดจำนวนกริดในกรณีที่มากเกินไป
                    let adjustedGridSize = gridSize;
                    if (totalGrids > 10000) {
                        // ใช้กริดที่ใหญ่ขึ้นเพื่อลดจำนวนกริด
                        adjustedGridSize = Math.ceil(gridSize * Math.sqrt(totalGrids / 5000));
                        console.warn(`จำนวนกริดมากเกินไป (${totalGrids}). ปรับขนาดกริดเป็น ${adjustedGridSize} เมตร`);
                    }
                    
                    // สร้างกริดตามขนาดที่กำหนดหรือปรับแล้ว
                    for (let x = xmin; x < xmax; x += adjustedGridSize) {
                        for (let y = ymin; y < ymax; y += adjustedGridSize) {
                            const gridPolygon = new Polygon({
                                rings: [[[x, y], [x + adjustedGridSize, y], [x + adjustedGridSize, y + adjustedGridSize], [x, y + adjustedGridSize], [x, y]]],
                                spatialReference: { wkid: 32647 }
                            });
                            
                            // Project back to web mercator for display
                            const displayPolygon = projection.project(gridPolygon, view.spatialReference);
                            grids.push(displayPolygon);
                        }
                    }
                    
                    return {
                        grids: grids,
                        originalGridSize: gridSize,
                        adjustedGridSize: adjustedGridSize,
                        totalGrids: grids.length
                    };
                }

                // เพิ่มฟังก์ชันใหม่สำหรับวิเคราะห์ผลลัพธ์การประมวลผลและให้คำแนะนำแก่ผู้ใช้
                function analyzeProcessingResult(newRoads, previousCount, totalGrids, failedGrids) {
                    // ลบคำแนะนำเก่าออกก่อน (ถ้ามี)
                    const oldAdvice = document.getElementById("processingAdvice");
                    if (oldAdvice) {
                        oldAdvice.parentNode.removeChild(oldAdvice);
                    }
                    
                    // สร้าง element สำหรับแสดงคำแนะนำ
                    const adviceElement = document.createElement("div");
                    adviceElement.id = "processingAdvice";
                    adviceElement.style.marginTop = "10px";
                    adviceElement.style.padding = "10px";
                    adviceElement.style.borderRadius = "4px";
                    adviceElement.style.fontSize = "0.9em";
                    
                    // กรณีที่ 1: มีข้อมูลใหม่จำนวนมาก - ควรประมวลผลต่อ
                    if (newRoads > 5000 && processCount > 1) {
                        adviceElement.style.backgroundColor = "#E8F5E9";
                        adviceElement.style.borderLeft = "3px solid #4CAF50";
                        adviceElement.innerHTML = `
                            <div style="font-weight: bold; color: #2E7D32; margin-bottom: 5px;">✓ พบข้อมูลเพิ่มเติมจำนวนมาก</div>
                            <div>พบข้อมูลเพิ่มขึ้น ${newRoads.toLocaleString()} รายการ ควรกดปุ่ม "ประมวลผลซ้ำเพื่อดึงข้อมูลเพิ่มเติม" อีกครั้งเพื่อให้ได้ข้อมูลที่ครบถ้วน</div>
                        `;
                    }
                    // กรณีที่ 2: มีข้อมูลใหม่น้อยมาก แต่ยังมีกริดที่ล้มเหลวจำนวนมาก - แนะนำให้ประมวลผลซ้ำ
                    else if (newRoads < 100 && failedGrids > totalGrids * 0.05 && processCount > 1) {
                        adviceElement.style.backgroundColor = "#FFF8E1";
                        adviceElement.style.borderLeft = "3px solid #FFC107";
                        adviceElement.innerHTML = `
                            <div style="font-weight: bold; color: #FF8F00; margin-bottom: 5px;">⚠️ พบปัญหาในการดึงข้อมูล</div>
                            <div>พบข้อมูลเพิ่มขึ้นเพียง ${newRoads} รายการ แต่มีกริดที่ประมวลผลไม่สำเร็จ ${failedGrids} กริด (${(failedGrids/totalGrids*100).toFixed(1)}%) ควรลองประมวลผลซ้ำอีกครั้ง</div>
                        `;
                    }
                    // กรณีที่ 3: มีข้อมูลใหม่ไม่มาก และไม่มีปัญหากับกริด - แนะนำว่าอาจจะครบถ้วนแล้ว
                    else if (newRoads < 100 && failedGrids < totalGrids * 0.01 && processCount > 1) {
                        adviceElement.style.backgroundColor = "#E3F2FD";
                        adviceElement.style.borderLeft = "3px solid #2196F3";
                        adviceElement.innerHTML = `
                            <div style="font-weight: bold; color: #1565C0; margin-bottom: 5px;">ℹ️ การประมวลผลอาจครบถ้วนแล้ว</div>
                            <div>พบข้อมูลเพิ่มขึ้นเพียง ${newRoads} รายการ การประมวลผลอาจครบถ้วนแล้ว</div>
                        `;
                    }
                    // กรณีที่ 4: การประมวลผลครั้งแรก - แนะนำให้ประมวลผลซ้ำ
                    else if (processCount === 1) {
                        adviceElement.style.backgroundColor = "#E3F2FD";
                        adviceElement.style.borderLeft = "3px solid #2196F3";
                        adviceElement.innerHTML = `
                            <div style="font-weight: bold; color: #1565C0; margin-bottom: 5px;">ℹ️ การประมวลผลขั้นต้นเสร็จสิ้น</div>
                            <div>ได้รับข้อมูล ${selectedRoads.length.toLocaleString()} รายการ แนะนำให้กดปุ่ม "ประมวลผลซ้ำเพื่อดึงข้อมูลเพิ่มเติม" อย่างน้อย 1 ครั้งเพื่อให้แน่ใจว่าได้ข้อมูลครบถ้วน</div>
                        `;
                    }
                    // กรณีที่ 5: มีการประมวลผลซ้ำหลายครั้งและยังได้ข้อมูลใหม่เรื่อยๆ - แนะนำให้ประมวลผลต่อหรือปรับพื้นที่
                    else if (processCount > 3 && newRoads > 0) {
                        adviceElement.style.backgroundColor = "#FFF8E1";
                        adviceElement.style.borderLeft = "3px solid #FFC107";
                        adviceElement.innerHTML = `
                            <div style="font-weight: bold; color: #FF8F00; margin-bottom: 5px;">⚠️ ยังคงพบข้อมูลเพิ่มเติม</div>
                            <div>หลังจากประมวลผล ${processCount} ครั้ง ยังพบข้อมูลเพิ่มขึ้น ${newRoads} รายการ พื้นที่นี้อาจมีข้อมูลจำนวนมาก ควรประมวลผลซ้ำอีกครั้งหรือพิจารณาแบ่งพื้นที่เป็นส่วนเล็กๆ</div>
                        `;
                    }
                    
                    // เพิ่ม element เข้าไปใน DOM
                    if (adviceElement.innerHTML) {
                        document.getElementById("processingStats").appendChild(adviceElement);
                    }
                }

                async function processRoadsByGrid(geometry, type = 'boundary') {
                    // อ่านค่าการตั้งค่าขั้นสูง
                    const userGridSize = parseInt(document.getElementById("gridSizeInput").value) || 300;
                    const maxFeatures = parseInt(document.getElementById("maxFeaturesInput").value) || 500000;
                    const userMaxConcurrentGrids = parseInt(document.getElementById("concurrentGridsInput").value) || 15;
                    
                    // เพิ่มการนับครั้งการประมวลผล
                    processCount++;
                    
                    // เก็บจำนวนข้อมูลก่อนการประมวลผลล่าสุด
                    previousSelectionCount = selectedRoads ? selectedRoads.length : 0;
                    
                    // ลบ layer การแสดงผลแต่ยังคงข้อมูลที่เคยประมวลผลแล้ว
                    gridLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    
                    // กรณีการประมวลผลครั้งแรกให้เริ่มจากศูนย์
                    if (processCount === 1) {
                        selectedRoads = [];
                        processedIds = {};
                    }
                    
                    // Show grid process container
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'block';
                    
                    // แสดงข้อมูลสถิติการประมวลผล
                    const processingStats = document.getElementById("processingStats");
                    processingStats.style.display = "block";
                    document.getElementById("processCount").textContent = `จำนวนครั้งที่ประมวลผล: ${processCount}`;
                    document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${selectedRoads ? selectedRoads.length : 0}`;
                    document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: กำลังประมวลผล...`;
                    
                    try {
                        // ขนาดกริดสำหรับการแสดงผลและประมวลผล
                        // ปรับขนาดกริดให้เล็กลงเพื่อเพิ่มความละเอียดในการดึงข้อมูล
                        const displayGridSize = roadGeometryType === "polygon" ? 800 : 600; // กริดใหญ่สำหรับแสดงผล
                        const processingGridSize = userGridSize; // ใช้ค่าที่ผู้ใช้กำหนด
                        
                        // สร้างกริดสำหรับการแสดงผล (ใหญ่)
                        const displayGridResult = createGridCells(geometry.extent, displayGridSize);
                        const displayGrids = displayGridResult.grids;
                        
                        // สร้างกริดสำหรับประมวลผล (เล็ก)
                        processingGridResult = createGridCells(geometry.extent, processingGridSize);
                        const processingGrids = processingGridResult.grids;
                        
                        // เก็บข้อมูลเพิ่มเติม
                        const adjustedGridSize = processingGridResult.adjustedGridSize;
                        
                        const totalGrids = processingGrids.length;
                        let processedCount = 0;
                        let totalRoads = selectedRoads ? selectedRoads.length : 0;
                        let newRoads = 0;
                        
                        // เพิ่มข้อมูลขนาดกริดที่ใช้จริงในการประมวลผล
                        gridStatus.style.display = "block";
                        gridStatus.textContent = `เริ่มประมวลผลกริดครั้งที่ ${processCount} (ขนาดกริด ${adjustedGridSize}m)`;
                        gridDetails.style.display = "block";
                        gridDetails.textContent = `0/${totalGrids} กริด`;
                        if (processCount > 1) {
                            gridDetails.textContent += ` (ข้อมูลเดิม: ${previousSelectionCount})`;
                        }
                        progressBarFill.style.width = '0%';
                        
                        // แสดงกริดสำหรับการแสดงผล
                        displayGrids.forEach(grid => {
                            const gridGraphic = new Graphic({
                                geometry: grid,
                                symbol: {
                                    type: "simple-fill",
                                    color: [255, 165, 0, 0.1], // ลดความทึบให้เห็นแผนที่ด้านล่างได้
                                    outline: {
                                        color: [255, 165, 0, 0.5],
                                        width: 0.5
                                    }
                                }
                            });
                            gridLayer.add(gridGraphic);
                        });
                        
                        // ปรับปรุงการประมวลผลแบบ concurrent สำหรับ grid ขนาดเล็ก
                        // ใช้ค่าที่ผู้ใช้กำหนดหรือค่าเริ่มต้นตามประเภทข้อมูล
                        const maxConcurrentGrids = userMaxConcurrentGrids;
                        
                        // แบ่งกริดเป็นส่วนๆ ตามจำนวน concurrent ที่กำหนด
                        const gridSegments = [];
                        let segmentCount = Math.ceil(processingGrids.length / 1000); // แบ่งเป็นชุดละไม่เกิน 1000 กริด
                        segmentCount = Math.max(2, Math.min(segmentCount, 10)); // มีอย่างน้อย 2 ส่วน แต่ไม่เกิน 10 ส่วน
                        
                        const segmentSize = Math.ceil(processingGrids.length / segmentCount);
                        for (let i = 0; i < segmentCount; i++) {
                            const startIdx = i * segmentSize;
                            const endIdx = Math.min((i + 1) * segmentSize, processingGrids.length);
                            gridSegments.push(processingGrids.slice(startIdx, endIdx));
                        }
                        
                        // เก็บข้อมูลสถานะสำหรับแสดงผล
                        let failedQueries = 0;
                        let startTime = Date.now();
                        let lastStatusUpdateTime = startTime;
                        
                        // เพิ่มการตรวจสอบความซ้ำซ้อนที่เข้มงวดมากขึ้น
                        const uniqueIdentifiers = new Set();
                        
                        // ประมวลผลทีละส่วนเพื่อลดการใช้หน่วยความจำ
                        for (const [segmentIndex, segment] of gridSegments.entries()) {
                            // แสดงสถานะให้ผู้ใช้ทราบ
                            gridStatus.textContent = `กำลังประมวลผลส่วนที่ ${segmentIndex + 1}/${gridSegments.length}`;
                            
                            // แบ่งกริดในแต่ละส่วนเป็นกลุ่มๆ สำหรับประมวลผลพร้อมกัน
                            const gridGroups = [];
                            for (let i = 0; i < segment.length; i += maxConcurrentGrids) {
                                gridGroups.push(segment.slice(i, i + maxConcurrentGrids));
                            }
                            
                            // ประมวลผลทีละกลุ่มกริดในส่วนนี้
                            for (const [groupIndex, currentGrids] of gridGroups.entries()) {
                                // คำนวณความคืบหน้าในภาพรวม
                                const overallProgress = ((segmentIndex * segment.length + groupIndex * maxConcurrentGrids) / processingGrids.length) * 100;
                                progressBarFill.style.width = `${overallProgress}%`;
                                
                                // ประมวลผลกริดพร้อมกันหลายกริด
                                const results = await Promise.all(currentGrids.map(async (grid, localIndex) => {
                                    const globalGridIndex = segmentIndex * segmentSize + groupIndex * maxConcurrentGrids + localIndex;
                                    
                                    try {
                                        // สร้าง query สำหรับดึงข้อมูลถนนในกริด
                                        const query = roadsLayer.createQuery();
                                        query.geometry = grid;
                                        query.spatialRelationship = "intersects";
                                        query.returnGeometry = true;
                                        query.outFields = ["*"];
                                        
                                        // เพิ่มการกำหนดขนาดของผลลัพธ์สูงสุด (ป้องกันการจำกัดโดย server)
                                        query.num = 2000; // ดึงจำนวนมากในแต่ละกริด
                                        
                                        // ปรับแต่ง query เพื่อให้ได้ผลลัพธ์ที่ครบถ้วนมากขึ้น
                                        if (roadGeometryType === "polygon") {
                                            // เพิ่มการกรองพิเศษสำหรับ polygon ถ้าจำเป็น
                                        }
                                        
                                        const result = await roadsLayer.queryFeatures(query);
                                        
                                        // ตรวจสอบว่าผลลัพธ์อาจถูกตัดหรือไม่ (เต็มขีดจำกัด)
                                        const possiblyTruncated = result.features.length >= (query.num || 1000);
                                        
                                        let validRoads = result.features;
                                        
                                        if (type === 'draw') {
                                            // สำหรับการวาดพื้นที่ กรองเฉพาะถนนที่อยู่ในพื้นที่ที่วาด
                                            validRoads = result.features.filter(road => 
                                                geometryEngine.intersects(road.geometry, geometry)
                                            );
                                        }
                                        
                                        // เพิ่มข้อมูลเกี่ยวกับความสมบูรณ์ของข้อมูล
                                        return {
                                            features: validRoads,
                                            truncated: possiblyTruncated,
                                            gridIndex: globalGridIndex
                                        };
                                    } catch (error) {
                                        console.error(`Error processing grid ${globalGridIndex}:`, error);
                                        failedQueries++;
                                        return {
                                            features: [],
                                            truncated: false,
                                            error: true,
                                            gridIndex: globalGridIndex
                                        };
                                    }
                                }));
                                
                                // นับจำนวนกริดที่มีข้อมูลถูกตัดและกริดที่มีข้อผิดพลาด
                                const truncatedGrids = results.filter(r => r.truncated).length;
                                const errorGrids = results.filter(r => r.error).length;
                                
                                // รวบรวม features จากทุกกริดในกลุ่มนี้
                                const allFeaturesInGroup = results.flatMap(r => r.features);
                                
                                // เพิ่มข้อมูลใหม่และตรวจสอบความซ้ำซ้อน
                                let newInGroup = 0;
                                
                                for (const road of allFeaturesInGroup) {
                                    // ใช้หลายฟิลด์เพื่อระบุความซ้ำซ้อน
                                    const id = road.attributes.OBJECTID || road.attributes.FID || 
                                              road.attributes.objectid || road.attributes.fid;
                                    
                                    // สร้าง unique identifier ที่มีความเข้มงวดมากขึ้น
                                    let uniqueId = id ? id.toString() : '';
                                    
                                    // ถ้าไม่มี ID ชัดเจน ให้ใช้ข้อมูลเชิงพื้นที่
                                    if (!uniqueId || uniqueId === '') {
                                        if (roadGeometryType === "polygon" && road.geometry.rings && road.geometry.rings.length > 0) {
                                            // ใช้จุดแรกและจุดสุดท้ายของ polygon เป็นเอกลักษณ์
                                            const firstRing = road.geometry.rings[0];
                                            if (firstRing && firstRing.length > 0) {
                                                uniqueId = `poly_${firstRing[0][0]}_${firstRing[0][1]}_${firstRing[firstRing.length-1][0]}_${firstRing[firstRing.length-1][1]}`;
                                            }
                                        } else if (roadGeometryType === "polyline" && road.geometry.paths && road.geometry.paths.length > 0) {
                                            // ใช้จุดแรกและจุดสุดท้ายของเส้นเป็นเอกลักษณ์
                                            const firstPath = road.geometry.paths[0];
                                            if (firstPath && firstPath.length > 0) {
                                                uniqueId = `line_${firstPath[0][0]}_${firstPath[0][1]}_${firstPath[firstPath.length-1][0]}_${firstPath[firstPath.length-1][1]}`;
                                            }
                                        }
                                    }
                                    
                                    // เพิ่มเฉพาะข้อมูลที่ยังไม่เคยประมวลผล
                                    if (uniqueId && !uniqueIdentifiers.has(uniqueId)) {
                                        uniqueIdentifiers.add(uniqueId);
                                        processedIds[uniqueId] = true;
                                        selectedRoads.push(road);
                                        newRoads++;
                                        newInGroup++;
                                    }
                                }
                                
                                // ปรับปรุงและแสดงสถานะทุก 1 วินาทีเพื่อลดการอัปเดต UI บ่อยเกินไป
                                const currentTime = Date.now();
                                if (currentTime - lastStatusUpdateTime > 1000 || groupIndex === gridGroups.length - 1) {
                                    lastStatusUpdateTime = currentTime;
                                    
                                    // คำนวณความเร็วและเวลาที่เหลือ
                                    const elapsedSeconds = (currentTime - startTime) / 1000;
                                    const gridsProcessed = segmentIndex * segmentSize + (groupIndex + 1) * maxConcurrentGrids;
                                    const gridsPerSecond = gridsProcessed / elapsedSeconds;
                                    const remainingGrids = processingGrids.length - gridsProcessed;
                                    const estimatedRemainingSeconds = remainingGrids / gridsPerSecond;
                                    
                                    // สร้างข้อความแสดงเวลา
                                    let timeText = "";
                                    if (estimatedRemainingSeconds < 60) {
                                        timeText = `${Math.round(estimatedRemainingSeconds)} วินาที`;
                                    } else if (estimatedRemainingSeconds < 3600) {
                                        timeText = `${Math.floor(estimatedRemainingSeconds / 60)} นาที ${Math.round(estimatedRemainingSeconds % 60)} วินาที`;
                                    } else {
                                        timeText = `${Math.floor(estimatedRemainingSeconds / 3600)} ชั่วโมง ${Math.floor((estimatedRemainingSeconds % 3600) / 60)} นาที`;
                                    }
                                    
                                    // อัปเดตสถานะการประมวลผล
                                    const progressPercent = Math.round(overallProgress);
                                    gridStatus.textContent = `กำลังประมวลผลครั้งที่ ${processCount}... ${progressPercent}% (เหลือเวลาอีกประมาณ ${timeText})`;
                                    
                                    // แสดงรายละเอียดเพิ่มเติม
                                    let statusDetails = `ส่วนที่ ${segmentIndex + 1}/${gridSegments.length} - กริดกลุ่มที่ ${groupIndex + 1}/${gridGroups.length}`;
                                    statusDetails += ` | พบข้อมูลใหม่: ${newRoads} รายการ`;
                                    
                                    // เพิ่มข้อมูลกริดที่มีปัญหา
                                    if (truncatedGrids > 0 || errorGrids > 0) {
                                        statusDetails += ` | `;
                                        if (truncatedGrids > 0) {
                                            statusDetails += `กริดข้อมูลอาจไม่ครบ: ${truncatedGrids} `;
                                        }
                                        if (errorGrids > 0) {
                                            statusDetails += `กริดที่มีข้อผิดพลาด: ${errorGrids}`;
                                        }
                                    }
                                    
                                    gridDetails.textContent = statusDetails;
                                    
                                    // อัพเดทข้อมูลสถิติ
                                    document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${selectedRoads.length}`;
                                    document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: +${newRoads}`;
                                    
                                    // ถ้าจำนวนถนนมากเกินไปเกินขีดจำกัด ให้หยุดการประมวลผล
                                    if (selectedRoads.length > maxFeatures) {
                                        console.warn(`จำนวนถนนมากเกินไป (${selectedRoads.length}). หยุดการประมวลผลเพื่อป้องกันปัญหาหน่วยความจำ`);
                                        
                                        // เพิ่มการแจ้งเตือนเฉพาะกรณีที่พบจำนวนข้อมูลมาก
                                        const warningDiv = document.createElement('div');
                                        warningDiv.style.color = '#FF5722';
                                        warningDiv.style.fontWeight = 'bold';
                                        warningDiv.style.padding = '10px';
                                        warningDiv.style.marginTop = '10px';
                                        warningDiv.style.backgroundColor = '#FFF3E0';
                                        warningDiv.style.borderRadius = '4px';
                                        warningDiv.textContent = `คำเตือน: ถึงขีดจำกัด ${maxFeatures.toLocaleString()} รายการ! กรุณาลองเลือกพื้นที่ให้เล็กลงหรือส่งออกข้อมูลนี้ก่อน`;
                                        
                                        // เพิ่มไปที่ container
                                        document.getElementById("gridProcessContainer").appendChild(warningDiv);
                                        
                                        // ลบการแจ้งเตือนหลังจากผ่านไป 10 วินาที
                                        setTimeout(() => {
                                            if (warningDiv.parentNode) {
                                                warningDiv.parentNode.removeChild(warningDiv);
                                            }
                                        }, 10000);
                                        
                                        // จบการประมวลผล
                                        break;
                                    }
                                }
                                
                                // ให้ UI ได้มีโอกาส update ก่อนเริ่มประมวลผลชุดถัดไป
                                await new Promise(resolve => setTimeout(resolve, 0));
                            }
                            
                            // ตรวจสอบว่าควรหยุดการประมวลผลหรือไม่
                            if (selectedRoads.length >= maxFeatures) {
                                // หยุดการประมวลผลหากข้อมูลมากกว่าขีดจำกัด
                                break;
                            }
                        }
                        
                        // สรุปผลการประมวลผล
                        const endTime = Date.now();
                        const totalTimeSeconds = (endTime - startTime) / 1000;
                        
                        // แสดงสรุปผลการประมวลผล
                        gridStatus.textContent = `ประมวลผลครั้งที่ ${processCount} เสร็จสิ้น (${totalTimeSeconds.toFixed(1)} วินาที)`;
                        
                        // เพิ่มการแสดงจำนวนกริดที่มีปัญหา
                        if (failedQueries > 0) {
                            gridDetails.textContent = `พบข้อมูลใหม่ ${newRoads} รายการ (รวมทั้งหมด ${selectedRoads.length} รายการ) - มีกริดที่ประมวลผลไม่สำเร็จ ${failedQueries} กริด`;
                        } else {
                            gridDetails.textContent = `พบข้อมูลใหม่ ${newRoads} รายการ (รวมทั้งหมด ${selectedRoads.length} รายการ)`;
                        }
                        
                        // อัพเดทสถิติการประมวลผล
                        document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${selectedRoads.length.toLocaleString()}`;
                        document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: +${newRoads.toLocaleString()}`;
                        
                        // วิเคราะห์ผลการประมวลผลและให้คำแนะนำ
                        analyzeProcessingResult(newRoads, previousSelectionCount, totalGrids, failedQueries);
                        
                        // ตั้งค่าปุ่มเพื่อให้พร้อมส่งออกข้อมูล
                        previewButton.disabled = false;
                        exportButton.disabled = false;
                        
                        // แสดงตัวอย่างการส่งออก (เฉพาะเมื่อจำนวนข้อมูลไม่มากเกินไป)
                        if (selectedRoads.length <= 100000) {
                            await previewExportRoads();
                        } else {
                            loadingMessage.style.display = "block";
                            loadingMessage.textContent = `เนื่องจากมีข้อมูลถนนจำนวนมาก (${selectedRoads.length.toLocaleString()} รายการ) จึงไม่แสดงตัวอย่าง สามารถกดปุ่มส่งออกได้ทันที`;
                            setTimeout(() => {
                                loadingMessage.style.display = "none";
                            }, 5000);
                        }
                        
                        // ซ่อน grid process container หลังจากการประมวลผลเสร็จสิ้น
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                        }, 5000);
                        
                    } catch (error) {
                        console.error("Error in grid processing:", error);
                        gridStatus.textContent = "เกิดข้อผิดพลาดในการประมวลผล";
                        gridDetails.textContent = error.message || "";
                    }
                }

               // ปรับฟังก์ชัน previewExportRoads สำหรับการแสดงผลตามประเภทข้อมูล
               async function previewExportRoads() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังวิเคราะห์ข้อมูล...";
                    previewButton.disabled = true;

                    try {
                        exportPreviewLayer.removeAll();
                        
                        const totalRoads = selectedRoads.length;
                        loadingMessage.textContent = `พบเส้นทาง/พื้นที่ทั้งหมด ${totalRoads.toLocaleString()} รายการ`;

                        // ถ้ามีข้อมูลมากเกินไป ให้แสดงเฉพาะบางส่วน
                        const maxPreviewRoads = roadGeometryType === "polygon" ? 15000 : 30000;
                        
                        if (totalRoads > maxPreviewRoads) {
                            loadingMessage.textContent = `มีข้อมูลจำนวนมาก (${totalRoads.toLocaleString()} รายการ) จะแสดงตัวอย่างเพียงบางส่วน`;
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }

                        const processVisibleRoads = async () => {
                            const viewExtent = view.extent;
                            
                            // ปรับขนาด batch ให้เหมาะสมกับประเภทข้อมูล
                            const batchSize = roadGeometryType === "polygon" ? 5000 : 10000;
                            
                            // จำกัดจำนวนข้อมูลที่จะแสดงตัวอย่าง
                            const roadsToProcess = totalRoads > maxPreviewRoads ? 
                                selectedRoads.slice(0, maxPreviewRoads) : selectedRoads;
                            
                            const chunks = [];
                            for (let i = 0; i < roadsToProcess.length; i += batchSize) {
                                chunks.push(roadsToProcess.slice(i, i + batchSize));
                            }

                            // ฟังก์ชันสำหรับจัดเตรียมข้อมูลเพื่อแสดงผล
                            const processChunk = async (roads) => {
                                // กรองเฉพาะถนนที่อยู่ในพื้นที่มุมมองปัจจุบัน
                                const visibleRoads = roads.filter(road => 
                                    geometryEngine.intersects(road.geometry, viewExtent)
                                );
                                
                                // ในกรณีที่มีข้อมูลมากเกินไป ให้สุ่มเลือกบางส่วน
                                let processRoads = visibleRoads;
                                if (visibleRoads.length > 5000 && roadGeometryType === "polygon") {
                                    // สุ่มเลือก 5000 รายการ
                                    const shuffled = [...visibleRoads].sort(() => 0.5 - Math.random());
                                    processRoads = shuffled.slice(0, 5000);
                                }
                                
                                return processRoads.map(road => {
                                    let priority = 0;
                                    
                                    if (roadGeometryType === "polygon") {
                                        // คำนวณพื้นที่เพียงครั้งเดียว
                                        const area = geometryEngine.geodesicArea(road.geometry, "square-meters");
                                        priority = area > 0 ? area : 0;
                                    } else {
                                        priority = road.geometry.length || 0;
                                    }
                                    
                                    const width = road.attributes.WIDTH || road.attributes.width || 0;
                                    
                                    return {
                                        road,
                                        priority,
                                        width
                                    };
                                });
                            };
                            // ประมวลผล chunk แบบขนาน
                            const maxConcurrentProcessing = navigator.hardwareConcurrency ? 
                                Math.min(navigator.hardwareConcurrency, 4) : 2;
                            
                            let processedRoads = [];
                            
                            for (let i = 0; i < chunks.length; i += maxConcurrentProcessing) {
                                const currentChunks = chunks.slice(i, i + maxConcurrentProcessing);
                                const results = await Promise.all(
                                    currentChunks.map(async (chunk, index) => {
                                        const result = await processChunk(chunk);
                                        const progress = Math.round(((i + index + 1) / chunks.length) * 100);
                                        loadingMessage.textContent = `กำลังวิเคราะห์ข้อมูล... ${progress}%`;
                                        return result;
                                    })
                                );
                                processedRoads = processedRoads.concat(results.flat());
                                
                                // ถ้ามีข้อมูลมากเกินไป ให้หยุดการประมวลผล
                                if (processedRoads.length > 20000) {
                                    break;
                                }
                            }

                            // เรียงลำดับความสำคัญ
                            processedRoads.sort((a, b) => {
                                if (roadGeometryType === "polygon") {
                                    return b.priority - a.priority;
                                } else {
                                    const aPriority = (a.priority * 0.7) + (a.width * 0.3);
                                    const bPriority = (b.priority * 0.7) + (b.width * 0.3);
                                    return bPriority - aPriority;
                                }
                            });

                            // กำหนดจำนวนสูงสุดของแต่ละระดับความสำคัญ
                            const maxHighPriority = roadGeometryType === "polygon" ? 3000 : 10000;
                            const maxMediumPriority = roadGeometryType === "polygon" ? 5000 : 15000;
                            
                            const highPriority = processedRoads.slice(0, maxHighPriority);
                            const mediumPriority = processedRoads.slice(maxHighPriority, maxHighPriority + maxMediumPriority);
                            const lowPriority = processedRoads.slice(maxHighPriority + maxMediumPriority);

                            // ฟังก์ชันสร้างกราฟิกแบบแบทช์
                            const createGraphicsBatch = async (roads, symbolWidth, delay = 0) => {
                                const graphicsBatchSize = roadGeometryType === "polygon" ? 500 : 1000;
                                let graphics = [];

                                for (let i = 0; i < roads.length; i += graphicsBatchSize) {
                                    const batch = roads.slice(i, i + graphicsBatchSize);
                                    
                                    const batchGraphics = batch.map(item => {
                                        let symbol;
                                        
                                        if (roadGeometryType === "polygon") {
                                            symbol = {
                                                type: "simple-fill",
                                                color: [255, 0, 0, 0.2], // ลดความทึบให้เห็นชัดขึ้น
                                                outline: {
                                                    color: [255, 0, 0],
                                                    width: symbolWidth
                                                }
                                            };
                                        } else {
                                            symbol = {
                                                type: "simple-line",
                                                color: [255, 0, 0],
                                                width: symbolWidth
                                            };
                                        }
                                        
                                        return new Graphic({
                                            geometry: item.road.geometry,
                                            attributes: item.road.attributes,
                                            symbol: symbol
                                        });
                                    });

                                    graphics = graphics.concat(batchGraphics);
                                    
                                    if (graphics.length >= (roadGeometryType === "polygon" ? 2500 : 5000) || 
                                        i + graphicsBatchSize >= roads.length) {
                                        exportPreviewLayer.addMany(graphics);
                                        graphics = [];
                                        
                                        if (delay > 0) {
                                            const adjustedDelay = roadGeometryType === "polygon" ? 
                                                Math.max(1, delay / 3) : delay;
                                            await new Promise(resolve => setTimeout(resolve, adjustedDelay));
                                        }
                                    }
                                }
                            };

                            const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                            
                            // แสดงข้อมูลหลัก (ความสำคัญสูง)
                            loadingMessage.textContent = `กำลังแสดง${itemTypeName}หลัก...`;
                            await createGraphicsBatch(highPriority, 
                                roadGeometryType === "polygon" ? "1px" : "2px", 
                                roadGeometryType === "polygon" ? 0 : 1);
                            
                            // แสดงข้อมูลรอง (ความสำคัญปานกลาง)
                            if (mediumPriority.length > 0) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}รอง...`;
                                await createGraphicsBatch(mediumPriority, 
                                    roadGeometryType === "polygon" ? "0.5px" : "1px", 
                                    roadGeometryType === "polygon" ? 0 : 1);
                            }
                            
                            // แสดงข้อมูลย่อย (ความสำคัญต่ำ) เฉพาะเมื่อไม่มีข้อมูลมากเกินไป
                            if (lowPriority.length > 0 && 
                                (roadGeometryType !== "polygon" || lowPriority.length < 1000)) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}ย่อย...`;
                                await createGraphicsBatch(lowPriority, 
                                    roadGeometryType === "polygon" ? "0.3px" : "0.5px", 
                                    roadGeometryType === "polygon" ? 0 : 1);
                            }
                        };

                        // ใช้ debounce เพื่อลดการเรียกซ้ำบ่อยๆ
                        let updateTimeout;
                        const debouncedUpdate = () => {
                            clearTimeout(updateTimeout);
                            const debounceTime = roadGeometryType === "polygon" ? 1500 : 1000;
                            updateTimeout = setTimeout(async () => {
                                exportPreviewLayer.removeAll();
                                await processVisibleRoads();
                            }, debounceTime);
                        };

                        // ประมวลผลข้อมูลที่อยู่ในมุมมองปัจจุบัน
                        await processVisibleRoads();
                        
                        // ติดตามการเปลี่ยนแปลงขอบเขตและการหมุนแผนที่
                        view.watch("extent", debouncedUpdate);
                        view.watch("rotation", debouncedUpdate);

                        // แสดงเลเยอร์ผลลัพธ์และเปิดใช้งานปุ่มส่งออก
                        exportPreviewLayer.visible = true;
                        exportButton.disabled = false;

                        // แสดงข้อความสรุป
                        const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                        loadingMessage.textContent = `พร้อมส่งออกข้อมูล${itemTypeName} ${totalRoads.toLocaleString()} รายการ`;
                        
                        // ซ่อนข้อความสถานะหลังจากเวลาผ่านไป
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);

                    } catch (error) {
                        console.error("Error previewing roads:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการสร้างตัวอย่าง";
                    } finally {
                        previewButton.disabled = false;
                    }
                }

                // ปรับปรุงฟังก์ชัน exportRoadsToGeoJSON ให้มีประสิทธิภาพและโหลดข้อมูลครบถ้วน
                async function exportRoadsToGeoJSON() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังเตรียมข้อมูลเพื่อส่งออก...";

                    try {
                        const name = document.getElementById("boundarySelect").value || "selected_area";
                        
                        const utmSR = new SpatialReference({
                            wkid: 32647
                        });

                        // แสดงความคืบหน้า
                        const progressBar = document.querySelector(".progress-bar-fill");
                        const gridProcessContainer = document.getElementById('gridProcessContainer');
                        const gridStatus = document.getElementById("gridStatus");
                        const gridDetails = document.getElementById("gridDetails");
                        
                        gridProcessContainer.style.display = 'block';
                        gridStatus.style.display = "block";
                        gridStatus.textContent = "กำลังเตรียมข้อมูลเพื่อส่งออก...";
                        gridDetails.style.display = "block";
                        gridDetails.textContent = `0/${selectedRoads.length} รายการ`;
                        progressBar.style.width = '0%';
                        
                        // เพิ่มรายละเอียดลงใน GeoJSON
                        const geojson = {
                            type: "FeatureCollection",
                            name: `roads_${name}`,
                            crs: {
                                type: "name",
                                properties: {
                                    name: "EPSG:32647"
                                }
                            },
                            metadata: {
                                exportDate: new Date().toISOString(),
                                totalFeatures: selectedRoads.length,
                                geometryType: roadGeometryType,
                                gridSize: `${processingGridResult ? processingGridResult.adjustedGridSize : 300}x${processingGridResult ? processingGridResult.adjustedGridSize : 300}m`,
                                processingCount: processCount,
                                source: "Department of Public Works and Town & Country Planning"
                            },
                            features: []
                        };
                        
                        // ปรับขนาด batch ให้เล็กลงเพื่อป้องกันปัญหาหน่วยความจำเต็ม
                        const batchSize = Math.min(Math.max(100, Math.floor(500000 / selectedRoads.length * 500)), 500);
                        const totalBatches = Math.ceil(selectedRoads.length / batchSize);
                        
                        // แสดงการประมาณการเวลาทั้งหมด
                        const startTime = Date.now();
                        let estimatedTotalTime = 0;
                        let partCount = 0;
                        
                        // กำหนดขนาดสูงสุดของแต่ละส่วน GeoJSON (ควรน้อยกว่าขีดจำกัดของเบราว์เซอร์)
                        const maxFeaturesPerFile = 50000;
                        
                        // เตรียมข้อมูลสำหรับแบ่งไฟล์
                        const totalParts = Math.ceil(selectedRoads.length / maxFeaturesPerFile);
                        let currentPartFeatures = [];
                        
                        // ประมวลผลทีละ batch
                        for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                            const start = batchIndex * batchSize;
                            const end = Math.min(start + batchSize, selectedRoads.length);
                            const currentBatch = selectedRoads.slice(start, end);
                            
                            // ประมวลผลแต่ละรายการใน batch
                            const batchFeatures = await Promise.all(currentBatch.map(async (feature) => {
                                try {
                                    const utmGeometry = projection.project(
                                        feature.geometry,
                                        utmSR
                                    );
                                    
                                    let geometryObject;
                                    let lengthField = 0;
                                    let areaField = null;
                                    
                                    if (roadGeometryType === "polygon") {
                                        geometryObject = {
                                            type: "Polygon",
                                            coordinates: utmGeometry.rings
                                        };
                                        
                                        // คำนวณพื้นที่
                                        if (feature.geometry.rings) {
                                            areaField = geometryEngine.geodesicArea(feature.geometry, "square-meters");
                                            lengthField = geometryEngine.geodesicLength(feature.geometry, "meters");
                                        }
                                    } else {
                                        geometryObject = {
                                            type: "LineString",
                                            coordinates: utmGeometry.paths ? utmGeometry.paths[0] : []
                                        };
                                        
                                        // คำนวณความยาว
                                        lengthField = geometryEngine.geodesicLength(feature.geometry, "meters");
                                    }
                                    
                                    // กำหนดคุณสมบัติเพิ่มเติม
                                    const properties = {
                                        ...feature.attributes,
                                        length_m: parseFloat(lengthField.toFixed(2)), // ปัดเศษให้มีเพียง 2 ตำแหน่ง
                                        area_sqm: areaField ? parseFloat(areaField.toFixed(2)) : null,
                                        road_id: feature.attributes.OBJECTID || feature.attributes.FID || 
                                                 feature.attributes.objectid || feature.attributes.fid || null,
                                        geometry_type: roadGeometryType,
                                        exported_by: "ThaiRoadExtractor",
                                        export_date: new Date().toISOString().split('T')[0]
                                    };
                                    
                                    // สร้าง Feature object
                                    return {
                                        type: "Feature",
                                        geometry: geometryObject,
                                        properties: properties
                                    };
                                } catch (error) {
                                    console.error("Error processing feature:", error);
                                    return null;
                                }
                            }));
                            
                            // กรองข้อมูลที่เป็น null ออก
                            const validFeatures = batchFeatures.filter(feature => feature !== null);
                            
                            // เพิ่มข้อมูลลงใน GeoJSON และอาเรย์สำหรับแบ่งไฟล์
                            geojson.features = geojson.features.concat(validFeatures);
                            currentPartFeatures = currentPartFeatures.concat(validFeatures);
                            
                            // ตรวจสอบว่าถึงเวลาที่ต้องสร้างไฟล์ส่วนย่อยหรือไม่
                            if (currentPartFeatures.length >= maxFeaturesPerFile || end === selectedRoads.length) {
                                partCount++;
                                
                                // สร้างชื่อไฟล์
                                const partFileName = `roads_${name}_part${partCount}of${totalParts}_utm47n`;
                                
                                // สร้าง GeoJSON สำหรับส่วนนี้
                                const partGeojson = {
                                    ...geojson,
                                    name: partFileName,
                                    metadata: {
                                        ...geojson.metadata,
                                        partNumber: partCount,
                                        totalParts: totalParts,
                                        features: currentPartFeatures.length
                                    },
                                    features: currentPartFeatures
                                };
                                
                                // สร้างและบันทึกไฟล์ส่วนย่อย
                                const partBlob = new Blob([JSON.stringify(partGeojson, null, 2)], { 
                                    type: "application/json" 
                                });
                                const partUrl = URL.createObjectURL(partBlob);
                                const partLink = document.createElement("a");
                                partLink.href = partUrl;
                                partLink.download = `${partFileName}_${new Date().getTime()}.geojson`;
                                document.body.appendChild(partLink);
                                partLink.click();
                                document.body.removeChild(partLink);
                                URL.revokeObjectURL(partUrl);
                                
                                // แสดงข้อความแจ้งเตือน
                                gridStatus.textContent = `บันทึกส่วนที่ ${partCount} จาก ${totalParts} ส่วน`;
                                await new Promise(resolve => setTimeout(resolve, 500));
                                
                                // ล้างข้อมูลเพื่อเตรียมสำหรับส่วนถัดไป
                                currentPartFeatures = [];
                            }
                            
                            // คำนวณเวลาที่ใช้และประมาณการเวลาที่เหลือ
                            const currentTime = Date.now();
                            const elapsedTime = (currentTime - startTime) / 1000; // เวลาที่ผ่านไปเป็นวินาที
                            const processedItems = end;
                            
                            if (batchIndex > 0) {
                                const itemsPerSecond = processedItems / elapsedTime;
                                const remainingItems = selectedRoads.length - processedItems;
                                const estimatedRemainingTime = remainingItems / itemsPerSecond;
                                estimatedTotalTime = elapsedTime + estimatedRemainingTime;
                                
                                // แสดงเวลาในรูปแบบที่อ่านง่าย
                                const formatTime = (seconds) => {
                                    if (seconds < 60) return `${Math.round(seconds)} วินาที`;
                                    if (seconds < 3600) return `${Math.floor(seconds / 60)} นาที ${Math.round(seconds % 60)} วินาที`;
                                    return `${Math.floor(seconds / 3600)} ชั่วโมง ${Math.floor((seconds % 3600) / 60)} นาที`;
                                };
                                
                                const timeInfo = `ประมาณอีก ${formatTime(estimatedRemainingTime)} (ทั้งหมด ${formatTime(estimatedTotalTime)})`;
                                gridDetails.textContent = `${processedItems.toLocaleString()}/${selectedRoads.length.toLocaleString()} รายการ - ${timeInfo}`;
                            }
                            
                            // อัพเดทความคืบหน้า
                            const progress = ((batchIndex + 1) / totalBatches) * 100;
                            progressBarFill.style.width = `${progress}%`;
                            gridStatus.textContent = `กำลังส่งออกข้อมูล... ${Math.round(progress)}%`;
                            
                            // เพิ่มการหน่วงเวลาเล็กน้อยเพื่อให้ UI อัพเดท
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }

                        // แสดงสรุปผลการส่งออก
                        const endTime = Date.now();
                        const totalTime = ((endTime - startTime) / 1000).toFixed(1);
                        
                        gridStatus.textContent = "ส่งออกข้อมูลเสร็จสิ้น";
                        
                        if (totalParts > 1) {
                            gridDetails.textContent = `ส่งออกทั้งหมด ${selectedRoads.length.toLocaleString()} รายการ แบ่งเป็น ${totalParts} ไฟล์ (${totalTime} วินาที)`;
                        } else {
                            gridDetails.textContent = `ส่งออกทั้งหมด ${selectedRoads.length.toLocaleString()} รายการ (${totalTime} วินาที)`;
                        }
                        
                        // ซ่อนการแสดงสถานะหลังจากเวลาผ่านไป
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                            loadingMessage.style.display = "none";
                        }, 5000);
                    } catch (error) {
                        console.error("Error exporting data:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการส่งออกข้อมูล";
                        
                        // แสดงข้อผิดพลาดในกรณีเกิดปัญหา
                        gridStatus.textContent = "เกิดข้อผิดพลาด";
                        gridDetails.textContent = error.message || "ไม่สามารถส่งออกข้อมูลได้";
                        
                        // แสดงข้อความแนะนำเพิ่มเติม
                        setTimeout(() => {
                            gridDetails.textContent += " - ลองลดขนาดพื้นที่เลือกและลองอีกครั้ง";
                        }, 2000);
                    }
                }
                
                function toggleDrawingMode() {
                    isDrawing = !isDrawing;
                    drawPolygonButton.classList.toggle("active");
                    if (isDrawing) {
                        sketch.create("polygon");
                    } else {
                        sketch.cancel();
                    }
                }

                function clearSelection() {
                    selectionLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    gridLayer.removeAll();
                    selectedRoads = null;
                    processedIds = {}; // ล้าง ID ที่เคยประมวลผล
                    processCount = 0; // รีเซ็ตการนับจำนวนครั้ง
                    exportButton.disabled = true;
                    previewButton.disabled = true;
                    gridProcessButton.style.display = 'block';
                    document.getElementById("processingStats").style.display = "none";
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                }

                // Sketch Widget
                const sketch = new Sketch({
                    view: view,
                    layer: selectionLayer,
                    creationMode: "single",
                    availableCreateTools: ["polygon"],
                    visibleElements: {
                        createTools: {
                            point: false,
                            polyline: false,
                            rectangle: false,
                            circle: false
                        },
                        selectionTools: {
                            "lasso-selection": false,
                            "rectangle-selection": false
                        },
                        settingsMenu: false,
                        undoRedoMenu: false
                    }
                });

                // Event Handlers
                drawPolygonButton.addEventListener("click", toggleDrawingMode);
                clearSelectionButton.addEventListener("click", clearSelection);

                sketch.on("create", async (event) => {
                    if (event.state === "complete") {
                        const polygon = event.graphic.geometry;
                        await processRoadsByGrid(polygon, 'draw');
                        isDrawing = false;
                        drawPolygonButton.classList.remove("active");
                    }
                });

                function updateSelectOptions(boundaries) {
                    const select = document.getElementById("boundarySelect");
                    select.innerHTML = '<option value="">เลือกขอบเขตผัง</option>';
                    
                    boundaries.forEach(name => {
                        const option = document.createElement("option");
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });
                }

                function loadBoundaries() {
                    const query = new Query({
                        where: "1=1",
                        outFields: ["NAME"],
                        returnDistinctValues: true,
                        returnGeometry: false
                    });

                    boundariesLayer.queryFeatures(query)
                        .then(function(results) {
                            const select = document.getElementById("boundarySelect");
                            const boundaries = results.features
                                .map(feature => feature.attributes.NAME)
                                .filter(name => name)
                                .sort();
                            
                            select.dataset.allBoundaries = JSON.stringify(boundaries);
                            updateSelectOptions(boundaries);
                            loadingMessage.style.display = "none";
                        })
                        .catch(function(error) {
                            console.error("Error loading boundaries:", error);
                            loadingMessage.textContent = "เกิดข้อผิดพลาดในการโหลดข้อมูล";
                        });
                }

                function filterBoundaries() {
                    const input = document.getElementById("searchInput");
                    const select = document.getElementById("boundarySelect");
                    const searchTerm = input.value.toLowerCase();
                    
                    const allBoundaries = JSON.parse(select.dataset.allBoundaries || '[]');
                    const filteredBoundaries = allBoundaries.filter(name => 
                        name.toLowerCase().includes(searchTerm)
                    );
                    
                    updateSelectOptions(filteredBoundaries);
                }

                async function handleBoundarySelect(name) {
                    exportPreviewLayer.removeAll();
                    selectionLayer.removeAll();
                    gridLayer.removeAll();
                    selectedRoads = null;
                    processedIds = {}; // ล้าง ID ที่เคยประมวลผล
                    processCount = 0; // รีเซ็ตการนับจำนวนครั้ง
                    document.getElementById("processingStats").style.display = "none";
                    
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                    
                    if (!name) {
                        exportButton.disabled = true;
                        previewButton.disabled = true;
                        roadsLayer.definitionExpression = "1=1";
                        boundariesLayer.definitionExpression = "1=1";
                        return;
                    }

                    exportButton.disabled = true;
                    previewButton.disabled = false;
                    boundariesLayer.definitionExpression = `NAME = '${name}'`;

                    const query = boundariesLayer.createQuery();
                    query.where = `NAME = '${name}'`;
                    query.returnGeometry = true;
                    
                    try {
                        // แสดงการโหลด
                        loadingMessage.style.display = "block";
                        loadingMessage.textContent = "กำลังโหลดขอบเขตผังที่เลือก...";
                        
                        const results = await boundariesLayer.queryFeatures(query);
                        if (results.features.length > 0) {
                            currentBoundaryGeometry = results.features[0].geometry;
                            view.goTo(currentBoundaryGeometry.extent.expand(1.2));
                            
                            // เริ่มประมวลผลหลังจากที่แผนที่ซูมเข้าไปที่ขอบเขตแล้ว
                            view.when(() => {
                                processRoadsByGrid(currentBoundaryGeometry, 'boundary');
                            });
                        } else {
                            loadingMessage.textContent = "ไม่พบข้อมูลขอบเขตผังที่เลือก";
                            setTimeout(() => {
                                loadingMessage.style.display = "none";
                            }, 3000);
                        }
                    } catch (error) {
                        console.error("Error querying features:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการโหลดข้อมูล";
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);
                    }
                }

                // เพิ่มการเชื่อมโยงปุ่ม "ประมวลผลซ้ำ" กับฟังก์ชัน
                document.getElementById("gridProcessButton").addEventListener("click", function() {
                    // เรียกฟังก์ชันประมวลผลซ้ำโดยใช้พื้นที่เดิม
                    if (currentBoundaryGeometry) {
                        // กรณีเลือกจากเมนู dropdown
                        processRoadsByGrid(currentBoundaryGeometry, 'boundary');
                    } else if (selectionLayer.graphics.length > 0) {
                        // กรณีวาดพื้นที่เอง
                        const geometry = selectionLayer.graphics.getItemAt(0).geometry;
                        processRoadsByGrid(geometry, 'draw');
                    } else {
                        // แจ้งเตือนกรณีไม่มีพื้นที่เลือก
                        loadingMessage.style.display = "block";
                        loadingMessage.textContent = "กรุณาเลือกขอบเขตหรือวาดพื้นที่ก่อนประมวลผลซ้ำ";
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);
                    }
                });

                // Event listeners
                document.getElementById("searchInput").addEventListener("input", filterBoundaries);
                document.getElementById("boundarySelect").addEventListener("change", function(e) {
                    handleBoundarySelect(e.target.value);
                });
                document.getElementById("previewButton").addEventListener("click", previewExportRoads);
                document.getElementById("exportButton").addEventListener("click", exportRoadsToGeoJSON);
                
                // Initialize
                view.when(() => {
                    loadBoundaries();
                    view.ui.add(sketch, {
                        position: "manual"
                    });
                    
                    const layerList = new LayerList({
                        view: view
                    });

                    const legend = new Legend({
                        view: view
                    });

                    view.ui.add(layerList, "top-right");
                    view.ui.add(legend, "bottom-right");
                    
                    // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อแผนที่โหลดเสร็จ
                    checkRoadLayerGeometryType();
                    
                    // เพิ่มข้อความต้อนรับและคำแนะนำ
                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "ยินดีต้อนรับ! กรุณาเลือกขอบเขตผังจากรายการหรือใช้เครื่องมือวาดพื้นที่";
                    setTimeout(() => {
                        loadingMessage.style.display = "none";
                    }, 5000);
                });
                
                // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อมีการเปลี่ยนแปลงเลเยอร์
                roadsLayer.when(() => {
                    checkRoadLayerGeometryType();
                });
            }
        });
    </script>
</body>
</html>