<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>แผนที่ขอบเขตผังและถนน</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <style>
        html, body, #mapDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        /* Search Container */
        #searchContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 300px;
        }

        /* Grid Process Container */
        #gridProcessContainer {
            position: absolute;
            top: 20px;
            left: 340px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 250px;
            display: none;
        }

        .status-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        /* Draw Tools */
        #drawTools {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 180px;
        }

        /* Widgets */
        .esri-layer-list {
            position: absolute;
            top: 20px;
            right: 220px;
            max-height: calc(100vh - 240px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            max-height: 200px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-sketch {
            position: absolute;
            top: 100px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Form Elements */
        .search-input, .search-select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .search-input:focus, .search-select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        /* Buttons */
        .button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #previewButton {
            background-color: #2196F3;
            color: white;
        }

        #previewButton:hover {
            background-color: #1976D2;
        }

        #exportButton {
            background-color: #4CAF50;
            color: white;
        }

        #exportButton:hover {
            background-color: #45a049;
        }

        #gridProcessButton {
            background-color: #FF9800;
            color: white;
            display: none;
        }

        #gridProcessButton:hover {
            background-color: #F57C00;
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Tool Buttons */
        .tool-button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
        }

        .tool-button.active {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .tool-button:hover {
            background-color: #f0f0f0;
        }

        .tool-button.active:hover {
            background-color: #1976D2;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Status Messages */
        #loadingMessage, #gridStatus {
            color: #666;
            margin-top: 5px;
            font-size: 0.9em;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: none;
        }

        /* Layer Type Info */
        #layerTypeInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 2;
            min-width: 200px;
        }

        .type-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .type-polygon {
            background-color: #4CAF50;
        }

        .type-polyline {
            background-color: #2196F3;
        }

        .type-unknown {
            background-color: #FF5722;
        }

        /* Responsive Adjustments */
        @media screen and (max-height: 800px) {
            .esri-layer-list {
                max-height: calc(100vh - 400px);
            }
            .esri-legend {
                max-height: 150px;
            }
        }
    </style>
</head>
<body>
    <div id="searchContainer">
        <input type="text" id="searchInput" class="search-input" placeholder="ค้นหาขอบเขตผัง...">
        <select id="boundarySelect" class="search-select">
            <option value="">เลือกขอบเขตผัง</option>
        </select>
        <button id="previewButton" class="button" disabled>แสดงตัวอย่างถนนที่จะส่งออก</button>
        <button id="gridProcessButton" class="button">ประมวลผลใหม่ด้วยกริด</button>
        <button id="exportButton" class="button" disabled>ส่งออก GeoJSON</button>
        <div id="loadingMessage">กำลังโหลดข้อมูล...</div>
    </div>

    <div id="gridProcessContainer">
        <h3 style="margin: 0 0 10px 0; font-size: 14px;">การประมวลผลด้วยกริด</h3>
        <div id="gridStatus" class="status-text"></div>
        <div class="progress-bar">
            <div class="progress-bar-fill"></div>
        </div>
        <div id="gridDetails" class="status-text"></div>
    </div>

    <div id="drawTools">
        <button id="drawPolygonButton" class="tool-button">วาดพื้นที่เลือก</button>
        <button id="clearSelectionButton" class="tool-button">ล้างการเลือก</button>
    </div>

    <div id="mapDiv"></div>

    <script src="https://js.arcgis.com/4.28/"></script>
    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/layers/GraphicsLayer",
            "esri/geometry/geometryEngine",
            "esri/rest/support/Query",
            "esri/geometry/Polygon",
            "esri/widgets/LayerList",
            "esri/widgets/Legend",
            "esri/widgets/Sketch",
            "esri/Graphic",
            "esri/geometry/support/webMercatorUtils",
            "esri/geometry/SpatialReference",
            "esri/geometry/projection"
        ], function(
            Map, MapView, FeatureLayer, GraphicsLayer, geometryEngine, 
            Query, Polygon, LayerList, Legend, Sketch, Graphic, 
            webMercatorUtils, SpatialReference, projection
        ) {
            // Load the projection engine
            projection.load().then(() => {
                initializeApp();
            });

            function initializeApp() {
                const loadingMessage = document.getElementById("loadingMessage");
                const gridStatus = document.getElementById("gridStatus");
                const gridDetails = document.getElementById("gridDetails");
                const exportButton = document.getElementById("exportButton");
                const previewButton = document.getElementById("previewButton");
                const gridProcessButton = document.getElementById("gridProcessButton");
                const progressBar = document.querySelector(".progress-bar");
                const progressBarFill = document.querySelector(".progress-bar-fill");
                let selectedRoads = null;
                let currentBoundaryGeometry = null;
                // ตัวแปรเก็บประเภทของ geometry
                let roadGeometryType = "polyline"; // ค่าเริ่มต้นเป็น polyline

                const map = new Map({
                    basemap: "streets"
                });

                const view = new MapView({
                    container: "mapDiv",
                    map: map,
                    center: [100.5234, 13.7563],
                    zoom: 6
                });

                // Layers
                const selectionLayer = new GraphicsLayer({
                    title: "พื้นที่ที่เลือก"
                });

                const gridLayer = new GraphicsLayer({
                    title: "กริดการประมวลผล"
                });

                const roadsLayer = new FeatureLayer({
                    url: "https://tcpebps.dpt.go.th/arcgis/rest/services/service/BLGD/MapServer/0",
                    outFields: ["*"],
                    title: "ถนน",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-line",
                            color: [0, 0, 0],
                            width: "1.5px"
                        }
                    }
                });

                const exportPreviewLayer = new GraphicsLayer({
                    title: "ถนนที่จะส่งออก",
                    visible: false
                });

                const boundariesLayer = new FeatureLayer({
                    url: "https://dptgis.dpt.go.th/arcgis/rest/services/Compbnd/MapServer/0",
                    outFields: ["*"],
                    title: "ขอบเขตผัง",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-fill",
                            color: [0, 0, 0, 0],
                            outline: {
                                color: [255, 0, 0],
                                width: 2
                            }
                        }
                    }
                });

                map.addMany([roadsLayer, exportPreviewLayer, boundariesLayer, selectionLayer, gridLayer]);

                // เพิ่มฟังก์ชันตรวจสอบประเภทของชั้นข้อมูลถนน
                function checkRoadLayerGeometryType() {
                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังตรวจสอบประเภทชั้นข้อมูลถนน...";
                    
                    roadsLayer.queryFeatures({
                        where: "1=1",
                        returnGeometry: true,
                        outFields: ["*"],
                        num: 1
                    }).then(function(result) {
                        if (result.features.length > 0) {
                            const geometry = result.features[0].geometry;
                            
                            if (geometry.type === "polygon") {
                                roadGeometryType = "polygon";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Polygon";
                            } else if (geometry.type === "polyline") {
                                roadGeometryType = "polyline";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Line";
                            } else {
                                roadGeometryType = "unknown";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: " + geometry.type;
                            }
                            
                            // แสดงข้อความแจ้งเตือนผู้ใช้
                            const geometryInfoDiv = document.createElement("div");
                            geometryInfoDiv.id = "geometryInfoDiv";
                            geometryInfoDiv.style.position = "absolute";
                            geometryInfoDiv.style.bottom = "20px";
                            geometryInfoDiv.style.left = "20px";
                            geometryInfoDiv.style.backgroundColor = "#f8f9fa";
                            geometryInfoDiv.style.border = "1px solid #ddd";
                            geometryInfoDiv.style.borderRadius = "8px";
                            geometryInfoDiv.style.padding = "10px";
                            geometryInfoDiv.style.zIndex = "10";
                            geometryInfoDiv.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
                            geometryInfoDiv.style.maxWidth = "300px";
                            
                            if (roadGeometryType === "polygon") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Polygon</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะรักษารูปแบบ Polygon และโครงสร้างข้อมูลต้นฉบับ</p>
                                `;
                            } else if (roadGeometryType === "polyline") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Line</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะอยู่ในรูปแบบ LineString</p>
                                `;
                            } else {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #FF5722;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: <strong>${geometry.type}</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">อาจเกิดข้อผิดพลาดในการส่งออกข้อมูล</p>
                                `;
                            }
                            
                            // ลบข้อความเดิมถ้ามี
                            const existingInfo = document.getElementById("geometryInfoDiv");
                            if (existingInfo) {
                                existingInfo.remove();
                            }
                            
                            document.body.appendChild(geometryInfoDiv);
                        }
                        
                        loadingMessage.style.display = "none";
                    }).catch(function(error) {
                        console.error("Error checking road layer geometry type:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการตรวจสอบประเภทชั้นข้อมูล";
                        roadGeometryType = "unknown";
                        loadingMessage.style.display = "none";
                    });
                }

                // Grid Processing Functions
                function createGridCells(extent) {
                    const gridSize = 2000; // 2000 meters
                    const grids = [];
                    
                    // Convert extent to UTM Zone 47N for accurate measurements
                    const utmExtent = projection.project(extent, new SpatialReference({ wkid: 32647 }));
                    
                    const xmin = Math.floor(utmExtent.xmin / gridSize) * gridSize;
                    const ymin = Math.floor(utmExtent.ymin / gridSize) * gridSize;
                    const xmax = Math.ceil(utmExtent.xmax / gridSize) * gridSize;
                    const ymax = Math.ceil(utmExtent.ymax / gridSize) * gridSize;
                    
                    for (let x = xmin; x < xmax; x += gridSize) {
                        for (let y = ymin; y < ymax; y += gridSize) {
                            const gridPolygon = new Polygon({
                                rings: [[[x, y], [x + gridSize, y], [x + gridSize, y + gridSize], [x, y + gridSize], [x, y]]],
                                spatialReference: { wkid: 32647 }
                            });
                            
                            // Project back to web mercator for display
                            const displayPolygon = projection.project(gridPolygon, view.spatialReference);
                            grids.push(displayPolygon);
                        }
                    }
                    
                    return grids;
                }

                async function processRoadsByGrid(geometry, type = 'boundary') {
                    gridLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    selectedRoads = [];
                    
                    // Show grid process container
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'block';
                    
                    try {
                        const grids = createGridCells(geometry.extent);
                        const totalGrids = grids.length;
                        let processedCount = 0;
                        let totalRoads = 0;
                        
                        gridStatus.textContent = `เริ่มประมวลผลกริด`;
                        gridDetails.textContent = `0/${totalGrids} กริด`;
                        progressBarFill.style.width = '0%';
                        
                        for (const [index, grid] of grids.entries()) {
                            const gridGraphic = new Graphic({
                                geometry: grid,
                                symbol: {
                                    type: "simple-fill",
                                    color: [255, 165, 0, 0.2],
                                    outline: {
                                        color: [255, 165, 0],
                                        width: 1
                                    }
                                }
                            });
                            gridLayer.add(gridGraphic);
                            
                            const query = roadsLayer.createQuery();
                            query.geometry = grid;
                            query.spatialRelationship = "intersects";
                            query.returnGeometry = true;
                            query.outFields = ["*"];
                            
                            try {
                                const result = await roadsLayer.queryFeatures(query);
                                let validRoads = result.features;
                                
                                if (type === 'draw') {
                                    validRoads = result.features.filter(road => 
                                        geometryEngine.intersects(road.geometry, geometry)
                                    );
                                }
                                
                                selectedRoads = selectedRoads.concat(validRoads);
                                totalRoads += validRoads.length;
                                
                                processedCount = index + 1;
                                const progress = (processedCount / totalGrids) * 100;
                                progressBarFill.style.width = `${progress}%`;
                                
                                gridStatus.textContent = `กำลังประมวลผล...`;
                                gridDetails.textContent = `${processedCount}/${totalGrids} กริด (พบถนน ${totalRoads.toLocaleString()} เส้น)`;
                                
                                gridGraphic.symbol = {
                                    type: "simple-fill",
                                    color: [76, 175, 80, 0.2],
                                    outline: {
                                        color: [76, 175, 80],
                                        width: 1
                                    }
                                };
                                
                            } catch (error) {
                                console.error("Error processing grid:", error);
                                gridGraphic.symbol = {
                                    type: "simple-fill",
                                    color: [255, 0, 0, 0.2],
                                    outline: {
                                        color: [255, 0, 0],
                                        width: 1
                                    }
                                };
                            }
                        }
                        
                        gridStatus.textContent = "ประมวลผลเสร็จสิ้น";
                        gridDetails.textContent = `พบถนนทั้งหมด ${totalRoads.toLocaleString()} เส้น`;
                        
                        previewButton.disabled = false;
                        await previewExportRoads();
                        
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                        }, 3000);
                        
                    } catch (error) {
                        console.error("Error in grid processing:", error);
                        gridStatus.textContent = "เกิดข้อผิดพลาดในการประมวลผล";
                    }
                }

                // Sketch Widget
                const sketch = new Sketch({
                    view: view,
                    layer: selectionLayer,
                    creationMode: "single",
                    availableCreateTools: ["polygon"],
                    visibleElements: {
                        createTools: {
                            point: false,
                            polyline: false,
                            rectangle: false,
                            circle: false
                        },
                        selectionTools: {
                            "lasso-selection": false,
                            "rectangle-selection": false
                        },
                        settingsMenu: false,
                        undoRedoMenu: false
                    }
                });

                const layerList = new LayerList({
                    view: view
                });

                const legend = new Legend({
                    view: view
                });

                view.ui.add(layerList, "top-right");
                view.ui.add(legend, "bottom-right");

                const drawPolygonButton = document.getElementById("drawPolygonButton");
                const clearSelectionButton = document.getElementById("clearSelectionButton");
                let isDrawing = false;

                // ปรับฟังก์ชัน previewExportRoads สำหรับการแสดงผลตามประเภทข้อมูล
                async function previewExportRoads() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังวิเคราะห์ข้อมูล...";
                    previewButton.disabled = true;

                    try {
                        exportPreviewLayer.removeAll();
                        
                        const totalRoads = selectedRoads.length;
                        loadingMessage.textContent = `พบเส้นทาง/พื้นที่ทั้งหมด ${totalRoads.toLocaleString()} รายการ`;

                        const processVisibleRoads = async () => {
                            const viewExtent = view.extent;
                            
                            const batchSize = 5000;
                            const chunks = [];
                            
                            for (let i = 0; i < selectedRoads.length; i += batchSize) {
                                chunks.push(selectedRoads.slice(i, i + batchSize));
                            }

                            const processChunk = async (roads) => {
                                return roads
                                    .filter(road => geometryEngine.intersects(road.geometry, viewExtent))
                                    .map(road => {
                                        let priority = 0;
                                        
                                        if (roadGeometryType === "polygon") {
                                            // ใช้พื้นที่เป็นตัวกำหนดความสำคัญสำหรับ polygon
                                            priority = geometryEngine.geodesicArea(road.geometry, "square-meters") || 0;
                                        } else {
                                            // ใช้ความยาวเป็นตัวกำหนดความสำคัญสำหรับ line
                                            priority = road.geometry.length || 0;
                                        }
                                        
                                        return {
                                            road,
                                            priority: priority,
                                            width: road.attributes.WIDTH || 0
                                        };
                                    });
                            };

                            const maxConcurrentProcessing = 4;
                            let processedRoads = [];
                            
                            for (let i = 0; i < chunks.length; i += maxConcurrentProcessing) {
                                const currentChunks = chunks.slice(i, i + maxConcurrentProcessing);
                                const results = await Promise.all(
                                    currentChunks.map(async (chunk, index) => {
                                        const result = await processChunk(chunk);
                                        const progress = Math.round(((i + index + 1) / chunks.length) * 100);
                                        loadingMessage.textContent = `กำลังวิเคราะห์ข้อมูล... ${progress}%`;
                                        return result;
                                    })
                                );
                                processedRoads = processedRoads.concat(results.flat());
                            }

                            processedRoads.sort((a, b) => {
                                const aPriority = (a.priority * 0.7) + (a.width * 0.3);
                                const bPriority = (b.priority * 0.7) + (b.width * 0.3);
                                return bPriority - aPriority;
                            });

                            const highPriority = processedRoads.slice(0, Math.min(20000, processedRoads.length));
                            const mediumPriority = processedRoads.slice(20000, Math.min(60000, processedRoads.length));
                            const lowPriority = processedRoads.slice(60000);

                            const createGraphicsBatch = async (roads, symbolWidth, delay = 0) => {
                                const graphicsBatchSize = 2000;
                                let graphics = [];

                                for (let i = 0; i < roads.length; i += graphicsBatchSize) {
                                    const batch = roads.slice(i, i + graphicsBatchSize);
                                    
                                    const batchGraphics = batch.map(item => {
                                        let symbol;
                                        
                                        if (roadGeometryType === "polygon") {
                                            // สัญลักษณ์สำหรับ polygon
                                            symbol = {
                                                type: "simple-fill",
                                                color: [255, 0, 0, 0.5],
                                                outline: {
                                                    color: [255, 0, 0],
                                                    width: symbolWidth
                                                }
                                            };
                                        } else {
                                            // สัญลักษณ์สำหรับ line
                                            symbol = {
                                                type: "simple-line",
                                                color: [255, 0, 0],
                                                width: symbolWidth
                                            };
                                        }
                                        
                                        return new Graphic({
                                            geometry: item.road.geometry,
                                            attributes: item.road.attributes,
                                            symbol: symbol
                                        });
                                    });

                                    graphics = graphics.concat(batchGraphics);
                                    
                                    if (graphics.length >= 10000 || i + graphicsBatchSize >= roads.length) {
                                        exportPreviewLayer.addMany(graphics);
                                        graphics = [];
                                                                            
                                        if (delay > 0) {
                                            await new Promise(resolve => setTimeout(resolve, delay));
                                        }
                                    }
                                }
                            };

                            const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                            
                            loadingMessage.textContent = `กำลังแสดง${itemTypeName}หลัก...`;
                            await createGraphicsBatch(highPriority, roadGeometryType === "polygon" ? "1.5px" : "2.5px", 1);
                            
                            loadingMessage.textContent = `กำลังแสดง${itemTypeName}รอง...`;
                            await createGraphicsBatch(mediumPriority, roadGeometryType === "polygon" ? "1px" : "1.5px", 2);
                            
                            if (lowPriority.length > 0) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}ย่อย...`;
                                await createGraphicsBatch(lowPriority, roadGeometryType === "polygon" ? "0.5px" : "1px", 3);
                            }
                        };

                        let updateTimeout;
                        const debouncedUpdate = () => {
                            clearTimeout(updateTimeout);
                            updateTimeout = setTimeout(async () => {
                                exportPreviewLayer.removeAll();
                                await processVisibleRoads();
                            }, 800);
                        };

                        await processVisibleRoads();
                        
                        view.watch("extent", debouncedUpdate);
                        view.watch("rotation", debouncedUpdate);

                        exportPreviewLayer.visible = true;
                        exportButton.disabled = false;

                        const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                        loadingMessage.textContent = `พร้อมส่งออกข้อมูล${itemTypeName} ${totalRoads.toLocaleString()} รายการ`;
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);

                    } catch (error) {
                        console.error("Error previewing roads:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการสร้างตัวอย่าง";
                    } finally {
                        previewButton.disabled = false;
                    }
                }

                // เปลี่ยนฟังก์ชัน exportRoadsToGeoJSON เพื่อรองรับทั้ง polyline และ polygon
                async function exportRoadsToGeoJSON() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังส่งออกข้อมูล...";

                    try {
                        const name = document.getElementById("boundarySelect").value || "selected_area";
                        
                        const utmSR = new SpatialReference({
                            wkid: 32647
                        });

                        const geojson = {
                            type: "FeatureCollection",
                            name: `roads_${name}`,
                            crs: {
                                type: "name",
                                properties: {
                                    name: "EPSG:32647"
                                }
                            },
                            features: await Promise.all(selectedRoads.map(async feature => {
                                const utmGeometry = projection.project(
                                    feature.geometry,
                                    utmSR
                                );
                                
                                let geometryObject;
                                let lengthField = 0;
                                
                                if (roadGeometryType === "polygon") {
                                    // กรณีเป็น Polygon
                                    geometryObject = {
                                        type: "Polygon",
                                        coordinates: utmGeometry.rings
                                    };
                                    
                                    // คำนวณพื้นที่ในกรณีเป็น Polygon
                                    if (feature.geometry.rings) {
                                        lengthField = geometryEngine.geodesicArea(feature.geometry, "square-meters");
                                    }
                                } else {
                                    // กรณีเป็น LineString (ค่าเริ่มต้น)
                                    geometryObject = {
                                        type: "LineString",
                                        coordinates: utmGeometry.paths ? utmGeometry.paths[0] : []
                                    };
                                    
                                    // คำนวณความยาวในกรณีเป็น Line
                                    lengthField = feature.geometry.length || 0;
                                }
                                
                                return {
                                    type: "Feature",
                                    geometry: geometryObject,
                                    properties: {
                                        ...feature.attributes,
                                        length_m: lengthField,
                                        road_id: feature.attributes.OBJECTID || feature.attributes.FID || null,
                                        geometry_type: roadGeometryType,
                                        style: {
                                            color: "#FF0000",
                                            weight: 2
                                        }
                                    }
                                };
                            }))
                        };

                        const blob = new Blob([JSON.stringify(geojson, null, 2)], { 
                            type: "application/json" 
                        });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement("a");
                        a.href = url;
                        a.download = `roads_${name}_utm47n_${new Date().getTime()}.geojson`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        loadingMessage.style.display = "none";
                    } catch (error) {
                        console.error("Error exporting data:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการส่งออกข้อมูล";
                    }
                }

                function toggleDrawingMode() {
                    isDrawing = !isDrawing;
                    drawPolygonButton.classList.toggle("active");
                    if (isDrawing) {
                        sketch.create("polygon");
                    } else {
                        sketch.cancel();
                    }
                }

                function clearSelection() {
                    selectionLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    gridLayer.removeAll();
                    selectedRoads = null;
                    exportButton.disabled = true;
                    previewButton.disabled = true;
                    gridProcessButton.style.display = 'none';
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                }

                // Event Handlers
                drawPolygonButton.addEventListener("click", toggleDrawingMode);
                clearSelectionButton.addEventListener("click", clearSelection);

                sketch.on("create", async (event) => {
                    if (event.state === "complete") {
                        const polygon = event.graphic.geometry;
                        await processRoadsByGrid(polygon, 'draw');
                        isDrawing = false;
                        drawPolygonButton.classList.remove("active");
                    }
                });

                function updateSelectOptions(boundaries) {
                    const select = document.getElementById("boundarySelect");
                    select.innerHTML = '<option value="">เลือกขอบเขตผัง</option>';
                    
                    boundaries.forEach(name => {
                        const option = document.createElement("option");
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });
                }

                function loadBoundaries() {
                    const query = new Query({
                        where: "1=1",
                        outFields: ["NAME"],
                        returnDistinctValues: true,
                        returnGeometry: false
                    });

                    boundariesLayer.queryFeatures(query)
                        .then(function(results) {
                            const select = document.getElementById("boundarySelect");
                            const boundaries = results.features
                                .map(feature => feature.attributes.NAME)
                                .filter(name => name)
                                .sort();
                            
                            select.dataset.allBoundaries = JSON.stringify(boundaries);
                            updateSelectOptions(boundaries);
                            loadingMessage.style.display = "none";
                        })
                        .catch(function(error) {
                            console.error("Error loading boundaries:", error);
                            loadingMessage.textContent = "เกิดข้อผิดพลาดในการโหลดข้อมูล";
                        });
                }

                function filterBoundaries() {
                    const input = document.getElementById("searchInput");
                    const select = document.getElementById("boundarySelect");
                    const searchTerm = input.value.toLowerCase();
                    
                    const allBoundaries = JSON.parse(select.dataset.allBoundaries || '[]');
                    const filteredBoundaries = allBoundaries.filter(name => 
                        name.toLowerCase().includes(searchTerm)
                    );
                    
                    updateSelectOptions(filteredBoundaries);
                }

                async function handleBoundarySelect(name) {
                    exportPreviewLayer.removeAll();
                    selectionLayer.removeAll();
                    gridLayer.removeAll();
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                    
                    if (!name) {
                        exportButton.disabled = true;
                        previewButton.disabled = true;
                        roadsLayer.definitionExpression = "1=1";
                        boundariesLayer.definitionExpression = "1=1";
                        return;
                    }

                    exportButton.disabled = true;
                    previewButton.disabled = false;
                    boundariesLayer.definitionExpression = `NAME = '${name}'`;

                    const query = boundariesLayer.createQuery();
                    query.where = `NAME = '${name}'`;
                    query.returnGeometry = true;
                    
                    try {
                        const results = await boundariesLayer.queryFeatures(query);
                        if (results.features.length > 0) {
                            currentBoundaryGeometry = results.features[0].geometry;
                            view.goTo(currentBoundaryGeometry.extent.expand(1.2));
                            await processRoadsByGrid(currentBoundaryGeometry, 'boundary');
                        }
                    } catch (error) {
                        console.error("Error querying features:", error);
                    }
                }

                // Event listeners
                document.getElementById("searchInput").addEventListener("input", filterBoundaries);
                document.getElementById("boundarySelect").addEventListener("change", function(e) {
                    handleBoundarySelect(e.target.value);
                });
                document.getElementById("previewButton").addEventListener("click", previewExportRoads);
                document.getElementById("exportButton").addEventListener("click", exportRoadsToGeoJSON);
                
                // Initialize
                view.when(() => {
                    loadBoundaries();
                    view.ui.add(sketch, {
                        position: "manual"
                    });
                    
                    // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อแผนที่โหลดเสร็จ
                    checkRoadLayerGeometryType();
                });
                
                // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อมีการเปลี่ยนแปลงเลเยอร์
                roadsLayer.when(() => {
                    checkRoadLayerGeometryType();
                });
            }
        });
    </script>
</body>
</html>