<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>แผนที่ขอบเขตผังและถนน</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css">
    <style>
        html, body, #mapDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }

        /* Search Container */
        #searchContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 300px;
        }

        /* Grid Process Container */
        #gridProcessContainer {
            position: absolute;
            top: 20px;
            left: 340px;
            z-index: 2;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 250px;
            display: none;
        }

        .status-text {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        /* Draw Tools */
        #drawTools {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 2;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 180px;
        }

        /* Widgets */
        .esri-layer-list {
            position: absolute;
            top: 20px;
            right: 220px;
            max-height: calc(100vh - 240px);
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            max-height: 200px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .esri-sketch {
            position: absolute;
            top: 100px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        /* Form Elements */
        .search-input, .search-select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .search-input:focus, .search-select:focus {
            outline: none;
            border-color: #4CAF50;
        }

        /* Buttons */
        .button {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease;
        }

        #previewButton {
            background-color: #2196F3;
            color: white;
        }

        #previewButton:hover {
            background-color: #1976D2;
        }

        #exportButton {
            background-color: #4CAF50;
            color: white;
        }

        #exportButton:hover {
            background-color: #45a049;
        }

        #gridProcessButton {
            background-color: #FF5722;
            color: white;
        }

        #gridProcessButton:hover {
            background-color: #E64A19;
        }

        .button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Tool Buttons */
        .tool-button {
            width: 100%;
            padding: 8px;
            margin: 4px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background-color: #fff;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
        }

        .tool-button.active {
            background-color: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .tool-button:hover {
            background-color: #f0f0f0;
        }

        .tool-button.active:hover {
            background-color: #1976D2;
        }

        /* Progress Bar */
        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Status Messages */
        #loadingMessage, #gridStatus {
            color: #666;
            margin-top: 5px;
            font-size: 0.9em;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: none;
        }

        /* Processing Stats Box */
        #processingStats {
            margin: 10px 0;
            padding: 8px;
            background-color: #f5f5f5;
            border-radius: 4px;
            display: none;
            border-left: 3px solid #FF5722;
        }

        /* Layer Type Info */
        #layerTypeInfo {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 2;
            min-width: 200px;
        }

        .type-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .type-polygon {
            background-color: #4CAF50;
        }

        .type-polyline {
            background-color: #2196F3;
        }

        .type-unknown {
            background-color: #FF5722;
        }

        /* Responsive Adjustments */
        @media screen and (max-height: 800px) {
            .esri-layer-list {
                max-height: calc(100vh - 400px);
            }
            .esri-legend {
                max-height: 150px;
            }
        }

        /* Added: Warning and info banners */
        .info-banner {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 15px;
            background-color: rgba(33, 150, 243, 0.9);
            color: white;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            max-width: 80%;
            text-align: center;
            font-size: 14px;
        }

        .warning-banner {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 15px;
            background-color: rgba(255, 87, 34, 0.9);
            color: white;
            border-radius: 8px;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            display: none;
            max-width: 80%;
            text-align: center;
            font-size: 14px;
        }

        /* Added: Debug panel */
        #debugPanel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            width: 300px;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            z-index: 10;
        }

        #debugToggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255,255,255,0.8);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            cursor: pointer;
            font-size: 12px;
            z-index: 9;
        }
    </style>
</head>
<body>
    <div id="searchContainer">
        <input type="text" id="searchInput" class="search-input" placeholder="ค้นหาขอบเขตผัง...">
        <select id="boundarySelect" class="search-select">
            <option value="">เลือกขอบเขตผัง</option>
        </select>
        <button id="previewButton" class="button" disabled>แสดงตัวอย่างถนนที่จะส่งออก</button>
        <button id="gridProcessButton" class="button">ประมวลผลซ้ำเพื่อดึงข้อมูลเพิ่มเติม</button>
        <button id="exportButton" class="button" disabled>ส่งออก GeoJSON</button>
        <div id="loadingMessage">กำลังโหลดข้อมูล...</div>
        <div id="processingStats">
            <div style="font-weight: bold; margin-bottom: 5px;">สถิติการประมวลผล</div>
            <div id="processCount">จำนวนครั้งที่ประมวลผล: 1</div>
            <div id="totalFeaturesCount">จำนวนข้อมูลทั้งหมด: 0</div>
            <div id="newFeaturesCount">จำนวนข้อมูลใหม่: 0</div>
        </div>
    </div>

    <div id="gridProcessContainer">
        <h3 style="margin: 0 0 10px 0; font-size: 14px;">การประมวลผลด้วยกริด</h3>
        <div id="gridStatus" class="status-text"></div>
        <div class="progress-bar">
            <div class="progress-bar-fill"></div>
        </div>
        <div id="gridDetails" class="status-text"></div>
    </div>

    <div id="drawTools">
        <button id="drawPolygonButton" class="tool-button">วาดพื้นที่เลือก</button>
        <button id="clearSelectionButton" class="tool-button">ล้างการเลือก</button>
    </div>

    <div id="mapDiv"></div>
    
    <!-- Added: Warning and info banners -->
    <div id="warningBanner" class="warning-banner"></div>
    <div id="infoBanner" class="info-banner"></div>
    
    <!-- Added: Debug panel -->
    <button id="debugToggle">Debug</button>
    <div id="debugPanel">
        <h4 style="margin-top: 0;">Debug Information</h4>
        <div id="debugContent"></div>
    </div>

    <script src="https://js.arcgis.com/4.28/"></script>
    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/layers/GraphicsLayer",
            "esri/geometry/geometryEngine",
            "esri/rest/support/Query",
            "esri/geometry/Polygon",
            "esri/widgets/LayerList",
            "esri/widgets/Legend",
            "esri/widgets/Sketch",
            "esri/Graphic",
            "esri/geometry/support/webMercatorUtils",
            "esri/geometry/SpatialReference",
            "esri/geometry/projection"
        ], function(
            Map, MapView, FeatureLayer, GraphicsLayer, geometryEngine, 
            Query, Polygon, LayerList, Legend, Sketch, Graphic, 
            webMercatorUtils, SpatialReference, projection
        ) {
            // Load the projection engine
            projection.load().then(() => {
                initializeApp();
            });

            function initializeApp() {
                const loadingMessage = document.getElementById("loadingMessage");
                const gridStatus = document.getElementById("gridStatus");
                const gridDetails = document.getElementById("gridDetails");
                const exportButton = document.getElementById("exportButton");
                const previewButton = document.getElementById("previewButton");
                const gridProcessButton = document.getElementById("gridProcessButton");
                const progressBar = document.querySelector(".progress-bar");
                const progressBarFill = document.querySelector(".progress-bar-fill");
                let selectedRoads = null;
                let currentBoundaryGeometry = null;
                // ตัวแปรเก็บประเภทของ geometry
                let roadGeometryType = "polyline"; // ค่าเริ่มต้นเป็น polyline
                
                // ตัวแปรสำหรับติดตามการประมวลผลซ้ำ
                let processCount = 0; // จำนวนครั้งที่ประมวลผล
                let processedIds = {}; // เก็บ ID ที่เคยประมวลผลแล้ว
                let previousSelectionCount = 0; // จำนวนข้อมูลก่อนการประมวลผลล่าสุด
                
                // ตัวแปรใหม่สำหรับการตรวจสอบการประมวลผล
                let isProcessing = false; // สถานะกำลังประมวลผล
                let totalFeaturesExpected = 0; // จำนวนข้อมูลที่คาดว่าจะมีทั้งหมด
                let unprocessedAreaGrids = []; // เก็บกริดที่ยังไม่ได้ประมวลผล

                const map = new Map({
                    basemap: "streets"
                });

                const view = new MapView({
                    container: "mapDiv",
                    map: map,
                    center: [100.5234, 13.7563],
                    zoom: 6
                });

                // Layers
                const selectionLayer = new GraphicsLayer({
                    title: "พื้นที่ที่เลือก"
                });

                const gridLayer = new GraphicsLayer({
                    title: "กริดการประมวลผล"
                });

                const roadsLayer = new FeatureLayer({
                    url: "https://tcpebps.dpt.go.th/arcgis/rest/services/service/BLGD/MapServer/0",
                    outFields: ["*"],
                    title: "ถนน",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-line",
                            color: [0, 0, 0],
                            width: "1.5px"
                        }
                    }
                });

                const exportPreviewLayer = new GraphicsLayer({
                    title: "ถนนที่จะส่งออก",
                    visible: false
                });

                const boundariesLayer = new FeatureLayer({
                    url: "https://dptgis.dpt.go.th/arcgis/rest/services/Compbnd/MapServer/0",
                    outFields: ["*"],
                    title: "ขอบเขตผัง",
                    renderer: {
                        type: "simple",
                        symbol: {
                            type: "simple-fill",
                            color: [0, 0, 0, 0],
                            outline: {
                                color: [255, 0, 0],
                                width: 2
                            }
                        }
                    }
                });

                map.addMany([roadsLayer, exportPreviewLayer, boundariesLayer, selectionLayer, gridLayer]);

                // เพิ่มฟังก์ชันสำหรับแสดง debug logs
                function debugLog(message, type = 'info') {
                    const debugContent = document.getElementById('debugContent');
                    if (debugContent) {
                        const timestamp = new Date().toLocaleTimeString();
                        const logElement = document.createElement('div');
                        logElement.style.borderBottom = '1px solid #eee';
                        logElement.style.padding = '3px 0';
                        logElement.style.fontSize = '12px';
                        
                        if (type === 'error') {
                            logElement.style.color = '#F44336';
                        } else if (type === 'warning') {
                            logElement.style.color = '#FF9800';
                        } else if (type === 'success') {
                            logElement.style.color = '#4CAF50';
                        }
                        
                        logElement.innerHTML = `<span style="color:#999;font-size:10px;">${timestamp}</span> ${message}`;
                        debugContent.appendChild(logElement);
                        debugContent.scrollTop = debugContent.scrollHeight;
                        
                        // จำกัดจำนวนข้อความใน debug panel
                        if (debugContent.children.length > 50) {
                            debugContent.removeChild(debugContent.children[0]);
                        }
                    }
                    
                    // Log ไปที่ console ด้วย
                    if (type === 'error') {
                        console.error(message);
                    } else if (type === 'warning') {
                        console.warn(message);
                    } else {
                        console.log(message);
                    }
                }
                
                // เพิ่มฟังก์ชันสำหรับแสดงข้อความเตือน/แจ้งเตือน
                function showNotification(message, type = 'info', duration = 3000) {
                    const banner = type === 'warning' ? document.getElementById('warningBanner') : document.getElementById('infoBanner');
                    banner.textContent = message;
                    banner.style.display = 'block';
                    
                    setTimeout(() => {
                        banner.style.display = 'none';
                    }, duration);
                }

                // ฟังก์ชัน subdivideGrid สำหรับแบ่งกริดใหญ่เป็นกริดย่อย
                function subdivideGrid(grid) {
                    const extent = grid.extent;
                    const center = extent.center;
                    
                    const xmin = extent.xmin;
                    const ymin = extent.ymin;
                    const xmax = extent.xmax;
                    const ymax = extent.ymax;
                    
                    // สร้าง 4 กริดย่อยจากจุดศูนย์กลาง
                    const nw = new Polygon({
                        rings: [[[xmin, center.y], [center.x, center.y], [center.x, ymax], [xmin, ymax], [xmin, center.y]]],
                        spatialReference: grid.spatialReference
                    });
                    
                    const ne = new Polygon({
                        rings: [[[center.x, center.y], [xmax, center.y], [xmax, ymax], [center.x, ymax], [center.x, center.y]]],
                        spatialReference: grid.spatialReference
                    });
                    
                    const sw = new Polygon({
                        rings: [[[xmin, ymin], [center.x, ymin], [center.x, center.y], [xmin, center.y], [xmin, ymin]]],
                        spatialReference: grid.spatialReference
                    });
                    
                    const se = new Polygon({
                        rings: [[[center.x, ymin], [xmax, ymin], [xmax, center.y], [center.x, center.y], [center.x, ymin]]],
                        spatialReference: grid.spatialReference
                    });
                    
                    return [nw, ne, sw, se];
                }

                // เพิ่มฟังก์ชันตรวจสอบประเภทของชั้นข้อมูลถนน
                function checkRoadLayerGeometryType() {
                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังตรวจสอบประเภทชั้นข้อมูลถนน...";
                    
                    roadsLayer.queryFeatures({
                        where: "1=1",
                        returnGeometry: true,
                        outFields: ["*"],
                        num: 1
                    }).then(function(result) {
                        if (result.features.length > 0) {
                            const geometry = result.features[0].geometry;
                            
                            if (geometry.type === "polygon") {
                                roadGeometryType = "polygon";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Polygon";
                                debugLog("ตรวจพบชั้นข้อมูลถนนเป็นประเภท Polygon", "info");
                            } else if (geometry.type === "polyline") {
                                roadGeometryType = "polyline";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภท Line";
                                debugLog("ตรวจพบชั้นข้อมูลถนนเป็นประเภท Polyline", "info");
                            } else {
                                roadGeometryType = "unknown";
                                loadingMessage.textContent = "ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: " + geometry.type;
                                debugLog(`ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: ${geometry.type}`, "warning");
                            }
                            
                            // แสดงข้อความแจ้งเตือนผู้ใช้
                            const geometryInfoDiv = document.createElement("div");
                            geometryInfoDiv.id = "geometryInfoDiv";
                            geometryInfoDiv.style.position = "absolute";
                            geometryInfoDiv.style.bottom = "20px";
                            geometryInfoDiv.style.left = "20px";
                            geometryInfoDiv.style.backgroundColor = "#f8f9fa";
                            geometryInfoDiv.style.border = "1px solid #ddd";
                            geometryInfoDiv.style.borderRadius = "8px";
                            geometryInfoDiv.style.padding = "10px";
                            geometryInfoDiv.style.zIndex = "10";
                            geometryInfoDiv.style.boxShadow = "0 2px 6px rgba(0,0,0,0.3)";
                            geometryInfoDiv.style.maxWidth = "300px";
                            
                            if (roadGeometryType === "polygon") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Polygon</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะรักษารูปแบบ Polygon และโครงสร้างข้อมูลต้นฉบับ</p>
                                `;
                            } else if (roadGeometryType === "polyline") {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #2196F3;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภท <strong>Line</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">ไฟล์ GeoJSON ที่ส่งออกจะอยู่ในรูปแบบ LineString</p>
                                `;
                            } else {
                                geometryInfoDiv.innerHTML = `
                                    <h4 style="margin: 0 0 5px 0; color: #FF5722;">ข้อมูลชั้นถนน</h4>
                                    <p style="margin: 0; font-size: 14px;">ชั้นข้อมูลถนนเป็นประเภทที่ไม่รองรับ: <strong>${geometry.type}</strong></p>
                                    <p style="margin: 5px 0 0 0; font-size: 13px; color: #666;">อาจเกิดข้อผิดพลาดในการส่งออกข้อมูล</p>
                                `;
                            }
                            
                            // ลบข้อความเดิมถ้ามี
                            const existingInfo = document.getElementById("geometryInfoDiv");
                            if (existingInfo) {
                                existingInfo.remove();
                            }
                            
                            document.body.appendChild(geometryInfoDiv);
                        }
                        
                        loadingMessage.style.display = "none";
                    }).catch(function(error) {
                        console.error("Error checking road layer geometry type:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการตรวจสอบประเภทชั้นข้อมูล";
                        roadGeometryType = "unknown";
                        loadingMessage.style.display = "none";
                        debugLog(`เกิดข้อผิดพลาดในการตรวจสอบประเภทชั้นข้อมูล: ${error.message}`, "error");
                    });
                }

                // Grid Processing Functions
                function createGridCells(extent, gridSize = 250) {  // ลดขนาดกริดเริ่มต้นเพื่อเพิ่มประสิทธิภาพ
                    const grids = [];
                    
                    // Convert extent to UTM Zone 47N for accurate measurements
                    const utmExtent = projection.project(extent, new SpatialReference({ wkid: 32647 }));
                    
                    const xmin = Math.floor(utmExtent.xmin / gridSize) * gridSize;
                    const ymin = Math.floor(utmExtent.ymin / gridSize) * gridSize;
                    const xmax = Math.ceil(utmExtent.xmax / gridSize) * gridSize;
                    const ymax = Math.ceil(utmExtent.ymax / gridSize) * gridSize;
                    
                    debugLog(`สร้างกริดในพื้นที่ UTM [${xmin}, ${ymin}, ${xmax}, ${ymax}] ขนาดกริด ${gridSize}m`);
                    
                    // สร้างกริดขนาดตามที่กำหนด
                    for (let x = xmin; x < xmax; x += gridSize) {
                        for (let y = ymin; y < ymax; y += gridSize) {
                            const gridPolygon = new Polygon({
                                rings: [[[x, y], [x + gridSize, y], [x + gridSize, y + gridSize], [x, y + gridSize], [x, y]]],
                                spatialReference: { wkid: 32647 }
                            });
                            
                            // Project back to web mercator for display
                            const displayPolygon = projection.project(gridPolygon, view.spatialReference);
                            grids.push(displayPolygon);
                        }
                    }
                    
                    // ในกรณีที่กริดมีจำนวนมาก ให้แสดงคำเตือน
                    if (grids.length > 2000) {
                        debugLog(`จำนวนกริดมากเกินไป (${grids.length} กริด) อาจมีผลต่อประสิทธิภาพ`, "warning");
                    }
                    
                    // จัดเรียงกริดจากจุดศูนย์กลางออกไป
                    const centerX = (extent.xmin + extent.xmax) / 2;
                    const centerY = (extent.ymin + extent.ymax) / 2;
                    
                    // คำนวณระยะห่างจากศูนย์กลางให้กับแต่ละกริด
                    grids.forEach(grid => {
                        const gridCenter = grid.extent.center;
                        grid.distanceToCenter = Math.sqrt(
                            Math.pow(gridCenter.x - centerX, 2) + 
                            Math.pow(gridCenter.y - centerY, 2)
                        );
                    });
                    
                    // เรียงลำดับจากใกล้สุดไปไกลสุด
                    grids.sort((a, b) => a.distanceToCenter - b.distanceToCenter);
                    
                    debugLog(`สร้างกริดเสร็จสิ้น: ${grids.length} กริด`);
                    return grids;
                }

                async function processRoadsByGrid(geometry, type = 'boundary') {
                    if (isProcessing) {
                        showNotification("กำลังประมวลผลอยู่ กรุณารอสักครู่", "warning");
                        debugLog("ไม่สามารถเริ่มการประมวลผลใหม่ เนื่องจากมีการประมวลผลอยู่แล้ว", "warning");
                        return;
                    }
                    
                    isProcessing = true;
                    
                    // เพิ่มการนับครั้งการประมวลผล
                    processCount++;
                    
                    // เก็บจำนวนข้อมูลก่อนการประมวลผลล่าสุด
                    previousSelectionCount = selectedRoads ? selectedRoads.length : 0;
                    
                    // ลบ layer การแสดงผลแต่ยังคงข้อมูลที่เคยประมวลผลแล้ว
                    gridLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    
                    // กรณีการประมวลผลครั้งแรกให้เริ่มจากศูนย์
                    if (processCount === 1) {
                        selectedRoads = [];
                        processedIds = {};
                    }
                    
                    // Show grid process container
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'block';
                    
                    // แสดงข้อมูลสถิติการประมวลผล
                    const processingStats = document.getElementById("processingStats");
                    processingStats.style.display = "block";
                    document.getElementById("processCount").textContent = `จำนวนครั้งที่ประมวลผล: ${processCount}`;
                    document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${selectedRoads ? selectedRoads.length : 0}`;
                    document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: กำลังประมวลผล...`;
                    
                    try {
                        // ประมาณการจำนวนข้อมูลที่ควรจะมีในพื้นที่
                        const boundaryAreaSqKm = geometryEngine.geodesicArea(geometry, "square-kilometers");
                        const expectedDensity = roadGeometryType === "polygon" ? 500 : 1000; // จำนวนข้อมูลต่อตร.กม.
                        totalFeaturesExpected = Math.round(boundaryAreaSqKm * expectedDensity);
                        
                        debugLog(`พื้นที่ขนาด ${boundaryAreaSqKm.toFixed(2)} ตร.กม. คาดว่าจะมีข้อมูลประมาณ ${totalFeaturesExpected} รายการ`);
                        
                        // ขนาดกริดสำหรับการแสดงผลและประมวลผล
                        // ใช้กริดที่ใหญ่สำหรับการแสดงผล (เพื่อประสิทธิภาพ) แต่ใช้กริดเล็กสำหรับการประมวลผลจริง
                        const displayGridSize = roadGeometryType === "polygon" ? 1000 : 500; // กริดใหญ่สำหรับแสดงผล
                        const processingGridSize = 250; // ลดขนาดกริดลงเพื่อให้ได้ข้อมูลละเอียดมากขึ้น
                        
                        // สร้างกริดสำหรับการแสดงผล (ใหญ่)
                        const displayGrids = createGridCells(geometry.extent, displayGridSize);
                        
                        // ตรวจสอบหากมีข้อมูลกริดที่ยังไม่ได้ประมวลผลจากครั้งก่อน
                        let processingGrids = [];
                        
                        if (unprocessedAreaGrids.length > 0 && processCount > 1) {
                            debugLog(`ใช้กริดที่ยังไม่ได้ประมวลผลจากครั้งก่อน ${unprocessedAreaGrids.length} กริด`, "info");
                            processingGrids = unprocessedAreaGrids;
                            unprocessedAreaGrids = []; // ล้างข้อมูล
                        } else {
                            // สร้างกริดใหม่สำหรับประมวลผล
                            processingGrids = createGridCells(geometry.extent, processingGridSize);
                        }
                        
                        const totalGrids = processingGrids.length;
                        let processedCount = 0;
                        let totalRoads = selectedRoads ? selectedRoads.length : 0;
                        let newRoads = 0;
                        let consecutiveEmptyGrids = 0; // นับจำนวนกริดติดต่อกันที่ไม่พบข้อมูลใหม่
                        let hasGridError = false; // สถานะว่ามีข้อผิดพลาดหรือไม่
                        
                        gridStatus.textContent = `เริ่มประมวลผลกริดครั้งที่ ${processCount}`;
                        gridDetails.textContent = `0/${totalGrids} กริด`;
                        if (processCount > 1) {
                            gridDetails.textContent += ` (ข้อมูลเดิม: ${previousSelectionCount})`;
                        }
                        progressBarFill.style.width = '0%';
                        
                        // แสดงกริดสำหรับการแสดงผล
                        displayGrids.forEach((grid, index) => {
                            // แสดงเฉพาะกริดบางส่วนเพื่อไม่ให้หน้าจอรก
                            if (index % Math.ceil(displayGrids.length / 200) === 0 || index === displayGrids.length - 1) {
                                const gridGraphic = new Graphic({
                                    geometry: grid,
                                    symbol: {
                                        type: "simple-fill",
                                        color: [255, 165, 0, 0.1],
                                        outline: {
                                            color: [255, 165, 0, 0.5],
                                            width: 0.5
                                        }
                                    }
                                });
                                gridLayer.add(gridGraphic);
                            }
                        });
                        
                        // ปรับปรุงการประมวลผลแบบ concurrent สำหรับ grid ขนาดเล็ก
                        // เพิ่มจำนวน grids ที่ประมวลผลพร้อมกันเนื่องจากขนาดกริดเล็กลง
                        const maxConcurrentGrids = navigator.hardwareConcurrency ? 
                            Math.min(navigator.hardwareConcurrency * 2, 24) : 12;
                        
                        debugLog(`ตั้งค่าการประมวลผลพร้อมกันสูงสุด ${maxConcurrentGrids} กริด`);
                        
                        // แบ่งกริดเป็นกลุ่มๆ
                        const gridGroups = [];
                        for (let i = 0; i < processingGrids.length; i += maxConcurrentGrids) {
                            gridGroups.push(processingGrids.slice(i, i + maxConcurrentGrids));
                        }
                        
                        // สำหรับบันทึกกริดที่ล้มเหลวเพื่อลองประมวลผลอีกครั้ง
                        const failedGrids = [];
                        
                        // เก็บข้อมูลพื้นที่ที่ยังไม่ได้ประมวลผล หากมีการหยุดกลางคัน
                        unprocessedAreaGrids = [];
                        
                        // กำหนดขีดจำกัดจำนวนกริดว่างติดต่อกันที่ยอมรับได้
                        const emptyGridThreshold = Math.min(100, Math.max(20, Math.ceil(totalGrids * 0.05)));
                        
                        // ประมวลผลทีละกลุ่มกริด
                        let shouldContinue = true;
                        
                        for (const [groupIndex, currentGrids] of gridGroups.entries()) {
                            if (!shouldContinue) break;
                            
                            // ตรวจสอบว่าควรหยุดการประมวลผลหรือไม่
                            if (consecutiveEmptyGrids >= emptyGridThreshold && newRoads > 0) {
                                // ถ้าไม่พบข้อมูลใหม่ติดต่อกันหลายกริด และมีข้อมูลใหม่แล้วบ้าง
                                debugLog(`พบกริดว่างติดต่อกัน ${consecutiveEmptyGrids} กริด เกินค่าที่กำหนด ${emptyGridThreshold} กริด`, "warning");
                                
                                // ให้เก็บกริดที่เหลือไว้สำหรับการประมวลผลครั้งต่อไป
                                if (groupIndex < gridGroups.length - 1) {
                                    unprocessedAreaGrids = [];
                                    
                                    // เก็บทุกกริดที่ยังไม่ได้ประมวลผล
                                    for (let i = groupIndex + 1; i < gridGroups.length; i++) {
                                        unprocessedAreaGrids = unprocessedAreaGrids.concat(gridGroups[i]);
                                    }
                                    
                                    debugLog(`เหลือกริดที่ยังไม่ได้ประมวลผลอีก ${unprocessedAreaGrids.length} กริด`, "info");
                                    
                                    // แสดงข้อความแจ้งเตือนผู้ใช้
                                    gridStatus.textContent = `พบข้อมูลใหม่ ${newRoads} รายการแล้ว`;
                                    gridDetails.textContent = `หยุดการประมวลผลชั่วคราว - สามารถกดปุ่ม "ประมวลผลซ้ำ" เพื่อดึงข้อมูลเพิ่มเติม`;
                                    
                                    showNotification(`พบข้อมูลใหม่ ${newRoads} รายการแล้ว กดปุ่ม "ประมวลผลซ้ำ" เพื่อดึงข้อมูลเพิ่มเติม`, 'info', 5000);
                                    
                                    break;
                                }
                            }
                            
                            // ประมวลผลกริดพร้อมกันหลายกริด
                            const results = await Promise.all(currentGrids.map(async (grid, localIndex) => {
                                const globalIndex = groupIndex * maxConcurrentGrids + localIndex;
                                
                                try {
                                    // สร้าง query สำหรับดึงข้อมูลถนนในกริด
                                    const query = roadsLayer.createQuery();
                                    query.geometry = grid;
                                    query.spatialRelationship = "intersects";
                                    query.returnGeometry = true;
                                    query.outFields = ["*"];
                                    
                                    // เพิ่มขีดจำกัดจำนวนข้อมูลที่ดึงในแต่ละครั้ง
                                    query.num = 10000; // เพิ่มค่าสูงสุดเพื่อลดจำนวนครั้งในการดึงข้อมูล
                                    
                                    // เพิ่มการกรองข้อมูลที่ดึงแล้ว (ถ้าทำได้)
                                    if (Object.keys(processedIds).length > 0 && processCount > 1) {
                                        // หากมีจำนวน ID น้อยกว่า 100 ให้ใช้ NOT IN
                                        if (Object.keys(processedIds).length < 100) {
                                            const idList = Object.keys(processedIds).slice(0, 99);
                                            query.where = `OBJECTID NOT IN (${idList.join(',')})`;
                                        }
                                    }
                                    
                                    // ตรวจสอบว่ามีจำนวนข้อมูลเกินขีดจำกัดหรือไม่
                                    let allFeatures = [];
                                    let queryResult = await roadsLayer.queryFeatures(query);
                                    let validRoads = queryResult.features;
                                    allFeatures = allFeatures.concat(validRoads);
                                    
                                    // ถ้าจำนวนที่ได้เท่ากับที่กำหนดใน num แสดงว่าอาจมีข้อมูลเพิ่มเติม
                                    if (validRoads.length === query.num) {
                                        // ลองแบ่งกริดออกเป็น 4 ส่วนและประมวลผลแยก
                                        const subGrids = subdivideGrid(grid);
                                        
                                        debugLog(`กริดที่ ${globalIndex} มีข้อมูลมาก (${validRoads.length} รายการ) แบ่งเป็น 4 กริดย่อย`, "info");
                                        
                                        // ประมวลผลกริดย่อยแต่ละกริด
                                        for (const subGrid of subGrids) {
                                            try {
                                                const subQuery = roadsLayer.createQuery();
                                                subQuery.geometry = subGrid;
                                                subQuery.spatialRelationship = "intersects";
                                                subQuery.returnGeometry = true;
                                                subQuery.outFields = ["*"];
                                                subQuery.num = 10000;
                                                
                                                // ใช้เงื่อนไขกรองเช่นเดียวกับกริดหลัก (ถ้ามี)
                                                if (query.where) {
                                                    subQuery.where = query.where;
                                                }
                                                
                                                const subResult = await roadsLayer.queryFeatures(subQuery);
                                                allFeatures = allFeatures.concat(subResult.features);
                                                
                                                // ถ้ายังมีข้อมูลเยอะอีก แบ่งย่อยลงไปอีกระดับ
                                                if (subResult.features.length === subQuery.num) {
                                                    const microGrids = subdivideGrid(subGrid);
                                                    
                                                    for (const microGrid of microGrids) {
                                                        const microQuery = roadsLayer.createQuery();
                                                        microQuery.geometry = microGrid;
                                                        microQuery.spatialRelationship = "intersects";
                                                        microQuery.returnGeometry = true;
                                                        microQuery.outFields = ["*"];
                                                        microQuery.num = 10000;
                                                        
                                                        if (query.where) {
                                                            microQuery.where = query.where;
                                                        }
                                                        
                                                        const microResult = await roadsLayer.queryFeatures(microQuery);
                                                        allFeatures = allFeatures.concat(microResult.features);
                                                    }
                                                }
                                            } catch (subError) {
                                                debugLog(`ข้อผิดพลาดในการประมวลผลกริดย่อย: ${subError.message}`, "error");
                                            }
                                        }
                                    }
                                    
                                    // กรองเฉพาะถนนที่อยู่ในพื้นที่ที่วาด (สำหรับกรณีวาดพื้นที่เอง)
                                    if (type === 'draw') {
                                        allFeatures = allFeatures.filter(road => 
                                            geometryEngine.intersects(road.geometry, geometry)
                                        );
                                    }
                                    
                                    // กรองข้อมูลที่ซ้ำซ้อน โดยตรวจสอบจาก ID
                                    const newFeatures = allFeatures.filter(road => {
                                        const id = road.attributes.OBJECTID || road.attributes.FID || 
                                                road.attributes.objectid || road.attributes.fid;
                                                
                                        return id && !processedIds[id];
                                    });
                                    
                                    // ตรวจสอบว่าพบข้อมูลใหม่หรือไม่
                                    if (newFeatures.length > 0) {
                                        consecutiveEmptyGrids = 0; // รีเซ็ตตัวนับกริดว่าง
                                    } else {
                                        consecutiveEmptyGrids++; // เพิ่มตัวนับกริดว่าง
                                    }
                                    
                                    // อัพเดทความคืบหน้า
                                    processedCount++;
                                    const progress = (processedCount / totalGrids) * 100;
                                    progressBarFill.style.width = `${progress}%`;
                                    
                                    // อัพเดทข้อความสถานะทุก 5% หรือเมื่อเสร็จสิ้น
                                    if (processedCount % Math.max(1, Math.floor(totalGrids / 20)) === 0 || 
                                        processedCount === totalGrids) {
                                        gridStatus.textContent = `กำลังประมวลผลครั้งที่ ${processCount}...`;
                                        gridDetails.textContent = `${processedCount}/${totalGrids} กริด`;
                                        if (processCount > 1) {
                                            gridDetails.textContent += ` (พบข้อมูลใหม่ ${newRoads} รายการ)`;
                                        }
                                    }
                                    
                                    return newFeatures;
                                } catch (error) {
                                    console.error(`Error processing grid ${globalIndex}:`, error);
                                    debugLog(`ข้อผิดพลาดในการประมวลผลกริดที่ ${globalIndex}: ${error.message}`, "error");
                                    
                                    // เก็บกริดที่ล้มเหลวเพื่อลองประมวลผลอีกครั้ง
                                    failedGrids.push(grid);
                                    hasGridError = true;
                                    return [];
                                }
                            }));
                            
                            // รวมผลลัพธ์จากทุกกริดในกลุ่มนี้
                            const flatResults = results.flat();
                            
                            // เพิ่มข้อมูลใหม่และตรวจสอบความซ้ำซ้อน
                            const newFeaturesInThisGroup = [];
                            
                            flatResults.forEach(road => {
                                const id = road.attributes.OBJECTID || road.attributes.FID || 
                                          road.attributes.objectid || road.attributes.fid;
                                          
                                if (id && !processedIds[id]) {
                                    // เพิ่มเฉพาะข้อมูลที่ยังไม่เคยประมวลผล
                                    processedIds[id] = true;
                                    selectedRoads.push(road);
                                    newRoads++;
                                    newFeaturesInThisGroup.push(road);
                                }
                            });
                            
                            // อัพเดทจำนวนข้อมูลทั้งหมด
                            totalRoads = selectedRoads.length;
                            
                            // อัพเดทความคืบหน้าและสถิติ
                            const progress = ((groupIndex + 1) / gridGroups.length) * 100;
                            progressBarFill.style.width = `${progress}%`;
                            
                            gridStatus.textContent = `กำลังประมวลผลครั้งที่ ${processCount}... ${Math.round(progress)}%`;
                            gridDetails.textContent = `${processedCount}/${totalGrids} กริด (พบข้อมูลใหม่ ${newRoads} รายการ)`;
                            
                            document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${totalRoads}`;
                            document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: +${newRoads}`;
                            
                            debugLog(`ประมวลผลกลุ่มที่ ${groupIndex+1}/${gridGroups.length} เสร็จแล้ว พบข้อมูลใหม่ ${newFeaturesInThisGroup.length} รายการ`);
                            
                            // ถ้าจำนวนข้อมูลมากกว่าที่คาดการณ์อย่างมาก ให้ปรับการคาดการณ์
                            if (totalRoads > totalFeaturesExpected * 1.5) {
                                const oldExpected = totalFeaturesExpected;
                                totalFeaturesExpected = Math.round(totalRoads * 1.2); // เพิ่มอีก 20%
                                debugLog(`ปรับการคาดการณ์จำนวนข้อมูลจาก ${oldExpected} เป็น ${totalFeaturesExpected} รายการ`);
                            }
                            
                            // ตรวจสอบว่าได้ข้อมูลถึงเป้าหมายหรือยัง
                            // หากได้ข้อมูลเกิน 80% ของที่คาดการณ์และยังไม่พบข้อมูลใหม่ในหลายกริงติดต่อกัน
                            if (totalRoads > totalFeaturesExpected * 0.8 && consecutiveEmptyGrids > emptyGridThreshold) {
                                debugLog(`ได้ข้อมูล ${totalRoads} รายการ (${(totalRoads/totalFeaturesExpected*100).toFixed(0)}% ของที่คาดการณ์) และไม่พบข้อมูลใหม่แล้ว`, "success");
                                
                                // แสดงข้อความแจ้งเตือน
                                showNotification(`ได้ข้อมูลครบถ้วนแล้ว ${totalRoads} รายการ หยุดการประมวลผล`, 'info', 5000);
                                
                                // หยุดการประมวลผล
                                shouldContinue = false;
                                break;
                            }
                            
                            // เพิ่มการตรวจสอบเมื่อดึงข้อมูลได้เยอะแล้ว ให้บันทึกแล้วเริ่มใหม่
                            if (totalRoads > 400000) {
                                // ถ้าจำนวนข้อมูลเริ่มเยอะ ให้หยุดและบันทึกเป็นไฟล์ GEOJSON ก่อน
                                debugLog(`จำนวนข้อมูลมากถึง ${totalRoads} รายการ แนะนำให้บันทึกข้อมูลก่อนดำเนินการต่อ`, "warning");
                                
                                gridStatus.textContent = `ข้อมูลมีจำนวนมากถึง ${totalRoads} รายการ`;
                                gridDetails.textContent = `แนะนำให้ส่งออกข้อมูลก่อนประมวลผลต่อ`;
                                
                                // แสดงข้อความแจ้งเตือน
                                showNotification(`พบข้อมูลจำนวนมาก (${totalRoads} รายการ) แนะนำให้ส่งออกไฟล์ก่อนดำเนินการต่อ`, 'warning', 8000);
                                
                                // บันทึกกริดที่เหลือ
                                if (groupIndex < gridGroups.length - 1) {
                                    unprocessedAreaGrids = [];
                                    for (let i = groupIndex + 1; i < gridGroups.length; i++) {
                                        unprocessedAreaGrids = unprocessedAreaGrids.concat(gridGroups[i]);
                                    }
                                }
                                
                                // หยุดการประมวลผล
                                shouldContinue = false;
                                break;
                            }
                            
                            // ให้ UI ได้มีโอกาส update ก่อนเริ่มประมวลผลชุดถัดไป
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                        // ประมวลผลกริดที่ล้มเหลวอีกครั้ง (ถ้ามี)
                        if (failedGrids.length > 0 && shouldContinue) {
                            debugLog(`ลองประมวลผลกริดที่ล้มเหลว ${failedGrids.length} กริด อีกครั้ง`, "info");
                            gridStatus.textContent = `กำลังประมวลผลกริดที่ล้มเหลว ${failedGrids.length} กริด`;
                            
                            // จำกัดจำนวนกริดที่จะลองใหม่
                            const retryGrids = failedGrids.slice(0, Math.min(failedGrids.length, 50));
                            
                            // ลองประมวลผลทีละกริด
                            for (let i = 0; i < retryGrids.length; i++) {
                                try {
                                    const grid = retryGrids[i];
                                    const query = roadsLayer.createQuery();
                                    query.geometry = grid;
                                    query.spatialRelationship = "intersects";
                                    query.returnGeometry = true;
                                    query.outFields = ["*"];
                                    
                                    const result = await roadsLayer.queryFeatures(query);
                                    let validRoads = result.features;
                                    
                                    if (type === 'draw') {
                                        validRoads = result.features.filter(road => 
                                            geometryEngine.intersects(road.geometry, geometry)
                                        );
                                    }
                                    
                                    // เพิ่มข้อมูลใหม่และตรวจสอบความซ้ำซ้อน
                                    const newFeaturesCount = validRoads.filter(road => {
                                        const id = road.attributes.OBJECTID || road.attributes.FID || 
                                                road.attributes.objectid || road.attributes.fid;
                                                
                                        if (id && !processedIds[id]) {
                                            processedIds[id] = true;
                                            selectedRoads.push(road);
                                            newRoads++;
                                            return true;
                                        }
                                        return false;
                                    }).length;
                                    
                                    // อัพเดทความคืบหน้า
                                    gridStatus.textContent = `ประมวลผลกริดที่ล้มเหลว ${i+1}/${retryGrids.length}`;
                                    
                                    if (newFeaturesCount > 0) {
                                        debugLog(`กริดที่ล้มเหลวที่ ${i+1} พบข้อมูลใหม่ ${newFeaturesCount} รายการ`, "success");
                                    }
                                    
                                    // อัพเดทจำนวนข้อมูล
                                    document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${selectedRoads.length}`;
                                    document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: +${newRoads}`;
                                } catch (error) {
                                    console.error(`ล้มเหลวในการประมวลผลกริดอีกครั้ง:`, error);
                                    debugLog(`ล้มเหลวในการประมวลผลกริดอีกครั้ง: ${error.message}`, "error");
                                }
                                
                                // รอเล็กน้อยเพื่อไม่ให้ระบบล่ม
                                await new Promise(resolve => setTimeout(resolve, 100));
                            }
                        }
                        
                        // แสดงสรุปผลการประมวลผล
                        gridStatus.textContent = `ประมวลผลครั้งที่ ${processCount} เสร็จสิ้น`;
                        
                        if (hasGridError) {
                            gridDetails.textContent = `พบข้อมูลใหม่ ${newRoads} รายการ (รวมทั้งหมด ${selectedRoads.length} รายการ) มีบางกริดที่ล้มเหลว`;
                        } else {
                            gridDetails.textContent = `พบข้อมูลใหม่ ${newRoads} รายการ (รวมทั้งหมด ${selectedRoads.length} รายการ)`;
                        }
                        
                        // อัพเดทสถิติการประมวลผล
                        document.getElementById("totalFeaturesCount").textContent = `จำนวนข้อมูลทั้งหมด: ${selectedRoads.length}`;
                        document.getElementById("newFeaturesCount").textContent = `จำนวนข้อมูลใหม่: +${newRoads}`;
                        
                        // ตรวจสอบความครอบคลุมของข้อมูล
                        const coveragePercent = (selectedRoads.length / totalFeaturesExpected) * 100;
                        
                        debugLog(`ความครอบคลุมของข้อมูล: ${coveragePercent.toFixed(1)}% (${selectedRoads.length}/${totalFeaturesExpected})`, 
                            coveragePercent > 80 ? "success" : coveragePercent > 50 ? "info" : "warning");
                        
                        // แสดงข้อมูลเพิ่มเติมเกี่ยวกับความครอบคลุม
                        if (coveragePercent < 50 && newRoads > 0) {
                            // ถ้าดึงข้อมูลได้น้อยกว่า 50% แต่ยังมีข้อมูลใหม่ แนะนำให้ประมวลผลซ้ำ
                            const infoElement = document.createElement("div");
                            infoElement.style.marginTop = "5px";
                            infoElement.style.color = "#FF9800";
                            infoElement.textContent = `ข้อมูลอาจยังไม่ครบถ้วน (${coveragePercent.toFixed(0)}%) แนะนำให้กดปุ่ม "ประมวลผลซ้ำ" อีกครั้ง`;
                            document.getElementById("processingStats").appendChild(infoElement);
                            
                            // ลบข้อความหลังจาก 10 วินาที
                            setTimeout(() => {
                                if (infoElement.parentNode) {
                                    infoElement.parentNode.removeChild(infoElement);
                                }
                            }, 10000);
                            
                            // แสดงแจ้งเตือน
                            showNotification(`ข้อมูลอาจยังไม่ครบถ้วน (${coveragePercent.toFixed(0)}%) แนะนำให้กดปุ่ม "ประมวลผลซ้ำ" อีกครั้ง`, 'info', 5000);
                        } else if (coveragePercent >= 80) {
                            // ถ้าดึงข้อมูลได้เกิน 80% แสดงว่าน่าจะครบถ้วนแล้ว
                            const infoElement = document.createElement("div");
                            infoElement.style.marginTop = "5px";
                            infoElement.style.color = "#4CAF50";
                            infoElement.textContent = `ข้อมูลน่าจะครบถ้วนแล้ว (${coveragePercent.toFixed(0)}%)`;
                            document.getElementById("processingStats").appendChild(infoElement);
                            
                            // ลบข้อความหลังจาก 8 วินาที
                            setTimeout(() => {
                                if (infoElement.parentNode) {
                                    infoElement.parentNode.removeChild(infoElement);
                                }
                            }, 8000);
                        }
                        
                        // ถ้าพบข้อมูลใหม่น้อยมาก และมีการประมวลผลมากกว่า 1 ครั้ง
                        if (newRoads < 10 && processCount > 1 && selectedRoads.length > 1000) {
                            const additionalInfo = document.createElement("div");
                            additionalInfo.style.marginTop = "5px";
                            additionalInfo.style.color = "#4CAF50";
                            additionalInfo.textContent = `พบข้อมูลใหม่น้อยมาก ข้อมูลน่าจะครบถ้วนแล้ว`;
                            document.getElementById("processingStats").appendChild(additionalInfo);
                            
                            // ลบข้อความหลังจาก 8 วินาที
                            setTimeout(() => {
                                if (additionalInfo.parentNode) {
                                    additionalInfo.parentNode.removeChild(additionalInfo);
                                }
                            }, 8000);
                        }
                        
                        previewButton.disabled = false;
                        exportButton.disabled = false;
                        
                        // แสดงตัวอย่างการส่งออก (อาจปิดใช้งานหากจำนวนถนนมากเกินไป)
                        if (selectedRoads.length <= 100000) {
                            await previewExportRoads();
                        } else {
                            exportButton.disabled = false;
                            loadingMessage.style.display = "block";
                            loadingMessage.textContent = `เนื่องจากมีข้อมูลถนนจำนวนมาก (${selectedRoads.length.toLocaleString()} เส้น) จึงไม่แสดงตัวอย่าง สามารถกดปุ่มส่งออกได้ทันที`;
                            
                            // แสดงแจ้งเตือน
                            showNotification(`ไม่แสดงตัวอย่างเนื่องจากมีข้อมูลจำนวนมาก (${selectedRoads.length.toLocaleString()} รายการ) กรุณากดปุ่ม "ส่งออก GeoJSON"`, 'info', 5000);
                            
                            setTimeout(() => {
                                loadingMessage.style.display = "none";
                            }, 5000);
                        }
                        
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                        }, 3000);
                        
                    } catch (error) {
                        console.error("Error in grid processing:", error);
                        gridStatus.textContent = "เกิดข้อผิดพลาดในการประมวลผล";
                        gridDetails.textContent = error.message || "";
                        debugLog(`เกิดข้อผิดพลาดในการประมวลผล: ${error.message}`, "error");
                        showNotification("เกิดข้อผิดพลาดในการประมวลผล กรุณาลองใหม่อีกครั้ง", "warning");
                    } finally {
                        isProcessing = false;
                    }
                }

                // Sketch Widget
                const sketch = new Sketch({
                    view: view,
                    layer: selectionLayer,
                    creationMode: "single",
                    availableCreateTools: ["polygon"],
                    visibleElements: {
                        createTools: {
                            point: false,
                            polyline: false,
                            rectangle: false,
                            circle: false
                        },
                        selectionTools: {
                            "lasso-selection": false,
                            "rectangle-selection": false
                        },
                        settingsMenu: false,
                        undoRedoMenu: false
                    }
                });

                const layerList = new LayerList({
                    view: view
                });

                const legend = new Legend({
                    view: view
                });

                view.ui.add(layerList, "top-right");
                view.ui.add(legend, "bottom-right");

                const drawPolygonButton = document.getElementById("drawPolygonButton");
                const clearSelectionButton = document.getElementById("clearSelectionButton");
                let isDrawing = false;

                // ปรับฟังก์ชัน previewExportRoads สำหรับการแสดงผลตามประเภทข้อมูล
                async function previewExportRoads() {
                    if (!selectedRoads) return;

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังวิเคราะห์ข้อมูล...";
                    previewButton.disabled = true;

                    try {
                        exportPreviewLayer.removeAll();
                        
                        const totalRoads = selectedRoads.length;
                        loadingMessage.textContent = `พบเส้นทาง/พื้นที่ทั้งหมด ${totalRoads.toLocaleString()} รายการ`;
                        debugLog(`เริ่มการแสดงตัวอย่างสำหรับ ${totalRoads} รายการ`);

                        // ถ้ามีข้อมูลมากเกินไป ให้แสดงเฉพาะบางส่วน
                        const maxPreviewRoads = roadGeometryType === "polygon" ? 15000 : 30000;
                        
                        if (totalRoads > maxPreviewRoads) {
                            loadingMessage.textContent = `มีข้อมูลจำนวนมาก (${totalRoads.toLocaleString()} รายการ) จะแสดงตัวอย่างเพียงบางส่วน`;
                            debugLog(`ข้อมูลมากเกินกว่าจะแสดงทั้งหมด จะแสดงเพียง ${maxPreviewRoads} รายการ`, "warning");
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }

                        const processVisibleRoads = async () => {
                            const viewExtent = view.extent;
                            
                            // ปรับขนาด batch ให้เหมาะสมกับประเภทข้อมูล
                            const batchSize = roadGeometryType === "polygon" ? 5000 : 10000;
                            
                            // จำกัดจำนวนข้อมูลที่จะแสดงตัวอย่าง
                            const roadsToProcess = totalRoads > maxPreviewRoads ? 
                                selectedRoads.slice(0, maxPreviewRoads) : selectedRoads;
                            
                            const chunks = [];
                            for (let i = 0; i < roadsToProcess.length; i += batchSize) {
                                chunks.push(roadsToProcess.slice(i, i + batchSize));
                            }

                            // ฟังก์ชันสำหรับจัดเตรียมข้อมูลเพื่อแสดงผล
                            const processChunk = async (roads) => {
                                // กรองเฉพาะถนนที่อยู่ในพื้นที่มุมมองปัจจุบัน
                                const visibleRoads = roads.filter(road => 
                                    geometryEngine.intersects(road.geometry, viewExtent)
                                );
                                
                                // ในกรณีที่มีข้อมูลมากเกินไป ให้สุ่มเลือกบางส่วน
                                let processRoads = visibleRoads;
                                if (visibleRoads.length > 5000 && roadGeometryType === "polygon") {
                                    // สุ่มเลือก 5000 รายการ
                                    const shuffled = [...visibleRoads].sort(() => 0.5 - Math.random());
                                    processRoads = shuffled.slice(0, 5000);
                                }
                                
                                return processRoads.map(road => {
                                    let priority = 0;
                                    
                                    if (roadGeometryType === "polygon") {
                                        // คำนวณพื้นที่เพียงครั้งเดียว
                                        const area = geometryEngine.geodesicArea(road.geometry, "square-meters");
                                        priority = area > 0 ? area : 0;
                                    } else {
                                        priority = road.geometry.length || 0;
                                    }
                                    
                                    const width = road.attributes.WIDTH || road.attributes.width || 0;
                                    
                                    return {
                                        road,
                                        priority,
                                        width
                                    };
                                });
                            };
                            // ประมวลผล chunk แบบขนาน
                            const maxConcurrentProcessing = navigator.hardwareConcurrency ? 
                                Math.min(navigator.hardwareConcurrency, 4) : 2;
                            
                            debugLog(`ตั้งค่าการประมวลผลตัวอย่างพร้อมกัน ${maxConcurrentProcessing} กลุ่ม`);
                            
                            let processedRoads = [];
                            
                            for (let i = 0; i < chunks.length; i += maxConcurrentProcessing) {
                                const currentChunks = chunks.slice(i, i + maxConcurrentProcessing);
                                const results = await Promise.all(
                                    currentChunks.map(async (chunk, index) => {
                                        const result = await processChunk(chunk);
                                        const progress = Math.round(((i + index + 1) / chunks.length) * 100);
                                        loadingMessage.textContent = `กำลังวิเคราะห์ข้อมูล... ${progress}%`;
                                        return result;
                                    })
                                );
                                processedRoads = processedRoads.concat(results.flat());
                                
                                // ถ้ามีข้อมูลมากเกินไป ให้หยุดการประมวลผล
                                if (processedRoads.length > 20000) {
                                    debugLog(`ข้อมูลสำหรับแสดงตัวอย่างมากเกินไป จำกัดที่ ${processedRoads.length} รายการ`, "warning");
                                    break;
                                }
                            }

                            // เรียงลำดับความสำคัญ
                            processedRoads.sort((a, b) => {
                                if (roadGeometryType === "polygon") {
                                    return b.priority - a.priority;
                                } else {
                                    const aPriority = (a.priority * 0.7) + (a.width * 0.3);
                                    const bPriority = (b.priority * 0.7) + (b.width * 0.3);
                                    return bPriority - aPriority;
                                }
                            });

                            // กำหนดจำนวนสูงสุดของแต่ละระดับความสำคัญ
                            const maxHighPriority = roadGeometryType === "polygon" ? 3000 : 10000;
                            const maxMediumPriority = roadGeometryType === "polygon" ? 5000 : 15000;
                            
                            const highPriority = processedRoads.slice(0, maxHighPriority);
                            const mediumPriority = processedRoads.slice(maxHighPriority, maxHighPriority + maxMediumPriority);
                            const lowPriority = processedRoads.slice(maxHighPriority + maxMediumPriority);
                            
                            debugLog(`ข้อมูลสำหรับแสดงตัวอย่าง: ความสำคัญสูง ${highPriority.length}, กลาง ${mediumPriority.length}, ต่ำ ${lowPriority.length}`);

                            // ฟังก์ชันสร้างกราฟิกแบบแบทช์
                            const createGraphicsBatch = async (roads, symbolWidth, delay = 0) => {
                                const graphicsBatchSize = roadGeometryType === "polygon" ? 500 : 1000;
                                let graphics = [];

                                for (let i = 0; i < roads.length; i += graphicsBatchSize) {
                                    const batch = roads.slice(i, i + graphicsBatchSize);
                                    
                                    const batchGraphics = batch.map(item => {
                                        let symbol;
                                        
                                        if (roadGeometryType === "polygon") {
                                            symbol = {
                                                type: "simple-fill",
                                                color: [255, 0, 0, 0.2], // ลดความทึบให้เห็นชัดขึ้น
                                                outline: {
                                                    color: [255, 0, 0],
                                                    width: symbolWidth
                                                }
                                            };
                                        } else {
                                            symbol = {
                                                type: "simple-line",
                                                color: [255, 0, 0],
                                                width: symbolWidth
                                            };
                                        }
                                        
                                        return new Graphic({
                                            geometry: item.road.geometry,
                                            attributes: item.road.attributes,
                                            symbol: symbol
                                        });
                                    });

                                    graphics = graphics.concat(batchGraphics);
                                    
                                    if (graphics.length >= (roadGeometryType === "polygon" ? 2500 : 5000) || 
                                        i + graphicsBatchSize >= roads.length) {
                                        exportPreviewLayer.addMany(graphics);
                                        graphics = [];
                                        
                                        if (delay > 0) {
                                            const adjustedDelay = roadGeometryType === "polygon" ? 
                                                Math.max(1, delay / 3) : delay;
                                            await new Promise(resolve => setTimeout(resolve, adjustedDelay));
                                        }
                                    }
                                }
                            };

                            const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                            
                            // แสดงข้อมูลหลัก (ความสำคัญสูง)
                            loadingMessage.textContent = `กำลังแสดง${itemTypeName}หลัก...`;
                            await createGraphicsBatch(highPriority, 
                                roadGeometryType === "polygon" ? "1px" : "2px", 
                                roadGeometryType === "polygon" ? 0 : 1);
                            
                            // แสดงข้อมูลรอง (ความสำคัญปานกลาง)
                            if (mediumPriority.length > 0) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}รอง...`;
                                await createGraphicsBatch(mediumPriority, 
                                    roadGeometryType === "polygon" ? "0.5px" : "1px", 
                                    roadGeometryType === "polygon" ? 0 : 1);
                            }
                            
                            // แสดงข้อมูลย่อย (ความสำคัญต่ำ) เฉพาะเมื่อไม่มีข้อมูลมากเกินไป
                            if (lowPriority.length > 0 && 
                                (roadGeometryType !== "polygon" || lowPriority.length < 1000)) {
                                loadingMessage.textContent = `กำลังแสดง${itemTypeName}ย่อย...`;
                                await createGraphicsBatch(lowPriority, 
                                    roadGeometryType === "polygon" ? "0.3px" : "0.5px", 
                                    roadGeometryType === "polygon" ? 0 : 1);
                            }
                        };

                        // ใช้ debounce เพื่อลดการเรียกซ้ำบ่อยๆ
                        let updateTimeout;
                        const debouncedUpdate = () => {
                            clearTimeout(updateTimeout);
                            const debounceTime = roadGeometryType === "polygon" ? 1500 : 1000;
                            updateTimeout = setTimeout(async () => {
                                exportPreviewLayer.removeAll();
                                await processVisibleRoads();
                            }, debounceTime);
                        };

                        // ประมวลผลข้อมูลที่อยู่ในมุมมองปัจจุบัน
                        await processVisibleRoads();
                        
                        // ติดตามการเปลี่ยนแปลงขอบเขตและการหมุนแผนที่
                        view.watch("extent", debouncedUpdate);
                        view.watch("rotation", debouncedUpdate);

                        // แสดงเลเยอร์ผลลัพธ์และเปิดใช้งานปุ่มส่งออก
                        exportPreviewLayer.visible = true;
                        exportButton.disabled = false;

                        // แสดงข้อความสรุป
                        const itemTypeName = roadGeometryType === "polygon" ? "พื้นที่" : "เส้นทาง";
                        loadingMessage.textContent = `พร้อมส่งออกข้อมูล${itemTypeName} ${totalRoads.toLocaleString()} รายการ`;
                        debugLog(`พร้อมส่งออกข้อมูล ${totalRoads.toLocaleString()} รายการ`, "success");
                        
                        // ซ่อนข้อความสถานะหลังจากเวลาผ่านไป
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);

                    } catch (error) {
                        console.error("Error previewing roads:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการสร้างตัวอย่าง";
                        debugLog(`เกิดข้อผิดพลาดในการแสดงตัวอย่าง: ${error.message}`, "error");
                    } finally {
                        previewButton.disabled = false;
                    }
                }

                // ปรับปรุงฟังก์ชัน exportRoadsToGeoJSON ให้มีประสิทธิภาพและโหลดข้อมูลครบถ้วน
                async function exportRoadsToGeoJSON(customFileName = null) {
                    if (!selectedRoads || selectedRoads.length === 0) {
                        showNotification("ไม่มีข้อมูลสำหรับส่งออก กรุณาเลือกพื้นที่และประมวลผลก่อน", "warning");
                        return;
                    }

                    loadingMessage.style.display = "block";
                    loadingMessage.textContent = "กำลังเตรียมข้อมูลเพื่อส่งออก...";
                    debugLog(`เริ่มการส่งออกข้อมูล ${selectedRoads.length} รายการ`);

                    try {
                        let name = customFileName;
                        if (!name) {
                            name = document.getElementById("boundarySelect").value || "selected_area";
                        }
                        
                        const utmSR = new SpatialReference({
                            wkid: 32647
                        });

                        // แสดงความคืบหน้า
                        const progressBar = document.querySelector(".progress-bar-fill");
                        const gridProcessContainer = document.getElementById('gridProcessContainer');
                        const gridStatus = document.getElementById("gridStatus");
                        const gridDetails = document.getElementById("gridDetails");
                        
                        gridProcessContainer.style.display = 'block';
                        gridStatus.textContent = "กำลังเตรียมข้อมูลเพื่อส่งออก...";
                        gridDetails.textContent = `0/${selectedRoads.length} รายการ`;
                        progressBar.style.width = '0%';
                        
                        // เพิ่มรายละเอียดลงใน GeoJSON
                        const geojson = {
                            type: "FeatureCollection",
                            name: `roads_${name}`,
                            crs: {
                                type: "name",
                                properties: {
                                    name: "EPSG:32647"
                                }
                            },
                            metadata: {
                                exportDate: new Date().toISOString(),
                                totalFeatures: selectedRoads.length,
                                geometryType: roadGeometryType,
                                gridSize: "250x250m",
                                processingCount: processCount,
                                source: "Department of Public Works and Town & Country Planning"
                            },
                            features: []
                        };
                        // ปรับขนาด batch ให้เล็กลงเพื่อป้องกันปัญหาหน่วยความจำเต็ม
                        const batchSize = roadGeometryType === "polygon" ? 200 : 500;
                        const totalBatches = Math.ceil(selectedRoads.length / batchSize);
                        
                        // แสดงการประมาณการเวลาทั้งหมด
                        const startTime = Date.now();
                        let lastProcessed = 0;
                        let estimatedTotalTime = 0;
                        
                        // ประมวลผลทีละ batch
                        for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
                            const start = batchIndex * batchSize;
                            const end = Math.min(start + batchSize, selectedRoads.length);
                            const currentBatch = selectedRoads.slice(start, end);
                            
                            // ประมวลผลแต่ละรายการใน batch
                            const batchFeatures = await Promise.all(currentBatch.map(async (feature) => {
                                try {
                                    const utmGeometry = projection.project(
                                        feature.geometry,
                                        utmSR
                                    );
                                    
                                    let geometryObject;
                                    let lengthField = 0;
                                    let areaField = null;
                                    
                                    if (roadGeometryType === "polygon") {
                                        geometryObject = {
                                            type: "Polygon",
                                            coordinates: utmGeometry.rings
                                        };
                                        
                                        // คำนวณพื้นที่
                                        if (feature.geometry.rings) {
                                            areaField = geometryEngine.geodesicArea(feature.geometry, "square-meters");
                                            lengthField = areaField; // ใช้พื้นที่เป็นความยาว (สำหรับ polygon)
                                        }
                                    } else {
                                        geometryObject = {
                                            type: "LineString",
                                            coordinates: utmGeometry.paths ? utmGeometry.paths[0] : []
                                        };
                                        
                                        // คำนวณความยาว
                                        lengthField = feature.geometry.length || 0;
                                    }
                                    
                                    // กำหนดคุณสมบัติเพิ่มเติม
                                    const properties = {
                                        ...feature.attributes,
                                        length_m: lengthField,
                                        area_sqm: areaField,
                                        road_id: feature.attributes.OBJECTID || feature.attributes.FID || 
                                                feature.attributes.objectid || feature.attributes.fid || null,
                                        geometry_type: roadGeometryType,
                                        style: {
                                            color: "#FF0000",
                                            weight: 2,
                                            opacity: roadGeometryType === "polygon" ? 0.5 : 1
                                        }
                                    };
                                    
                                    // สร้าง Feature object
                                    return {
                                        type: "Feature",
                                        geometry: geometryObject,
                                        properties: properties
                                    };
                                } catch (error) {
                                    console.error("Error processing feature:", error);
                                    debugLog(`ข้อผิดพลาดในการประมวลผลรายการที่ ${start + currentBatch.indexOf(feature)}: ${error.message}`, "error");
                                    return null;
                                }
                            }));
                            
                            // กรองข้อมูลที่เป็น null ออก
                            const validFeatures = batchFeatures.filter(feature => feature !== null);
                            
                            // เพิ่มข้อมูลลงใน GeoJSON
                            geojson.features = geojson.features.concat(validFeatures);
                            
                            // คำนวณเวลาที่ใช้และประมาณการเวลาที่เหลือ
                            const currentTime = Date.now();
                            const elapsedTime = (currentTime - startTime) / 1000; // เวลาที่ผ่านไปเป็นวินาที
                            const processedItems = end;
                            
                            if (batchIndex > 0) {
                                const itemsPerSecond = processedItems / elapsedTime;
                                const remainingItems = selectedRoads.length - processedItems;
                                const estimatedRemainingTime = remainingItems / itemsPerSecond;
                                estimatedTotalTime = elapsedTime + estimatedRemainingTime;
                                
                                // แสดงเวลาในรูปแบบที่อ่านง่าย
                                const formatTime = (seconds) => {
                                    if (seconds < 60) return `${Math.round(seconds)} วินาที`;
                                    if (seconds < 3600) return `${Math.floor(seconds / 60)} นาที ${Math.round(seconds % 60)} วินาที`;
                                    return `${Math.floor(seconds / 3600)} ชั่วโมง ${Math.floor((seconds % 3600) / 60)} นาที`;
                                };
                                
                                const timeInfo = `ประมาณอีก ${formatTime(estimatedRemainingTime)} (ทั้งหมด ${formatTime(estimatedTotalTime)})`;
                                gridDetails.textContent = `${processedItems}/${selectedRoads.length} รายการ - ${timeInfo}`;
                            }
                            
                            // อัพเดทความคืบหน้า
                            const progress = ((batchIndex + 1) / totalBatches) * 100;
                            progressBar.style.width = `${progress}%`;
                            gridStatus.textContent = `กำลังส่งออกข้อมูล... ${Math.round(progress)}%`;
                            
                            // เพิ่มการหน่วงเวลาเล็กน้อยเพื่อให้ UI อัพเดท
                            await new Promise(resolve => setTimeout(resolve, 5));
                            
                            // ในกรณีที่ข้อมูลมีขนาดใหญ่มาก ให้ทำการบันทึกเป็นไฟล์ทุกๆ 50,000 รายการ
                            if (geojson.features.length >= 50000 && (batchIndex < totalBatches - 1)) {
                                // สร้างไฟล์ชั่วคราว
                                const partFileName = `roads_${name}_part${Math.ceil((batchIndex + 1) / (50000 / batchSize))}_utm47n`;
                                const partGeojson = {
                                    ...geojson,
                                    name: partFileName,
                                    metadata: {
                                        ...geojson.metadata,
                                        partNumber: Math.ceil((batchIndex + 1) / (50000 / batchSize)),
                                        totalParts: Math.ceil(selectedRoads.length / 50000),
                                        features: geojson.features.length
                                    }
                                };
                                
                                // สร้างและบันทึกไฟล์ส่วนย่อย
                                const partBlob = new Blob([JSON.stringify(partGeojson, null, 2)], { 
                                    type: "application/json" 
                                });
                                const partUrl = URL.createObjectURL(partBlob);
                                const partLink = document.createElement("a");
                                partLink.href = partUrl;
                                partLink.download = `${partFileName}_${new Date().getTime()}.geojson`;
                                document.body.appendChild(partLink);
                                partLink.click();
                                document.body.removeChild(partLink);
                                URL.revokeObjectURL(partUrl);
                                
                                debugLog(`บันทึกไฟล์ส่วนที่ ${Math.ceil((batchIndex + 1) / (50000 / batchSize))} จำนวน ${geojson.features.length} รายการ`, "success");
                                
                                // ล้างข้อมูลที่ส่งออกไปแล้วเพื่อประหยัดหน่วยความจำ
                                geojson.features = [];
                                
                                // แสดงข้อความแจ้งเตือน
                                gridStatus.textContent = `บันทึกส่วนที่ ${Math.ceil((batchIndex + 1) / (50000 / batchSize))} จาก ${Math.ceil(selectedRoads.length / 50000)} ส่วน`;
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }

                        // รวมจำนวนไฟล์ทั้งหมดที่ส่งออก
                        const totalParts = Math.ceil(selectedRoads.length / 50000);
                        
                        // ถ้ามีข้อมูลที่ยังไม่ได้ส่งออก หรือเป็นกรณีที่ข้อมูลไม่เกิน 50,000 รายการ
                        if (geojson.features.length > 0 || totalParts === 0) {
                            gridStatus.textContent = "กำลังบันทึกไฟล์...";
                            
                            // สร้างชื่อไฟล์
                            let fileName = `roads_${name}_utm47n_${new Date().getTime()}`;
                            if (totalParts > 1) {
                                fileName = `roads_${name}_part${totalParts}_utm47n_${new Date().getTime()}`;
                                
                                // อัพเดทข้อมูล metadata
                                geojson.metadata.partNumber = totalParts;
                                geojson.metadata.totalParts = totalParts;
                                geojson.metadata.features = geojson.features.length;
                            }
                            
                            // สร้างและบันทึกไฟล์
                            const blob = new Blob([JSON.stringify(geojson, null, 2)], { 
                                type: "application/json" 
                            });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement("a");
                            a.href = url;
                            a.download = `${fileName}.geojson`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            debugLog(`บันทึกไฟล์ ${fileName}.geojson จำนวน ${geojson.features.length} รายการ`, "success");
                        }

                        // แสดงสรุปผลการส่งออก
                        const endTime = Date.now();
                        const totalTime = ((endTime - startTime) / 1000).toFixed(1);
                        
                        gridStatus.textContent = "ส่งออกข้อมูลเสร็จสิ้น";
                        
                        if (totalParts > 1) {
                            gridDetails.textContent = `ส่งออกทั้งหมด ${selectedRoads.length} รายการ แบ่งเป็น ${totalParts} ไฟล์ (${totalTime} วินาที)`;
                            showNotification(`ส่งออกทั้งหมด ${selectedRoads.length} รายการ แบ่งเป็น ${totalParts} ไฟล์ เสร็จสิ้น`, "info", 5000);
                        } else {
                            gridDetails.textContent = `ส่งออกทั้งหมด ${selectedRoads.length} รายการ (${totalTime} วินาที)`;
                            showNotification(`ส่งออก ${selectedRoads.length} รายการเสร็จสิ้น`, "info", 5000);
                        }
                        
                        // ซ่อนการแสดงสถานะหลังจากเวลาผ่านไป
                        setTimeout(() => {
                            gridProcessContainer.style.display = 'none';
                            loadingMessage.style.display = "none";
                        }, 5000);
                    } catch (error) {
                        console.error("Error exporting data:", error);
                        loadingMessage.textContent = "เกิดข้อผิดพลาดในการส่งออกข้อมูล";
                        debugLog(`เกิดข้อผิดพลาดในการส่งออกข้อมูล: ${error.message}`, "error");
                        
                        // แสดงข้อผิดพลาดในกรณีเกิดปัญหา
                        gridStatus.textContent = "เกิดข้อผิดพลาด";
                        gridDetails.textContent = error.message || "ไม่สามารถส่งออกข้อมูลได้";
                        
                        // แสดงข้อความแนะนำเพิ่มเติม
                        setTimeout(() => {
                            gridDetails.textContent += " - ลองลดขนาดพื้นที่เลือกและลองอีกครั้ง";
                        }, 2000);
                        
                        showNotification("เกิดข้อผิดพลาดในการส่งออกข้อมูล โปรดลองใหม่อีกครั้ง", "warning", 5000);
                    }
                    
                    return true;
                }
                
                function toggleDrawingMode() {
                    isDrawing = !isDrawing;
                    drawPolygonButton.classList.toggle("active");
                    if (isDrawing) {
                        sketch.create("polygon");
                    } else {
                        sketch.cancel();
                    }
                }

                function clearSelection() {
                    selectionLayer.removeAll();
                    exportPreviewLayer.removeAll();
                    gridLayer.removeAll();
                    selectedRoads = null;
                    processedIds = {}; // ล้าง ID ที่เคยประมวลผล
                    processCount = 0; // รีเซ็ตการนับจำนวนครั้ง
                    unprocessedAreaGrids = []; // ล้างข้อมูลกริดที่ยังไม่ได้ประมวลผล
                    exportButton.disabled = true;
                    previewButton.disabled = true;
                    gridProcessButton.style.display = 'block';
                    document.getElementById("processingStats").style.display = "none";
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                    
                    debugLog("ล้างข้อมูลการเลือกทั้งหมด", "info");
                    
                    // ลบข้อความแสดงผลและปุ่มเพิ่มเติมที่อาจมีการสร้างขึ้น
                    const additionalButtons = gridProcessContainer.querySelectorAll("button:not(#gridProcessButton)");
                    additionalButtons.forEach(button => button.remove());
                    
                    showNotification("ล้างข้อมูลการเลือกเรียบร้อยแล้ว", "info", 3000);
                }

                // Event Handlers
                drawPolygonButton.addEventListener("click", toggleDrawingMode);
                clearSelectionButton.addEventListener("click", clearSelection);
                
                // Toggle debug panel
                document.getElementById("debugToggle").addEventListener("click", function() {
                    const debugPanel = document.getElementById("debugPanel");
                    debugPanel.style.display = debugPanel.style.display === "none" ? "block" : "none";
                });

                sketch.on("create", async (event) => {
                    if (event.state === "complete") {
                        const polygon = event.graphic.geometry;
                        await processRoadsByGrid(polygon, 'draw');
                        isDrawing = false;
                        drawPolygonButton.classList.remove("active");
                    }
                });

                function updateSelectOptions(boundaries) {
                    const select = document.getElementById("boundarySelect");
                    select.innerHTML = '<option value="">เลือกขอบเขตผัง</option>';
                    
                    boundaries.forEach(name => {
                        const option = document.createElement("option");
                        option.value = name;
                        option.textContent = name;
                        select.appendChild(option);
                    });
                }

                function loadBoundaries() {
                    const query = new Query({
                        where: "1=1",
                        outFields: ["NAME"],
                        returnDistinctValues: true,
                        returnGeometry: false
                    });

                    boundariesLayer.queryFeatures(query)
                        .then(function(results) {
                            const select = document.getElementById("boundarySelect");
                            const boundaries = results.features
                                .map(feature => feature.attributes.NAME)
                                .filter(name => name)
                                .sort();
                            
                            select.dataset.allBoundaries = JSON.stringify(boundaries);
                            updateSelectOptions(boundaries);
                            loadingMessage.style.display = "none";
                            debugLog(`โหลดขอบเขตผังเรียบร้อยแล้ว ${boundaries.length} รายการ`, "success");
                        })
                        .catch(function(error) {
                            console.error("Error loading boundaries:", error);
                            loadingMessage.textContent = "เกิดข้อผิดพลาดในการโหลดข้อมูล";
                            debugLog(`เกิดข้อผิดพลาดในการโหลดขอบเขตผัง: ${error.message}`, "error");
                        });
                }

                function filterBoundaries() {
                    const input = document.getElementById("searchInput");
                    const select = document.getElementById("boundarySelect");
                    const searchTerm = input.value.toLowerCase();
                    
                    const allBoundaries = JSON.parse(select.dataset.allBoundaries || '[]');
                    const filteredBoundaries = allBoundaries.filter(name => 
                        name.toLowerCase().includes(searchTerm)
                    );
                    
                    updateSelectOptions(filteredBoundaries);
                    debugLog(`กรองขอบเขตผังด้วยคำค้นหา "${searchTerm}" พบ ${filteredBoundaries.length} รายการ`);
                }

                async function handleBoundarySelect(name) {
                    exportPreviewLayer.removeAll();
                    selectionLayer.removeAll();
                    gridLayer.removeAll();
                    selectedRoads = null;
                    processedIds = {}; // ล้าง ID ที่เคยประมวลผล
                    processCount = 0; // รีเซ็ตการนับจำนวนครั้ง
                    unprocessedAreaGrids = []; // ล้างข้อมูลกริดที่ยังไม่ได้ประมวลผล
                    document.getElementById("processingStats").style.display = "none";
                    
                    const gridProcessContainer = document.getElementById('gridProcessContainer');
                    gridProcessContainer.style.display = 'none';
                    
                    if (!name) {
                        exportButton.disabled = true;
                        previewButton.disabled = true;
                        roadsLayer.definitionExpression = "1=1";
                        boundariesLayer.definitionExpression = "1=1";
                        return;
                    }

                    debugLog(`เลือกขอบเขตผัง "${name}" เริ่มการประมวลผล`);
                    exportButton.disabled = true;
                    previewButton.disabled = false;
                    boundariesLayer.definitionExpression = `NAME = '${name}'`;

                    const query = boundariesLayer.createQuery();
                    query.where = `NAME = '${name}'`;
                    query.returnGeometry = true;
                    
                    try {
                        const results = await boundariesLayer.queryFeatures(query);
                        if (results.features.length > 0) {
                            currentBoundaryGeometry = results.features[0].geometry;
                            
                            // คำนวณขนาดพื้นที่
                            const areaInSqKm = geometryEngine.geodesicArea(currentBoundaryGeometry, "square-kilometers");
                            debugLog(`พื้นที่ขอบเขตผัง "${name}" ขนาด ${areaInSqKm.toFixed(2)} ตร.กม.`);
                            
                            view.goTo(currentBoundaryGeometry.extent.expand(1.2));
                            
                            // ถ้าพื้นที่มีขนาดใหญ่มาก ให้แสดงข้อความเตือน
                            if (areaInSqKm > 500) {
                                showNotification(`พื้นที่มีขนาดใหญ่มาก (${areaInSqKm.toFixed(0)} ตร.กม.) การประมวลผลอาจใช้เวลานาน`, "warning", 5000);
                            }
                            
                            await processRoadsByGrid(currentBoundaryGeometry, 'boundary');
                        }
                    } catch (error) {
                        console.error("Error querying features:", error);
                        debugLog(`เกิดข้อผิดพลาดในการค้นหาขอบเขตผัง: ${error.message}`, "error");
                    }
                }

                // เพิ่มการเชื่อมโยงปุ่ม "ประมวลผลซ้ำ" กับฟังก์ชัน
                document.getElementById("gridProcessButton").addEventListener("click", function() {
                    // เรียกฟังก์ชันประมวลผลซ้ำโดยใช้พื้นที่เดิม
                    if (currentBoundaryGeometry) {
                        // กรณีเลือกจากเมนู dropdown
                        processRoadsByGrid(currentBoundaryGeometry, 'boundary');
                    } else if (selectionLayer.graphics.length > 0) {
                        // กรณีวาดพื้นที่เอง
                        const geometry = selectionLayer.graphics.getItemAt(0).geometry;
                        processRoadsByGrid(geometry, 'draw');
                    } else {
                        // แจ้งเตือนกรณีไม่มีพื้นที่เลือก
                        loadingMessage.style.display = "block";
                        loadingMessage.textContent = "กรุณาเลือกขอบเขตหรือวาดพื้นที่ก่อนประมวลผลซ้ำ";
                        setTimeout(() => {
                            loadingMessage.style.display = "none";
                        }, 3000);
                        
                        showNotification("กรุณาเลือกขอบเขตหรือวาดพื้นที่ก่อนประมวลผลซ้ำ", "warning", 3000);
                    }
                });

                // Event listeners
                document.getElementById("searchInput").addEventListener("input", filterBoundaries);
                document.getElementById("boundarySelect").addEventListener("change", function(e) {
                    handleBoundarySelect(e.target.value);
                });
                document.getElementById("previewButton").addEventListener("click", previewExportRoads);
                document.getElementById("exportButton").addEventListener("click", function() {
                    exportRoadsToGeoJSON();
                });
                
                // Initialize
                view.when(() => {
                    loadBoundaries();
                    view.ui.add(sketch, {
                        position: "manual"
                    });
                    
                    // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อแผนที่โหลดเสร็จ
                    checkRoadLayerGeometryType();
                    debugLog("เริ่มต้นแอปพลิเคชันเรียบร้อยแล้ว", "success");
                });
                
                // เพิ่มการตรวจสอบประเภทชั้นข้อมูลถนนเมื่อมีการเปลี่ยนแปลงเลเยอร์
                    roadsLayer.when(() => {
                    checkRoadLayerGeometryType();
                });
                
                // เพิ่มการตรวจจับ error ทั่วไปในแอปพลิเคชัน
                window.addEventListener('error', function(event) {
                    debugLog(`เกิดข้อผิดพลาดในแอปพลิเคชัน: ${event.message} ที่ ${event.filename}:${event.lineno}`, "error");
                    showNotification("เกิดข้อผิดพลาดในแอปพลิเคชัน กรุณารีเฟรชหน้าจอหากพบปัญหาการทำงาน", "warning", 5000);
                });
                
                // เพิ่มฟังก์ชันสำหรับตรวจสอบการใช้งานหน่วยความจำ (ใช้งานได้เฉพาะใน Chrome)
                function checkMemoryUsage() {
                    if (window.performance && window.performance.memory) {
                        const memoryInfo = window.performance.memory;
                        const usedHeapSize = memoryInfo.usedJSHeapSize / (1024 * 1024);
                        const totalHeapSize = memoryInfo.totalJSHeapSize / (1024 * 1024);
                        const percentUsed = (usedHeapSize / totalHeapSize) * 100;
                        
                        debugLog(`หน่วยความจำที่ใช้: ${usedHeapSize.toFixed(1)} MB / ${totalHeapSize.toFixed(1)} MB (${percentUsed.toFixed(1)}%)`, 
                            percentUsed > 80 ? "warning" : "info");
                        
                        // แจ้งเตือนหากหน่วยความจำเหลือน้อย
                        if (percentUsed > 80) {
                            showNotification("หน่วยความจำเหลือน้อย อาจเกิดปัญหาการทำงานหากมีข้อมูลจำนวนมาก", "warning", 5000);
                        }
                    }
                }
                
                // ตรวจสอบหน่วยความจำทุก 30 วินาที (ถ้าเบราว์เซอร์รองรับ)
                if (window.performance && window.performance.memory) {
                    setInterval(checkMemoryUsage, 30000);
                }
            }
        });
    </script>
</body>
</html>